
купил на stepik за 2000 с промокодом (был 2200) - 
https://stepik.org/116411
-
видео-лекции с дублированием теории в виде конспекта

в telegram этот курс в версии 2022 года скачанный - 29.08.2022 


************************************

ЕЩЁ МАТЕРИАЛЫ (ДРУГИХ АВТОРОВ) -

Русов -
https://youtube.com/playlist?list=PLKbJd47Kcbju2Vhi-FL7AI14vItVmGYk-

Леша Маршал
https://youtu.be/MmbVEwYnWTs?si=vkjupUOuUalJBtaY

1 -
https://docs.google.com/spreadsheets/d/1hBWUsc0IWrT6Zt_8BbYVvFuClm1Z_WnajWP9EMFrXHU/edit?gid=293292945#gid=293292945

2 -
https://docs.google.com/document/d/1sd8mMhk0UYZWvpuCL9ocP9YgPzh14vGqcUKKhHZOylA/edit?tab=t.0

3 -
https://docs.google.com/spreadsheets/d/1GL7IUc3xLrdfdH9eaAiTks0k6PW8ESIRRasBEAtc7As/edit?gid=2139852275#gid=2139852275

Ещё видео и материалы -
https://youtube.com/watch?v=8-lEjM0FhTg&si=qiIq-vkeFpJ0_GfQ
+
https://prostoitblog.ru/testirovshhik-qa-s-nulya-polnyj-kurs-dlya-nachinayushhih/

50+ тренажеров -
https://www.rusau.net/articles#!/tfeeds/854445515741/c/%D0%A2%D1%80%D0%B5%D0%BD%D0%B0%D0%B6%D0%B5%D1%80%D1%8B


************************************

ОБЯЗАТЕЛЬНО - конспектировать самому каждое видео, а уже потом читать текстовую версию 


- купил у вас полное собрание курсов по тестированию(6 курсов),в каком порядке их желательно проходить?
>>>
Тестирование ПО с нуля до Специалиста +
+
Автоматизация Selenium +
+
Автоматизация API +
+
Python+SQL -
+
Нагрузочное тестирование -
+
Симулятор Собеседования - перед началом поиска работы -


на мой взгляд это оптимальный вариант, там как работа с базами данных предполагает написание кода, следовательно будет удобнее продолжить его писать уже на языке программирования, параллельно с ручным тестированием, но пропорционально, как я указал. С момента написания этого видео курсы очень увеличивались и по количеству материала и особенно по практике,  но рекомендации те же
+
Если Вы уже имеете навык написания кода, то лучше взять вот этот : Программа курса – Тестирование ПО:Автоматизация и Программирование.Python.Selenium – Stepik - Selenium это самый востребованный инструмент на рынке, просто он сложнее чем тестирование серверной части
+
Если навыков нет, то можете взять Программа курса – Тестирование ПО: Автоматизация и Программирование на Python. API – Stepik, он проще, но Selenium все равно придется учить
+
Либо можете взять вот этот пакет курсов, который объединяет в себя сразу два эти курса, это 1)дешевле 2)пройдя курс по базовому программированию и ООП, Вы поймете свои силы, если далось нормально, то Selenium, если нет, то сперва API


основные пути развития тестировщика:
+
1.Ручной тестировщик - закончили курс и сразу начинаете искать работу
+
2.Перспектива автоматизатора - закончили ручное тестирование, начинаете изучать автоматизацию тестирования на python или java
+
3.Нагрузочное тестирование - закончили ручное тестирование, начинаете изучать необходимые инструменты, технологии и языки для него
+
4.Тестирование безопасности - база ручного тоже нужна ,а дальше там своя специфика
+
5.Мобильное тестирование - закончили ручное тестирование и начинаете изучать эмуляторы, симуляторы, учите автоматизацию для мобильных устройств
+
Как видите везде нужна база ручного тестирования, а далее уже на Ваш вкус или куда судьба занесет. Шансов найти работу только после курса по ручному тестированию разумеется меньше, чем если будете обладать к примеру навыками автоматизации, так как работодатель если и рассматривает людей без опыта, то хочет гения за копейки. Увы, сейчас рынок такой. 



************************************

1.1 - Как стать тестировщиком. План эффективного обучения -

настоятельно рекомендуется конспектировать видео, для дальнейшего повторения и подготовки к собеседованиям



По всем вопросам обращайтесь - aleksandr_stepik@mail.ru



Рекомендуемое время обучения, на данном курсе, от 2 часов в день в будни, и от 4 часов в выходные дни



Яндекс.дзен, там есть стать и они по факту являлись сценариями к моим видео, там всё в тексте https://zen.yandex.ru/id/622a3070d5872b0d6e34ea6c



Курс "Тестирование ПО с Нуля до Специалиста" - https://stepik.org/course/116411/
+
Курс "Тестирование: Автоматизация и Программирование на Python. Selenium" - https://stepik.org/course/120491/
+
Курс "Тестирование: Автоматизация и Программирование на Python. API" - https://stepik.org/course/127716/
+
Курс "Программирование на Python с Нуля + Работа с SQL" - https://stepik.org/course/134773/
+
Курс "Симулятор собеседования для Тестировщика" - https://stepik.org/course/118983/
+
Курс "Нагрузочное тестирование ПО с помощью Jmeter" - https://stepik.org/course/122902/

 

Так же, жду Вас на своем Youtube канале - https://www.youtube.com/channel/UCq-PbXBWej-lxniUkyEmUxw

Телеграмм-канал с новостями и тематическими видео о Тестировании и Мире IT - https://t.me/QaTestingChannel



путь автора - 
+
учиться можно где угодно и при любых условиях 
+
изучал python 
+
изучал selenium - автоматизация тестирования интерфейсов 
+
реальная мотивация - (мой дедлайн - март 2025)
+
учеба стоит на первом месте 
+
выделять время - ежедневно по 2 часа 
+
нужен структурированный курс без воды и технические уроки
+
sql - как составлять таблицу, изменять в ней данные, простые запросы - особо на SQL время не тратить
+
изучение python 
+
рассказ о себе + довести до автоматизма 2 интервью 
+
API легче чем Selenium 
+
резюме - после 2.5 месяцев обучения 
+
не затягивать и не становиться вечным студентом 
+
максимально откликаться на вакансии - 200 откликов в день на hh.ru
+
в ютуб - каналы - 
АйТиБорода
Мы обречены
В офисе - https://www.youtube.com/@itdeploy/videos (видео с HR - https://www.youtube.com/watch?v=W93wk-Fy2lk)
Миша Ларченко 



книги по тестированию - кто-то Куликова или Савина советуют, я их не читал, там уж слшком много страниц, быстрее пройти курс. Дома пылится книга "Как тестируют в Гугл", все не могу добраться
+
читала Куликова Тестирование ПО, базовый курс. Подробно рассказывает, особенно хорошо дает определения терминов. А у Савина описание и рассказы о тестировании, и в целом о разработке, больше похожи на розовые мечты, чем на суровую реальность айти в России



как я бы делал сейчас:
+
1. после прохождения каждого урока перечитывал бы конспект по данному уроку
+
2.после прохождения блока перечитал бы конспект по данному блоку
+
3.после прохождения всего курса каждый день читал бы хотя бы 1 раз весь конспект
+
я не вижу смысла разбивать зубреж конспекта на модули, нужно видеть картину в целом. Я когда зубрил свой, то некоторые разделы со временем пропускал, так как они уже знались наизусть, а проблемные наоборот повторял.



вот понять и применить это другое,  тут как я люблю говорить "практика - это неотъемлемая часть обучения", именно поэтому я даю своим студентам на курсе по автоматизации задачи, которые максимально приближенны к тем с которыми им придется столкнуться и развивающие мышление и скиллы. Думаю мне тут не дадут соврать) Проходите заново курс, уже вдумчиво, с конспектом, с практикой, подключайте мышление. Я вчера общался со студентом, который хотел больше практики, но она на поверхности - прошли урок к примеру по позитивному и негативному тестированию, техникам тест дизайна, на которых мы учимся тестировать, после открыли любой сайт и тестируете, ищите баги, проверяете сценарии. Прошли задания по написанию тестовых сценариев, там нужно всех документов по 10 штук, сдали, получили оценку, а потом для себя 100 сделали, закрепили...Прошли SQL, начали учить программирование, пока в уме еще есть понимание логики...ну и конечно же "стиснуть зубы и пахать"



************************************

1.2 - Обязательно к прочтению - Инструкция по обучению и выполнению ДЗ
+



************************************

1.3 - Инструкция по выполнению тестовых заданий -
+



************************************

2.1 - Что такое тестирование? Как стать тестировщиком? -

тестирование - это процесс, направленный на исследование, испытание програмного продукта на соответствие ожидаемого результата поведения программного продукта фактическому поведению программного продукта 

процесс разработки програмного продукта начинается с составления требований 

требования - документ содержащий описание того, что должно быть реализовано в програмном продукте (визуальный шаблон, описание бизнес-логики продукта, на какой платформе будет работать, и т.д.)

баг (дефект) - отклонение фактического поведения ПО от ожидаемого результата поведения ПО 

тестировщик - это специалист, обеспечивающий качество продукта, проверяет фактическую работу продукта на соответствие требованиям заказчика и отсутствие отклонений от требуемой бизнес-логики 

что тестирует тестировщик - 
- веб-продукт (веб-приложение)
- мобильные приложения 
- игры 
- железо 
- десктопные приложения 

способы которыми тестировщик пользуется в своей работе - 
- ручное тестирование 
- использование вспомогательного ПО 
- автоматизированное тестирование 

4 типа тестировщиков - 
- ручной тестировщик 
- ручное тестирование + использование вспомогательного ПО 
- ручное тестирование + использование чужого проекта по автоматизации 
- чистый автоматизатор (авто-тестер) - пишут только код 

чтобы сейчас устроиться тестировщиком, нужно - 
- изучить ручное тестирование 
- изучить вспомогательное ПО 
- изучить автотестирование 
- хорошо составленное резюме 
- хорошие софт-скилы 

можно обучиться за 3 месяца 
порог входа ниже чем у разработчиков 
меньше вакансий на рынке чем у разработчиков 



************************************

2.2 - Этапы разработки и тестирования ПО. Основные роли в IT -

жизненный цикл разработки программного продукта (SDLC) - это процесс, направленный на создание, поддержание работоспособности, качества и надежности програмного продукта 

этапы жизненного цикла программного продукта (важно запомнить эти 6 этапов) - 
- требования 
- проектирование 
- разработка 
- тестирование 
- релиз (загрузка на продакшн-сервер)
- поддержка (чаты, электронная почта, телефон)

этапы жизненного цикла тестирования програмного продукта (STLC – Software testing lifecycle) - 
- анализ требований 
- тестовое планирование 
- написание тестовых сценариев 
- подготовка тестовой среды 
- выполнение тестов 
- заверщающая фаза 

более детально рассмотрим каждый из них -

Анализ требований -
На данном этапе, мы анализируем наши требования на логичность и отсутствие противоречия в требованиях друг другу. Более подробнее мы рассмотрим этот вопрос, когда будем разбирать работу с требованиями

Тестовое планирование -
Оно включает в себя составление плана тестирования, в котором будут указаны сроки, способы и методы тестирования.

Написание тестовых сценариев -
Очень важный этап, в котором мы производим написание тестовых сценариев тестирования программного продукта, то есть сценариев и вариантов комбинаций исходных данных и действий. Подготовка тестовых данных - то есть создание пользователей от чьих лиц мы будем тестировать. Ведь мы всегда имитируем деятельность, конечного пользователя.

Подготовка тестовой среды -
Это подготовка стендов (серверов) для тестирования, то есть стенда, которым будут пользоваться наши тестировщики, с актуальной версией продукта, в этом нам помогают DevOps. Это может происходить локально, удаленно или же на специализированных сервисах. Подготовка вспомогательного ПО, настройка различных доступов.

Выполнение тестов -
На данном этапе происходит сам процесс тестирования программного продукта, используя тестовые сценарии, написанные нами ранее.

Завершающая фаза -
Если в результате выполнения нашего тестирования, тесты выполнены успешно, то происходит передача протестированного функционала в Релиз



************************************

2.3 - Что такое QA и QС. Уровни должностей в IT. Пути развития в QA -

QA - обеспечение качества (работает на всех уровнях - от написания текстовой документации до релиза) Это включает в себя обучение персонала, подбор инструментов, формат написания документации, как будет проходить тестирования на различных стендах, приемочное тестирование и т.д.

QC - контроль качества - Это специалисты, которые, уже реализуют данную стратегию: пишут тестовую документацию, производят тестирование. Они проверяют соответствует программный продукт требованиям или нет.

Такое разделение есть только в крупных компаниях и в основном в иностранных компаниях, в большинстве случаев в России, странах СНГ говорят просто тестировщик или QA тестировщик.

Теперь рассмотрим уровни должностей или старшинства в IT, внутри одной специальности:

1)Junior – это младший специалист, с опытом до года, основная задача которого писать и проходить тест-кейсы. Junior в основном занимается ручным тестированием, с небольшим навыком работы с базами данных и вспомогательным софтом. В реалиях нынешнего рынка, данный специалист уже имеет знания по базовому программированию и автоматизации, но не обязательно будет их применять.

2)Middle – это специалист среднего уровня. Уверенный специалист с опытом 1-3 года, он, как и junior занимается ручным тестированием и хорошо работает с базами данных и вспомогательным ПО. Так же уже должен иметь начальные навыки программирования, писать автоматизированные тесты на проектах автоматизации, которые были написаны до них;

3)Senior – почетное звание, специалист с опытом более 3 лет. Уверенно знает языки программирования, и не один, инструменты, которые используют при построение проекта по автоматизации и самостоятельно способен написать его;

4)Team Lead – лидер команды, человек, который вырос из senior, он занимается менеджерской функцией, отвечает за качество продукта на проекте, контролирует и направляет свою команду тестировщиков.

Важная ремарка по автоматизации, дело в том, что такие жесткие требования начались примерно с начала 2022 года, так что вы легком можете встретить тестировщика с опытом в 5 лет, который не будет иметь данных навыков, в связи с тем, что когда он устраивался, они не требовались, а сам он к примеру не хочет развиваться в этом направлении.

есть еще один путь - это путь перехода тестировщика автоматизатора, в независимости от его должности: junior, middle, senior в разработчики. Но для этого требуется высокий навык программирования и не всегда это выгодно по зарплат


ДЗ - 

Опишите  процесс разработки программного продукта, перечислив все основные этапы (раскрыть их), прокомментировав роли всех ее участников, на каждом этапе -

1. Выработка требований по ПО - заказчик с руководителем проекта устанавливают, какой продукт нужен заказчику, что и как он должен делать, фиксируют требования в письменном виде 

2. Проектирование - на основе требований системный аналитик, дизайнер, фронт и бек разработчики проектируют продукт в зонах своей ответственности 

3. Разработка - дизайнер делает дизайн, фронт реализует дизайн на HTML, CSS, JS, бекэндер проектирует базы данных и пишет бизнес-логику

4. Тестирование - тестировщик на основании жизненного цикла тестирования програмного продукта подготавливает и проводит тестирование, в случае необходимости указывает на ошибки (баги) разработчикам, после исправления ошибок тестирует снова, пока фактическое поведение продукта не станет полностью совпадать с ожидаемым поведением

5. Релиз (загрузка продукта на продакшн-сервер) - бекэндеры и девопс загружают получившуюся версию продукта на сервер, где ПО становиться доступно пользователям 

6. Поддержка - осуществляется поддержка и консультирование клиентов по ньюансам работы продукта специалистами поддержки, при необходимости привлекаются девопс, администратор баз данных, разработчики - для настройки продукта под конкретные нужды пользователей 


ответ автора - 
от Вас на собеседовании будут ждать подобный ответ: 
"В процесс разработки программного продукта входят следующие этапы: 
1. требования. Руководитель проекта составляет требования для команды разработчика, координирует их работу. Бизнес аналитик разрабатывает логику продукта. 
2. проектирование. Руководитель проекта совместно с дизайнерами проектирует графически проект. Дизайнер визуально воплощает его в макеты. 
3. разработка. Разработчики разворачивают серверы, базы данных. Разрабатывают фронтенд часть и бэкенд. 
4. тестирование. тестировщики согласно требованиям проводят тестирование программного продукта, и если находят отклонения, то отправляют на разработку. если все исправно, то в релиз. 
5. релиз. 
6. поддержка. специалисты тех. поддержки делятся на три линии: 1-справочная служба по несложным вопросам. 2- специалисты могут просмотреть по базам данных, и другим система и дать более техническую консультацию, по возможности устранить неполадки. 3- специалисты уровня разработки могут решить проблему, Конда она связана с базами данных или сервером." 



************************************

2.5 - Виды окружений - 

виды стендов (серверов) для развертывания программного продукта - 

- local - локально - это компьютер разработчика 

- dev - development - стенд для нескольких рабработчиков проекта 

- test - стенд для тестирования, обычно тестировщик заводит на нем несколько пользователей для тестирования (у некоторых компаний dev и test - это один и тот же стенд, но в идеале это должно быть два разных стенда)

- pre-prod - стенд для проверки перед релизом - по характеристикам должен быть очень приближен к проду, так как на нем проводится тестирование производительности

- prod - стенд для готовой версии продукта к которому имеют доступ пользователи 



************************************

3.1 - Основные принципы тестирования - 

7 принципов тестирования - 

- тестирование демонстрирует наличие дефектов (если при тестировании не найдены баги, это не означает что их нет, так как тестирование снижает вероятность дефектов (багов), но не означает что их нет)

- исчерпывающее тестирование (проверить вообще все варианты невозможно, нужно проверять самые ожидаемые комбинации и воспользоваться попарным тестированием - про попарное тестирование - https://habr.com/ru/company/otus/blog/592575/)

- ранее тестирование (чтобы найти дефекты как можно раньше, следует начинать тестирование на ранних стадиях цикла разработки ПО, проверять требования на логичность и непротеворечивость, проверять код разработчиков)

- скопление дефектов (80% дефектов находятся в 20% продукта, и наоборот, 20% дефектов находятся в 80% продукта. Необходимо предусмотреть, каким функционалом будет пользоваться наш конечный пользователь продукта и уделить ему больше внимания, а также предусмотреть проблематичные участки, например которые требуют ввода данных в поля и где есть логика зависимости заполнения полей. Особенно это важно в финансовых продуктах, к примеру в банковском софте.)

- парадокс пестицида - Если в тестировании продукта использовать один и тот же сценарий снова и снова, то со временем этот набор тестов перестанет выявлять новые баги. Ведь после каждого нахождения багов, разработчики будут их исправлять, и при следующем тестировании скорее всего этот баг уже не обнаружится. Поэтому постоянно нужно придумывать новые сценарии тестирования и проверять с помощью них, чтоб проверить наибольшее количество сценариев.

- тестирование зависит от контекста - Тестирование проводится по-разному, в зависимости от контекста. Например, банковский софт, в котором критически важна безопасность, тестируется иначе, чем новостной портал или портал прогноза погоды. А программный продукт с высоким количеством пользователей должен тестироваться на производительность более серьезнее, чем сайт, на котором минимальное посещение в сутки.

- заблуждение об отсутствии ошибок - Отсутствие найденных дефектов при тестировании не всегда означает готовность продукта к релизу. Продукт должен быть удобен и приятен в использовании, важно сохранить клиента, сделать так чтобы продукт удовлетворял ожиданиям и потребностям пользователя.

Очень важно чтобы вы поняли эти принципы и могли их применять в своей практике, ведь основная задача тестирования, это проверить продукт на соответствие заявленным требованиям, чтобы подтвердить его качество. Ведь чем больше дефектов мы сможем устранить до попадания в релиз, тем большим спросом будет пользоваться наш продукт, сохранится результат и минимизируются затраты на их устранения.

- рецензия автора курса на мой ответ - 
1)не раскрыт этап Проектирование, не указано чтотимннно происходит на фронтенде и бэкенде 
2)на этапе Поддержка необходимо указать все 3 линии поддержки и прописать что на них происходит

то же самое, но кратко - 

1. Тестирование демонстрирует наличие дефектов. Если не нашли баги, не значит, что их нет.

2. Исчерпывающее тестирование. Не получится протестировать абсолютно всё, либо не хватит денег, либо времени, либо то и то. В англоязычных есть in scope/out of scope, т.е. что в области исследования(тестирования) и вне его.

3. Раннее тестирование. Начать тестирование стоит как можно на более ранних стадиях. Чем раньше найдём, тем лучше и будет способствовать уменьшению последующих расходов.

4. Скопление дефектов. Принцип парето 80/20, действует практически везде (лучше погуглить) в жизни.

5. Парадокс пестицида. Нужно придумывать разные варианты/сценарии тестирования, так сказать, от одного средства "глаза" замыливаются.

6. Тестирование зависит от контекста. Например, банковский софт тестируется иначе, чем те же новостные порталы.

7. Заблуждение об отсутствии ошибок. Отсутствие дефектов не всегда значит готовность к релизу. Важно учитывать также удобство, приятно использовать продукт и степень удовлетворённость/ожидание клиента.



************************************

3.2 - Функциональное и нефункциональное тестирование -

классификация тестирования - 
- по уровню функционального тестирования 
- по уровню детализации приложения 
- по запуску кода на исполнение 
- в зависимости от исполнителей 
- по позитивности сценариями
- по цели тестирования 

классификация тестирования по уровню функционального тестирования -
- функциональное тестирование – тестирование которое направлено на проверку соответствия функциональных требований ПО к его реальным характеристикам. Подтверждение того, что наш продукт обладает всем функционалом, который требует заказчик. Функциональное тестирование отвечает на вопрос – что должен делать наш продукт?
- нефункциональное тестирование – направленно на проверку соответствия свойств ПО с его нефункциональными требованиями. Тестирование свойств, которые не относятся к функциональности системы – надежность, производительность и т.д. Нефункциональное тестирование отвечает на вопрос – как это должен делать наш продукт?

Виды функционального тестирования - 

- Дымовое тестирование (smoke test) — тестирование, которое проводится после появления нового билда. Направлено на проверку готовности разработанного продукта к проведению расширенного тестирования и определения общего качества продукта. Дает ответ готово ли приложение к выполнению своих основных функций. Давайте это рассмотрим на примере интернет магазина: Авторизуемся - производим выбор продукта – оплату - получаем подтверждение оплаты. Так же для примера рассмотрим сайт для размещения и скачивания фото. Ожидание совпадает с фактическим результатом. Должно быть быстрым.
К примеру: Авторизуемся -  производим выбор продукта – оплату - получаем подтверждение оплаты. 
Сразу уточню, в продукте может быть различный функционал. Например, возьмем сайт ВКонтакте. Это социальная сеть, основная его цель – это общение людей. Но она не заключается только в том, чтоб один человек зарегистрировался и мог написать другому зарегистрированному пользователю. По мимо писем, здесь так же есть возможность создавать сообщества, прослушивать музыку, смотреть видео, производить оплату и т.д, и для тестирования данных направлений так же проводится дымовое тестирование, например создание нового сообщества, прослушивание и подгрузка новой песни и т.д. Это очень важно понимать. Любую крупную бизнес-логику можно разбить на шаги, каждый этот шаг нужно тестировать, в том числе применяя дымовое тестирование.

- Тестирование критического пути (critical path) — направлено для проверки функциональности, используемой обычными пользователями во время их повседневной деятельности.
Основной тип тестовых испытаний, во время которого значимые элементы и функции приложения проверяются на предмет правильности работы при их стандартном использовании. Проверка типичных повседневных заданий пользователя. Выбор шрифта, возможность вставки текста, картинок, фильтры по цене и/или производителю товара и т.д
Давайте рассмотрим пример интернет-магазина – мы авторизовались, перешли в каталог продукции и начали производить фильтрацию результатов поиска
Другой пример – отправка сообщения в почтовом сервисе – изменение вида шрифта, цвета, размера и т.д

- Расширенное тестирование (extended) — направлено на исследование всей заявленной в требованиях функциональности.
Проверка нестандартного использования продукта (например, вводить не корректные логин и пароль в окне авторизации, работать на многих вкладках одновременно, подгрузка файлов недопустимых размеров или форматов. Максимально загружать нашу систему, проводить множество негативных тестов.



Виды нефункционального тестирования - 

1)Тестирование производительности (performance testing) – комплекс видов тестирования целью которых является проверка работоспособности, стабильности, потребления ресурсов и других атрибутов в условиях других сценариев использования и нагрузок
Это очень важный вид тестирование, ведь стабильность работоспособности нашего продукта – это очень важный показатель, ведь если наше приложение будет виснуть, не возвращать вовремя информацию, то пользователь перестанет им пользоваться.
Более подробно мы поговорим о данном виде тестирования в блоке по Нагрузочному тестированию, а сейчас давайте рассмотрим подвиды данного вида тестирования:
Давайте для пример установим дефолтное значение, то есть значение по умолчанию – что норма посещения нашего сайта одновременно – 1000 человек

-Нагрузочное (load testing) — определение или сбор показателей производительности и времени отклика программно-технической системы или устройства в ответ на внешний запрос с целью установления соответствия требованиям, предъявляемым к данной системе (устройству). 
– производительность в пределах нормы, например одновременное присутствие до 1000 пользователей на сайте (то есть наша норма), в идеале конечно установить это значение именно при 1000 пользователях

-Стресс (stress testing)- экстремальная нагрузка, в разы превышающая норму

Приведу пример, все мы знаем, что такое черная пятница, день в году, когда товары продаются с большой скидкой. Предположим, что у нас есть интернет-магазин, норма его посещения одновременно 1000 пользователей, наступает черная пятница и к нам на сайт заходит 5000 пользователей, что происходит – начинаются сбои, руководству магазина это не нужно. Именно поэтому важно производить данное тестирование, чтоб подготовиться к стресс нагрузкам

-Стабильность – проверка приложения при длительной работе

То есть происходит нагрузка нашей системы в пределах нормы, к примеру на день, неделю, месяц и смотрим как она будет себя вести

-Объемное (volume testing)– тестирование при увеличенных объемах обрабатываемых данных (например, 1000 пользователей отправляют одновременно сообщения или же загружают файлы)

2)Инсталляционное тестирование (installation testing) — тестирование, направленное на проверку успешной установки и настройки, обновления или удаления приложения. К примеру, проверка устанавливается ли наше мобильное приложение через плей-маркет, когда мы скачиваем с браузера нашего смартфона, установка с флешки, с компьютера и т.д
Проверяем обновление нашего приложение, возможность откатиться к предыдущей версии. Удаление нашего приложения, повторная установка и т.д

3)Проверка удобства (Usability) – проверка на удобство, соотношение дизайна ПП к функциональности, цветового оформления, текста, обучаемость и т.д то на сколько наш продукт удобен конечному пользователю. Это очень важно, так как наш продукт должен быть удобен и интуитивно понятен нашему пользователю, для того, чтоб он хотел пользоваться им снова и снова

4)Тестирование безопасности (security testing) — это стратегия тестирования, используемая для проверки безопасности системы, а также для анализа рисков, связанных с обеспечением целостного подхода к защите приложения, атак хакеров, вирусов, несанкционированного доступа к конфиденциальным данным.

5)Тестирование локализации(L10N) и интернационализации(I18N) –

-процесс адаптации нашего ПО к языку и культуре клиента (перевод, дата и время, символика, единицы измерения, цветов, валюта). К примеру, в некоторых странах используют как единицу расчета сантиметры, метры, километры, а в других дюймы, футы, мили. На сайтах должна быть возможность автоматического перевода единицы измерения или предусмотрен такой функционал.

-на сколько наш продукт может в дальнейшем адаптироваться к той или иной локации – особенности языка, удобность перестройки под него. Например, в азиатских странах.

6)Тестирование доступности(accessibility) – доступность людям с ограниченными возможностями, необязательно инвалиды

Тут можно привести пример с возможностью просматривать субтитры, например в том же ютубе, если у вас нет наушников, а вы не хотите пользоваться звуком, то можете включить субтитры. Или же возможность увеличить шрифт и размер кнопок на мобильном приложении. Аудио воспроизведение текста и т.д.



нагрузочное тестирование - до 1000 человек  включительно, выполняют различную деятельность на короткий промежуток времени

стресс-тестирование - более 2000 человек на короткий промежуток времени

стабильность - до 1000 человек  включительно, выполняют различную деятельность на неделю

объемное - до 1000 человек  включительно, выполняют одинаковую деятельность, например грузят файлы в письмо, в почтовом сервисе



ДЗ -

В данном ответе как пример продукта буду использовать мобильное приложение (игру).

I. Функциональное тестирование - это проверка того, что продукт (ПО) выполняет те функции (ту работу) которую должен выполнять.

1 - дымовое тестирование - мобильное приложение (игра) открывается, запускается, персонаж двигается, очки за игровые действия начисляются. 

2 - тестирование критического пути - выбор персонажей игры, возможность менять их характеристики, приобретать и менять предметы для улучшения силы персонажа и т.п.

3 - расширенное тестирование - попытка войти в игровой аккаунт используя неправильные логин и/или пароль
  
  
  
II. Нефункциональное тестирование - это тестирование свойств (качеств) продукта (надежность, удобство, нагрузоустойчивость).

1 - тестирование производительности (далее под буквами идут виды тестирования производительности):

- а - нагрузочное тестирование - проверяется как ведет себя мобильное приложение когда в нем недолго находится планируемое для одновременной работы в приложении количество пользователей (допустим если мы планируем что в приложении в среднем одномоментно будет 10_000 пользователей, то 10_000 или немного меньше)

- б - стресс-тестирование - проверяется как ведет себя мобильное приложение когда в нем находится количество пользователей, в несколько раз превышающее планируемое количество пользователей (есть ли сбои? подвисает или нет?)

- в - тестирование на сталильность - проверяется как ведет себя мобильное приложение когда в нем длительный период времени находится планируемое для одновременной работы в приложении количество пользователей

- г - объемное тестирование - проверяется как ведет себя мобильное приложение когда в нем планируемое для одновременной работы количество пользователей одновременно совершают какие-либо ресурсозатратные действия 


2 - инсталяционное тестирование - тестирование с целью проверки успешности установки, обновления, удаления приложения 

3 - проверка удобства - проводится с целью проверки максимального удобства приложения для пользователя - удобно ли расположены элементы управления, оптимальны ли шрифты текста, цветовая гамма для восприятия и т.п.

4 - тестирование безопасности - насколько безопасно приложение от утечки данных, атак хакеров, воздействию вирусов. 

5 - тестирование локализации и интернацинализации - меняются ли в приложении меры веса, длинны и т.п. в зависимости от региона использования приложения, качественно ли выполнен языковой перевод на язык региона, где используется приложение. 

6 - тестирование доступности - проверяется насколько приложение удобно для пользователей с ограниченными возможностями - управление приложением одной рукой, возможность увеличение шрифта/экрана, ввод информации голосом а не через клавиатуру, возможность вместо звука запустить субтитры, возможность озвучки текста голосом (звуком).



************************************

3.4 - Модульное (unit), интеграционное, системное и приемочное тестирование -

классификация тестирования -
- по уровню функционального тестирования 
- по уровню детализации приложения 
- по запуску кода на исполнение 
- в зависимости от исполнителей 
- по позитивности сценария 
- по цели тестирования 

разберем очень важную классификацию тестирования, а именно по уровню детализации приложения -

1)Модульное тестирование  или юнит-тестирование (англ. unit testing) — проводится для тестирования какого-либо одного логически выделенного и изолированного элемента (модуля) системы в коде. Проводится самими разработчиками, так как предполагает полный доступ к коду.

Модульное тестирование производят сами разработчики, не тестировщики. Для чего это нужно

Рассмотрим с вами идеальную ситуацию этапов разработки и тестирования программного продукта: разработчику поступает задача, для реализации некого функционала. Он пишет программный код, далее он сам должен руками это все проверить, а также написать юнит тест, который будет запускаться каждый раз, при сборке нового билда, то есть версии нашего продукта. Далее он передает его уже тестировщику, который проверяет уже различные сценарии тестирования данного функционала. То есть понятно, что разработчики не на столько углублены в процесс тестирования и его подходы, но они в любом случае должны проверить хотя бы позитивный сценарий руками. 

Идея юнит тестов состоит в том, чтобы писать тесты для каждой нетривиальной функции или метода. Это позволяет достаточно быстро проверить, не привело ли очередное изменение кода к регрессии, то есть к появлению ошибок в уже оттестированных местах программы, а также облегчает обнаружение и устранение таких ошибок.

2)Интеграционное тестирование (Integration testing) — тестирование, направленное на проверку корректности взаимодействия нескольких модулей, объединенных в единое целое.

Взаимодействие компонентов, модулей и иных систем между собой. Тестирование части системы, состоящей из 2-х и более модулей.

Приведу пример, у нас с вами есть возможность оплаты товара на сайте, разработчики разместили там платежную систему, которая связывает наш сайт с внешней системой банка, то есть это взаимодействие нескольких систем между собой. Мы проверяем прошла ли оплата в полной мере.

Другой пример – предположим, что мы разрабатываем сайт по доставке еды, пользователь выбрал любимые блюда, ввел нужный адрес в поле с адресными данными или решил выбрать «указать на карте». Как вы понимаете, разработчики сайта не будут разрабатывать свою карту города, не будут строить маршруты, они воспользуются уже разработанным данным функционалом, например яндекс или google картами и просто подключат данный функционал для нашего сайта. И мы проверяем что данный адрес действительно отображается корректно на нашем сайте, что пользователь не ввел несуществующий адрес.

Еще один пример, интернет-магазин, мы авторизовались, выбрали товар и перенесли в корзину. После чего мы проверяем, что у нас в корзине именно выбранный нами товар, по названию, характеристикам, цене.

Все три примера являются интеграционным тестированием, то есть проверкой взаимодействия нескольких модулей или систем между собой

3)Системное тестирование (System testing) — тестирование взаимодействия между всеми компонентами системы или разных систем между собой или тестирование интерфейсов, между которыми взаимодействует система. Полная проверка приложения, всех модулей, можно ли пройти весь бизнес путь.

Друзья, тут можно привести пример из нашего урока по дымовому тестированию, когда мы проводим тестирование основного бизнес-процесса нашего продукта. Так же можно его усложнить, добавив сюда подходы из теста критического пути, когда мы работаем с фильтрами.

Авторизация – переход в каталог – выбор товара используя фильтры – перенос в корзину – подтверждение товара - оплата товара, проверка списания денежных средств – получение данных когда товар будет выслан или готов к выдачи – подтверждение получения товара

4)Приёмочное тестирование (acceptance test) —

тестирование на сдаче приемки всего программного продукта или его части Заказчику

А) Пользовательское приемное тестирование (User Acceptance Testing) – перед релизом собирается группа конечных пользователей, тестируется основной функционал, при наличии дефектов-устраняются.

Приведу простой пример – мы разрабатываем компьютерную игру, сделали некую ее версию и выкладываем либо в открытой доступ, то есть в сеть или же для ограниченного количества пользователей и просим в нее поиграть, сказать свои впечатления.

Б) Эксплуатационное (Operational acceptance testing) – производится пользователем или администратором в среде, которая имитирует реальные условия эксплуатации ПО, производится тестирование резервного копирования, аварийное восстановление системы, безопасность ПО

В) На соответствие контракту – на соответствие гостов, нормативных актов и т.д



************************************

3.5 - Классификация по запуску кода на исполнение и по исполнителю

классификация по запуску кода на исполнение - 
- статистическое тестирование 
- динамическое тестирование 

Статическое тестирование — тестирование без запуска кода на исполнение.
Это процесс обнаружения и устранения ошибок и дефектов в различных сопроводительных документах (например, требованиях к программному обеспечению).
В рамках этого подхода тестированию могут подвергаться и проверка их на актуальность:
- Документы (требования, тест-кейсы, описания архитектуры приложения, схемы баз данных и т.д.). К примеру, у нас появился новый функционал и часть тест-кейсов стала не актуальной, необходимо вносить в них корректировки
- Графические прототипы (например, эскизы пользовательского интерфейса). Интерфейс нашего продукта может регулярно меняться, добавляться новые поля, кнопки и т.д., необходимо так же корректировать и эскизы нашего интерфейса
- Код приложения (что часто выполняется самими программистами в рамках аудита кода (code review), являющегося специфической вариацией взаимного просмотра в применении к исходному коду). Код приложения также можно проверять с использованием техник тестирования на основе структур кода.
- Параметры (настройки) среды исполнения приложения.
- Подготовленные тестовые данные.

Динамическое тестирование — тестирование проводится на работающей системе, не может быть осуществлено без запуска программного кода приложения.
Запускаться на исполнение может как код всего приложения целиком (системное тестирование), так и код нескольких взаимосвязанных частей (интеграционное тестирование), отдельных частей и даже отдельные участки кода.
Основная идея этого вида тестирования состоит в том, что проверяется реальное поведение (части) приложения.
Проще говоря, динамическое тестирование выполняется путем фактического использования приложения и определения того, работает ли функциональность так, как ожидается
То есть любое тестирование, в котором мы начинаем взаимодействовать с приложением, является динамическим. Например, проверка авторизации на сайте, запуск приложения, совершение какого либо действия в компьютерной игре и многое другое. Наша задача — посмотреть, как продукт реагирует на наши действия. Для этого мы вводим все необходимые условия и смотрим результат.

Классификация в зависимости от исполнителей:
- Альфа-тестирование — объектом данного тестирования является ранняя версия программного продукта. Может выполняться внутри организации-разработчика с возможным частичным привлечением конечных пользователей.
То есть тестирование членами команды разработки или, к примеру привлечение сотрудников со стороны Заказчика
- Бета-тестирование — тестирование программного обеспечения, выпускаемое для ограниченного количества пользователей. Главная цель — получить отзывы клиентов о продукте и внести соответствующие изменения. Например, в производстве видео игр, часто выпускают бета-версию игры на рынок, чтоб пользователи испытали и оценили ее.



************************************

3.6 - Позитивное и негативное тестирование

Тестирование классифицируют по следующим видам:
- позитивное 
- негативное

Позитивное тестирование – тестирование с применением сценариев, в которых ожидается нормальное, правильное поведение системы.
С его помощью мы можем определить, что система делает то, для чего и была создана. То есть тестирование с корректным использованием данных и выполнение шагов, соответствующих бизнес-логике продукта.

Негативное тестирование - тестирование с применением сценариев, в которых ожидается внештатное поведение системы, неверное. Когда минимум одно используемое данное не корректно.

Какой результат мы ждем от позитивных и негативных тестов?
- Позитивное тестирование должно нам всегда давать результат в виде отсутствия багов.
- Негативные проверки могут дать 2 результата:
1. На данный ввод у продукта есть ответ в виде сообщения/контроля. К примеру, сообщение о том, что введен некорректный логин или пароль, либо формат файла не поддерживается системой и т.д.
2. Система не знает, как реагировать на введенные данные, то есть она либо не дает нам пройти дальше, либо же выполняет те действия, которые не должна. К примеру, мы вводим верный логин, но не правильный пароль и система все равно дает нам авторизоваться в системе.

Сперва мы производим позитивное тестирование, а далее негативное. Ведь сперва мы должны убедиться, что система работает согласно своей бизнес логике.

Сначала мы проверяем работу системы, когда наш условный пользователь работает с системой «правильно», то есть вводит корректные данные и делает действия которые соответствуют логике продукта. А уже потом приступаем к проверке отклика системы на пользователя, который допускает различные ошибки (ввод неверных данных). И наша система должна быть готова ответить на неверный запрос. Это и есть цель негативного тестирования.

Давайте рассмотрим эти виды тестирования на примере.
Мы работаем с почтовым сервисов:
1)ввели наш логин
2)ввели корректный (правильный) пароль, к примеру "qwer1234"
3)нажали кнопку "Войти"
4)попали в наш личный кабинет
Это был пример позитивного тестирования авторизации.

Теперь давайте рассмотрим пример негативного тестирования:
1)ввели наш логин
2)ввели некорректный (не правильный) пароль, к примеру "qwer12345"
3)нажали кнопку "Войти"
4)получили оповещение о том, что наш пароль неверен

Оба наших теста прошли успешно, ведь мы первоначально уже знали, что получим такой результат. В данных тестах, мы проверили два сценария:
1)возможность авторизации на сайте, используя корректные данные
2)невозможность авторизации на сайте, используя некорректные данные и получение оповещения от системы.

Два данных подхода к тестированию - являются краеугольными во всем процессе тестирования, на них вы должны строить все ваши тестовые сценарии и не забывать, что мы, как тестировщики, имитируем деятельность конечного пользователя и должны предугадать все его действия.

Если Вы вводите корректные данные - это позитивное тестирование
Если Вы вводите некорректные данные - это негативное тестирование
Если система отработала верно, например для позитивного тестирования позволила пройти дальше или при негативном тестировании выдала предупреждение - значит оно успешное
Если она не дала продолжить работать при введении корректных данных или же наоборот, позволила работать при введении некорректных данных - значит тестирование не успешно и мы получили ошибку.



************************************

3.7 - Классификация по цели тестирования

1) смоук тестирование - это тестирование нового функционала, для того чтоб убедиться что продукт работает.

2)регрессионное - это повторное тестирование сатрого функционала, после того как у нас появился новый,чтоб убедиться что мы не навредили тому что было разработано ранее

3)автоматизация облегчает жизнь тестировщикам, потому что позволяет быстрее проводить тестирование, да, это AQA

4)"зачем мы говорим о ре-тесте сразу после тест нового функционала" . В данном видео мы говорим о причинах, по которой мы проводим тестирование:

а)тестирование нового функционала когда он вышел

б)регрессионное - тестирование всего старого функционала и смотрим, чтоб все работало

в)ретест, то есть повторное, когда нашли баг, его исправил разработчик и мы проверили что реально исправил.

Это не значит что мы сразу все 3 проводим, это значит что мы обсудили когда вообще возвможно тестирование, причины чтоб его начать.

Классификация по цели тестирования:

1)Тестирование новой функциональности (new feature test) – производится, как только была разработана новая функциональность.
То есть, как только разработчик выполнил свою часть работы, по созданию новой функциональности, он передает ее на тестирование. Данный функционал проходит все этапы тестирования начиная с дымового тестирования, теста критического пути и заканчивается расширенным тестом.

2)Re-test – проверка правильности исправления дефекта. Повторное тестирование функционала, в котором был найден дефект, то есть баг.
Разработчик разработал новый функционал, тестировщик его проверил, нашел там баг, занес его в бактрекинговую систему, типа Jira, я уже не много рассказывал о ней, в последующих уроках мы чуть больше затронем эту тему. Далее, когда разработчик исправил наш баг, или как говорят в IT «зафиксил», он говорит нашему тестировщику что баг исправлен, так вот повторная проверка нашего функционала, на отсутствие устраненного бага, называется re-test. Если баг не обнаружен, то новый функционал отправляется в релиз, если он повторно обнаружился, то снова возвращается разработчику и т.д.

3)Регрессионное тестирование – что такое регрессионное тестирование и когда оно проводится, один из самых популярных вопросов на собеседованиях.
Это повторная проверка ранее разработанного функционала, после появления нового билда, то есть новой версии нашего программного продукта, для того, чтоб убедиться, что новый функционал билда никак ему не навредил
Оно проводится:
- после появления нового билда (новой версии нашего продукта)
- тестирование того функционала в котором часто обнаруживаются дефекты – то есть данный функционал может даже и не касаться нового, но в нем постоянно обнаруживаются различные сбои, некорректная работа и т.д
- плановое тестирование – оно может быть как ежедневным (к примеру, прохождение основных бизнес-процессов для того, чтоб убедиться, что наш продукт работает корректно, то есть обычные смоук тесты), либо же к примеру раз в месяц тестируется весь продукт, для этого составляют специальные тест-планы для регрессионного тестирования, куда включают самые важные и частые сценарии.
-того функционала который часто меняется в ходе разработки

регрессионное тестирование – это тестирование ранее разработанного функционала, с целью удостовериться, что новая функциональность (фича), не повлияла на прежнюю функциональность. Другими словами, работает ли наш старый функционал как должен, после появления нового функционала

Для того чтоб облегчить работу тестировщикам, чтоб им не приходилось ежедневно проходить множество тестов, данный процесс необходимо автоматизировать. Для этого и существует автоматизация тестирования, то есть выбирается язык программирования, например Python или Java, используются различные фреймворки для того, чтоб сымитировать деятельность конечного пользователя.

Например, у нас есть сценарий, который будет включать в себя авторизацию в интернет-магазине, выбор товара, перенос его в корзину и оплату товара. Используя те технологии что я перечислил, мы имитируем деятельность пользователя, прописываем все шаги нашего теста в коде, и у нас после его запуска открывается браузер, открывается нужная нам ссылка, заполняются все поля, нажимаются кнопки. При этом это все происходит гораздо быстрее, ведь нам не нужно вручную заполнять все поля, система делает это моментально. Тем самым мы экономим время, силы, ресурсы, людей. Так же есть различные средства CI/CD, благодаря которым мы можем запускать наши тесты удаленно, по событию или по расписанию. К примеру, можно настроить что после каждого появления нового билда, то есть, когда разработчик внес изменения в код и выложил это на стенд, будет происходить автоматический запуск наших тестов, для того, чтоб убедиться, что код нашего разработчика не навредил нашему старому функционалу. Так же это можно настроить по расписанию, например каждое утро, в 6 часов будет запускаться набор наших тестов, и придя на работу мы будем видеть результат. Разумеется, запускаются не все тесты, только их часть, основных, потому что прогон всех тестов может занять несколько часов.

По опыту скажу так, в жизни я ни разу не слышал чтоб кто-то говорил этот термин (санитарное), все говорят Дымовое. В целом в работе мало кто разделяет на виды тестирования, в основном все говорят - тестирование нового функционала, позитивное, негативное, повторное, интеграционное, автоматизированное и регрессионное, иногда нагрузочное. Других терминов вы не услышите) В курсе это дается, потому что на собеседованиях спрашивают



************************************

3.8 - Тестирование с помощью техник тест-дизайна

Тест-дизайн – это этап процесса тестирования нашего ПО, на котором проектируются и создаются тест-кейсы в соответствии с определенными ранее критериями качества и целями тестирования. Позволяет выбрать из большого набора данных малую часть,  которая с большей вероятностью позволит обнаружить те же проблемы, что и большой набор данных. И в целом нужен для облегчения и ускорения работы
Цели:
1)Придумать тесты которые смогли бы обнаружить наиболее серьезные ошибки для ПО
2)Минимизация количества тестов

Тестирование классов эквивалентности -

1 - Класс эквивалентности – входные данные которые обрабатываются нашим приложением одинаково или обработка которых приводит к одному и тому же результату.
Правила работы:
1)определение класса эквивалентности
2)минимум 1 тест для 1 класса

2 - Анализ граничных значений  - это техника проверки поведения продукта на крайних (граничных) значениях входных данных.
Правила работы:
1)определение класса эквивалентности
2)определение границ диапазонов
3)проведение трех тестов для границ (на самой границе, +/-1 значение)

Остальные техники тест-дизайна с которыми Вы можете ознакомиться самостоятельно и которые применяются гораздо реже чем выше перечисленные:

1. Попарное тестирование (pairwise testing) — это техника формирования наборов тестовых данных из полного набора входных данных в системе, которая позволяет существенно сократить количество тест-кейсов.

2. Тестирование на основе состояний и переходов (State-Transition Testing) — применяется для фиксирования требований и описания дизайна приложения.

3. Таблицы принятия решений (Decision Table Testing) — техника тестирования, основанная на методе чёрного ящика, которая применяется для систем со сложной логикой.

4. Доменный анализ (Domain Analysis Testing) — это техника основана на разбиении диапазона возможных значений переменной на поддиапазоны, с последующим выбором одного или нескольких значений из каждого домена для тестирования.

5. Сценарий использования (Use Case Testing) — Use Case описывает сценарий взаимодействия двух и более участников (как правило — пользователя и системы).



************************************

3.9 - Методы тестирования: черный, серый и белый ящик

когда начинают спрашивать на собеседовании виды тестирования, то на 99% имеют ввиду функциональное и нефункционлаьное тетсирование

Выделяют 3 метода, так же можно назвать подходами, тестирования, Вы могли уже слышать данные названия: 
черный ящик
серый ящик
белый ящик

Начнем с черного ящика, это метод тестирования, когда мы имеем в своем распоряжение только внешний доступ к программного продукту, то есть тот же доступ что и конечный пользователь
То есть мы не имеем доступа к базе данных, не можем тестировать серверную часть, посмотреть код продукта. Так же, как и конечный пользователь, то есть мы не знаем, что находится внутри нашего программного продукта, в его серверной части и коде продукта. Для на это черный ящик.
И давайте рассмотрим на примере. У нас есть сайт, в котором есть окно авторизации. Тестирование методом черного ящика будет выглядеть следующим способом: это ввод в поля корректных и некорректных данных, с цель проверки на то, что система не пропустит некорректные данные, например данные по несуществующему пользователю, или если поле будет пустым. То есть данный вид тестирования может провести как тестировщик, так и любой пользователь системы

Тестирование методом серого ящика. В данном методе в нашем вооружение уже есть доступ к серверной части. То есть мы можем тестировать графический интерфейс нашего приложения, отправлять запросы на сервер и в базу данных
рассмотрим на примере той же формы по авторизации. Имея доступ к серверной части, мы можем отправлять специальные запросы на сервер, в будущих уроках мы рассмотрим какие бывают запросы и когда они применяются, которые будут создавать новых пользователей и мы будем авторизовываться под этими данными, проверять что мы можем войти в систему, так же сможем проверить что пользователь появился в базе данных или же наоборот, с помощью нее создать нового пользователя и потом проверить это на сайте. Проще говоря, Вы можете использовать базу данных и запросы на сервер, для того, чтоб получать информацию, создавать, изменять и удалять какие-либо данные. Тем самым тестировать продукт

Метод белого ящика, это когда мы имеем те же возможности что и в сером ящике, то есть доступ к графическому интерфейсу приложения, базе данных, серверу, а также доступу к коду программного продукта. То есть тестировщик может посмотреть код, который написан разработчиком. Данный метод требует более высокую квалификацию, так как требует от специалиста знания языков программирования. Как правило тестировщики редко это делают, тут больше работают разработчики, когда, к примеру пишут модульные тесты, то есть unit-тесты. Или же исправляют баги найденные тестировщиком. По своему опыту могу сказать, что я иногда применяю данный вид тестирования, например, когда постановка задачи плохо написана, то можно с помощью специализированного ПО зайти и посмотреть какие именно изменения делал разработчик в проекте, например название полей, которые он изменил

Тестировщик - Вопросы собесов - 
https://t.me/easy_qa_ru

************************************

4.1 - Методологии разработки ПО : водопадная, V-образная, Agile модель

Методология разработки ПО – это процесс описания того, как определенный продукт будет разрабатываться, то есть один из способов организации коллективной разработки. Существует множество разных моделей такого процесса, каждая из которых описывает свой подход и нельзя сказать, что среди них выделяется одна, которую нужно использовать в каждом проекте, всё сугубо ситуативно.

3 основных методологии, это:
1. Водопадная модель
2. V-образная модель
3. Итерационная модель

1. Водопадная модель - каждый этап разработки последовательного цикла продолжает предыдущий. По факту это наш Жизненный цикл разработки программного продукта – SDLC, который мы обсуждали с вами ранее.

Она включает в себя следующие этапы: требования-проектирование-разработка-тестирование-релиз-поддержка

Данная модель подходит под долголетние проекты в крупных компаниях, когда есть возможность первоначально составить требования, полноценные, включить в них все и на протяжении всего процесса разработки их не менять, подготовить дизайн-проект, написать полностью код проекта  и только потом его протестировать, это очень важно, тестирование идет не параллельно с разработкой, а только после ее полнейшего завершения. Далее идет релиз, всего продукта, а не поэтапно и поддержка.

Плюсы данного методологии:

+ полное документирование каждого этапа, всегда доступны требования

+ возможность распланировать сроки и затраты

Минусы:

- необходимо утвердить полный объем требований к системе, в случае необходимости внести новые требования, мы не можем вернуться к старым и нам необходимо переделать все заново

- увеличение затрат времени и средств, при необходимости внесения новых требований

Пример такого проекта: крупный банк решил создать внутренний чат для своих сотрудников, он может позволить потратить на это длительный промежуток времени, пока его сотрудники пользуются общедоступными приложениями, например Jabber.

Когда-то данная модель была очень популярна и применялась повсеместно, но сегодня эта модель не может удовлетворить быстро меняющиеся технические потребности

2. V-образная модель - это модифицированная версия каскадной – тестирование начинается со стадии написания требований и происходит на каждом этапе

Особенностью V-образной модели можно считать то, что она направлена на тщательную проверку и тестирование продукта, находящегося уже на первоначальных стадиях проектирования. Стадия тестирования проводится одновременно с соответствующей стадией разработки, например, во время написания кода разработчиками пишутся модульные тесты.

Плюсы:

+ есть строгие этапы

+ раннее тестирование

+ промежуточное тестирование

Минусы:

- отсутствие гибкости модели

- отсутствие возможности внесения динамических изменений

- написание кода происходит только в середине процесса

Когда использовать V-модель?
- Если требуется тщательное тестирование продукта.
- Для малых и средних проектов, где требования четко определены и фиксированы.
- В условиях доступности инженеров необходимой квалификации, особенно тестировщиков.

V-образная модель может быть чрезвычайно полезна в случаях, когда ошибки могут быть фатальными, и в проектах, где точность имеет решающее значение

3. Итерационная модель – жизненный цикл создания продуктов разбит на ряд минициклов. И самая популярная из них это Agile.

Итерация- разработка отдельного компонента системы, после чего добавляется к ранее разработанным компонентам.

В «гибкой» методологии разработки после каждой итерации заказчик может наблюдать результат и понимать, удовлетворяет он его или нет. Это одно из преимуществ гибкой модели.

Данная методология подходит для больших или нацеленных на длительный жизненный цикл проектов, которые постоянно адаптируются к условиям рынка и готовы изменить направление в любой момент. Соответственно, в процессе реализации проекта его требования могут изменяются.

Плюсы:

+ раннее создание работающего ПО

+ очень гибкая, готова к изменениям на любом этапе разработки

Минусы:

- каждая фаза самостоятельна

- не все требования известны

Agile – набор методов и принципов гибкого управления проектами

Фактически, существует 12 принципов гибкой разработки, которые сводятся к следующим ценностям:

- люди и взаимодействия важнее процессов и инструментов (если есть принципы, которые мешают нашей работе, то от них нужно избавиться. Люди должны сами выбирать инструменты и процессы). От себя хочу добавить, что на практике это не всегда возможно и заказчики могут выставить жесткие условия, что хотят, чтоб их продукт был разработан на конкретных технологиях.

- работающий продукт важнее исчерпывающей документации (большая часть времени должна уходить на функционал продукта, а не на документацию). Не стоит сбрасывать со счетов ведение документации, так как она необходима для поддержки и сопровождения продукта в целом, а также если заказчик захочет в будущем нанять иную организацию для продолжения разработки продукта.

- сотрудничество с заказчиком важнее согласований условий контракта (не должно быть избыточной привязанности с контрактом, который регулирует наши взаимоотношения с заказчиком). Думаю, здесь все понимают, что контракт есть контракт и любые юридические разбирательства будут идти именно согласно контракту.

- готовность к изменениям важнее следования первоначальному плану (мы в любом случае будем вносить изменения). Очень важно чтоб все эти изменения были задокументированы и согласованы.

Основная составляющая данной методологии это - Спринт – временной отрезок в 2-4 недели, в течении которого у нас создается часть продукта, которая соответствует тем требованиям, которые мы берем в начале спринта. В начале каждого спринта мы набираем часть задач, которые должны реализовать за этот промежуток времени. А после должны произвести релиз разработанного функционала, но на практике может происходить, что релизы бывают и каждый день, поэтому не всегда есть четкая привязка к спринту.

Agile включает в себя две вариации: Kanban и Scrum

Основная разница между Scrum и Канбан — в длине итераций. В Scrum итерации — 2 недели, в Kanban задачи программисту можно «подсовывать» хоть каждый день

в Scrum наша цель — закончить спринт, в Kanban — задачу

Kanban – это конвейерная схема. У нас имеется общий backlog задач, своего рода список задач, которые необходимо сделать для завершения проекта и где они берутся и выполняются поочередно. Мы переносим задачу в разработку, тестируем ее и отправляем в релиз и пока она не будет выполнена, мы не берем следующую

Основные принципы:

- Визуализация – то есть у нас с Вами есть backlog с задачами, которые требуется выполнить.

- Имеется план разработки, которому придерживается команда, составленный по приоритету. Может меняться в любой момент.

- Ограничение одновременно выполняемых задач. Как правило команды на Kanban проектах малочисленны, поэтому одновременно в разработке небольшое количество задач

- Постоянная оптимизация разработанных процессов.

Отдельно необходимо отметить, что Kanban хорошо работает в стартапах, не имеющих четкого плана, но активно работающих над разработкой.

Scrum – это так же конвейерная схема, но в ней возможно производство одновременно нескольких задач. Scrum проекты разбиты на спринты, то есть небольшой объём работы, который необходимо выполнить в течение определённого, оговоренного заранее, периода времени. Заказчик по итогу спринта, должен получить готовый функционал. То есть передача продукта заказчику идет небольшими частями.  Мы выбрали на этот спринт из backlog 10 задач, они могут разрабатываться параллельно или последовательно, в зависимости от численности нашей команды, проходить через следующие этапы: 
Анализ-разработка-разработка завершена-тестирование-релиз

После анализа задача попала в разработку, как только она завершилась она попадает в стадию разработка завершена, где ее передают тестировщику, и если мы обнаружим баг, то мы возвращаем ее на этап разработки, если нет, то отправляем в релиз. В конце спринта подводятся итоги и остатки переносятся на следующий и так далее.

Допустим наш проект состоит из 10 блоков. На разработку каждого блока нам требуется 1месяц. Мы разрабатываем первый блок, запускаем его в релиз, и наш пользователь уже может пользоваться данным продуктом, далее второй блок и т.д.

Плюсы и минусы Agile методологии:

Плюсы:

+ не нужно ждать полного завершения проекта, чтобы он начал функционировать;

+ возможность адаптироваться к изменениям на любой стадии проекта, сделать соответствующие изменения в самом продукте и документации;

+ возможность получить обратную связь от пользователей продукта еще во время разработки и скорректировать его.

Минусы:

- очень быстро устаревает написанная документация, поэтому требуется постоянное ее обновление;

- сложность планирование бюджета и полного срока разработки программного продукта, так как происходят постоянные изменения

Теперь сравним все 3 методологии:

На разработку 1 блока уходит месяц, следовательно, если мы используем схему Waterfall или V-образную, то наш продукт будет готов через 10 месяцев и только после этого у нас начнут появляться пользователи, отзывы и пожелания от них, и на исправление или если мы захотим внести что-то новое, на это уйдет очень много времени. А если мы используем Aggile, то наш продукт начнет функционировать уже со второго месяца, и к концу разработки проекта, мы будем иметь большое количество пользователей нашего продукта и иметь обратную связь от них. А также мы сможем в любой момент изменить направление нашего продукта, в ту которая будет нам выгоднее.

На практике модели разработки программного продукта многовариантны. Нельзя сказать, что какая-то определенная модель идеальна и все должны следовать именно ей. Даже столь популярная модель Aggile не может применяться на каждом проекте из-за неготовности некоторых заказчиков или невозможности гибкого финансирования. Методологии отчасти похожи друг на друга и частично пересекаются в своих принципах и средствах

************************************

4.3 - Установка и работа в системе JIRA (для жителей РФ не доступна)

1)https://www.atlassian.com/ru/software/jira/free - сайт из урока

Так же доступна мобильная версия данной программы, скачать можно в любом маркете на Вашем устройстве

Дополнительная инструкция https://www.atlassian.com/ru/software/jira/guides/getting-started/basics#step-1-create-a-project

Выбор шаблона Scrum https://www.atlassian.com/ru/software/jira/templates/scrum

2)https://asproagile.ru/ - отечественный аналог Jira

Рабочие процессы в Аспро.Agile: что это и как их создавать? - видео-инструкция -
https://vkvideo.ru/video-124023938_456239251?ref_domain=yastatic.net

3)https://ru.yougile.com/ - ещё один аналог

https://www.youtube.com/watch?v=2G1ZiIzI8wo&t=541s - видео-инструкция по работе с yougile

https://investinperm.ru/upload/iblock/332/m0t4sj34dlt5k5is5vyp780lzi2aldpi.pdf текстовая инструкция по работе с yougile

https://www.atlassian.com/ru/software/jira/guides/getting-started/basics?tab=#step-1-create-a-project 
- Обновленный официальный гайд по Jira

https://youtu.be/TeckTCITenI - минимальный набор знаний, с разбором на основе реальных вакансий

https://youtu.be/34RcuYnHLXw - моё видео по обзору различных программ и сервисов, для хранения документации. Для прохождения собеседования достаточно будет jira

В компаниях так и осталась Jira, просто не поддерживается разработчиками. Поэтому ознакомиться нужно, так как скорей всего именно с ней и будете работать в будущем

Jira - система для управления проектом, тут можно - 
- создавать задачи которые будут в спринте
- назначать ответственных
- контролировать процесс разработки
- заводить баги, которые были обнаружены 
- планировать всю работу в целом 

зарегистрироваться на сайте -
https://www.atlassian.com/ru/software/jira/free
- не получается зарегистрироваться даже с VPN 

получить письмо 
перейти из письма на сайт 
придумать пароль 
добавить емейлы своей команды 
выбрать тип разработки -
- kanban 
- scrum 
- отслеживание багов 

scrum - самая популярная методология разработки программного продукта в настоящее время

использовать шаблоны 
выбрать проект, управляемый командой 
придумать название 
перейти в беклог (беклог - это хранилище задач, которые мы должны реализовать)
напишим ряд задач, которые нам необходимы
перенести созданные задачи из беклога в спринт 
нажать кнопку "запустить спринт"
выбрать -
- название спринта 
- длительность 
- дату и время начала 
- дату и время окончания 
- цель спринта 
можно нажать + и добавить дополнительные колонки 
- анализ 
- в разработке 
- разработка завершена 
- тестирование 
- готово 
тестировщик берет задачи из колонки "разработка завершена" и переносит в колонку "тестирование", если на этапе "тестирование" был обнаружен баг, то тестировщик переносит задачу в "разработку", а если багов нет, то в колонку "готово"

занесение найденных багов в баг-трекинговую систему - тестировщик в жире в строке сверху нажимает кнопку "создать"
выбирает проект 
выбирает тип "баг"
в резюме - "Не функционирует кнопка отправки сообщений"
в описании - пишет описание
в беклоге перенести созданную задачу в текущий спринт 



************************************

4.4 - Практическое задание в баг-трекинговой системе JIRA

Создание проекта в баг-трекинговой системе JIRA. Все шаги наглядно показаны в лекции.

1. Зарегистрироваться в баг-трекинговой системе JIRA по ссылке https://www.atlassian.com/ru/software/jira 
(или ее мобильная версия) 

или 
https://ru.yougile.com/ (говорят этот лучше чем asproagile.ru, где я зарегистрировался)

или 
https://asproagile.ru/ 
L -
ajdvzdxcd@yomail.info
P - 
a........ae10_
Здравствуйте, вы зарегистрировались в Аспро.Agile.
URL aдрес вашего аккаунта: 
https://ajdvzdxcd.asproagile.ru/
Ваш логин для входа: ajdvzdxcd@yomail.info
Войти в мой аккаунт https://ajdvzdxcd.asproagile.ru/
Если у вас есть вопросы, свяжитесь с нами -
mailto:support@aspro.cloud

-  отечественные аналоги Jira (инструкции в закрепленном комментарии прошлого урока)

2. Создать проект типа Scrum

3. Создать следующие этапы разработки программного продукта: анализ
в разработке
разработка завершена
тестирование
готово
релиз

4. Создать в Бэклоге 10 задач, названия для задач подбирайте на тему реального функционала (не 1, задача 1 и т.д)

5. Провести задачи через все этапы разработки программного продукта

6. Скриншоты с решением приложить в "Решения"

ПРЕЖДЕ ЧЕМ ПРИСЛАТЬ ОТВЕТ, ПРОСЬБА ВНИМАТЕЛЬНО ПРОЧЕСТЬ ЗАДАНИЕ И ВЫПОЛНИТЬ ЕГО В ПОЛНОМ ОБЪЕМЕ



************************************

5.1 - Работа с требованиями для тестировщика

Любой проект, который планируется реализовать, начинается с требований, это самый главный документ который используется в процессе разработки программного продукта. Это тот документ, на который все опирается и с которым будет позже сравниваться наш продукт. От того на сколько четко и грамотно они будут сформулированы во многом зависит успех нашего продукта.

Требования — это документ, описание того, что должно быть реализовано. Требования описывают то, что необходимо реализовать, без детализации технической стороны решения.

Выделяют 4 уровня требований:

1) Уровень бизнес требований – цель, ради которой создается продукт (для он нужен заказчику, какая польза, как получим прибыль). К примеру, фирма создает чат для своих сотрудников или, к примеру интернет-магазин для продажи товара, которая она производит.
Данные требования не относятся напрямую к реализации проекта, а в первую очередь отражают цели бизнеса.
Данные требования будут содержать следующие понятия:
- Причины инициации проекта – например у компании проблема с реализацией товара в своем регионе, и она решила выйти за его пределы, для этого решила создать свой интернет-магазин, для того, чтоб пользователи с других регионов могли заказать товар.
- Цели, которые должны быть достигнуты в результате разработки данного продукта – к примеру увеличить количество сбыта продукции и заключение контрактов с потребителями из других регионов
- Концепция продукта — сжато описываем наш конечный продукт, который выполнит заданные цели. Например, интернет-магазин который будет покрывать потребности пользователей в конкретной стране или регионе.

2) Уровень пользовательских требований - задачи, которые пользователь может выполнять с помощью продукта (регистрироваться, общаться, искать информацию о продукте)
Пользовательские требования определяют набор пользовательских задач, которые должна решать программа, а также способы (сценарии) их решения в системе. Они пишутся простым естественным языком, без погружения в сами процессы.
Что же включают в себя пользовательские требования:
- цели и задачи пользователей
- пользовательские истории или сценарии, так называемые user story и user case, о которых мы поговорим далее
- описание ролей и доступов. К примеру, в банках очень много должностей – менеджеры, специалисты, казначеи, начальники отделов и т.д, у банка есть свои программы, в которых у каждого из этих сотрудников будет своя роль, свой доступ, на те документы, задачи, заявки, справочники и т.д, к которым они будут иметь доступ.

Следующие 2 требования - это продуктовые требования 

3) Функциональные требования – что система должна и не должна делать?
Здесь в отличии от пользовательских требований, описание идет уже на профессиональном языке и более детально.
Указывается перечень функционала, который должна выполнять система, как система реагирует на те или иные входные данные, как она ведёт себя в определённых ситуациях и т.д.
Рассмотрим на примере Видеохостинга, то есть сервиса, на котором мы можем просматривать и загружать видео (к примеру YouTube). Если в пользовательских требованиях будет описано следующее «должна быть возможность загружать видео на платформу», то в функциональных требованиях будет написано «Должна быть возможность подгружать видео в следующих форматах, далее пойдет описание форматов, в случае попытки загрузки файлов некорректного формата выдавать предупреждение, размер файлов может быть в пределах, далее идут границы размера файла, в случае превышение размеров выдавать предупреждение и т.д

4) Нефункциональные требования – как система должна это делать?
Сюда, к примеру можно отнести характеристики нашего продукта по производительности, то есть какую нагрузку он может выдерживать. Так же надёжность, время ответа системы и т.д.

Теперь давайте рассмотрим, как же нам получить информацию, для составления требований, основные пути:
1)интервью с заказчиком или пользователем
2)наблюдение за продуктами Заказчика или конкурента
3)самостоятельное описание

Рассмотрим примеры -

1. интервью с заказчиком или пользователем
Наш Руководитель проекта, он же проджект менеджер, и бизнес-аналитик встречаются с заказчиком и обсуждают с ним требования, к продукту. Обсуждают для чего продукт создан, какой он будет нести функционал, как заказчик планирует получать прибыль, какие задачи сможет решать пользователь с помощью этого продукта, на каких платформах и системах будет запускаться наш продукт.
На примере социальной сети:
- основная цель разработки данного продукта – это создание платформы для общения, с возможностью обмена медиа файлами, созданием групп для общения и обмена данными
- прибыль заказчик может получать на основе платной регистрации, если такая имеется, встроенной рекламы, продажи подписок на музыку или отключение рекламы и т.д
- возможность запуска нашего приложения на ПК, на мобильных устройствах, в разных браузерах
Все эти пункты и не только описываются в требованиях

2. наблюдение за продуктами Заказчика или конкурента
Мы так же можем обратить внимание на уже созданные продукты нашего заказчика, если таковы имеются и подчеркнуть из них информацию, например оформление. 
Так же рассмотреть основных конкурентов, которые уже реализовали подобный продукт. 
Например, мессенджеры WhatsApp или Viber, мы видим что кнопка ответа на звонок зеленая, а сброса красная, большинству пользователю уже интуитивно знакома такая особенность, поэтому нам выгоднее использовать ее в своем продукте, так как пользователь уже привык к этому.

3. Самостоятельное описание
Это составление требований на основе опыта команды, которая уже создавала подобные продукты
Теперь давайте рассмотрим атрибуты требований:
- Корректность — точное описание разрабатываемого функционала.
- Непротиворечивость — требование не должно содержать внутренних противоречий и противоречий другим требованиям и документам.
- Недвусмысленность — требование должно содержать однозначные формулировки.
- Полнота — в требовании должна содержаться вся необходимая для реализации функциональности информация.
- Прослеживаемость — каждое требование должно иметь уникальный идентификатор, по которому на него можно сослаться.
- Приоритетность — у каждого требования должен быть приоритет(количественная оценка степени значимости требования). Этот атрибут позволит грамотно управлять ресурсами на проекте.
- Проверяемость — формулировка требований таким образом, чтобы можно было выставить однозначный вердикт, выполнено все в соответствии с требованиями или нет.
- Атомарность — требование нельзя разбить на отдельные части без потери деталей.
- Модифицируемость — в каждое требование можно внести изменение.

Способы представления наших требований:

- Use case diagram – схема, где изображены возможности каждого из ролей в системе: админа, пользователя и т.д которые описывают варианты взаимодействия между пользователем и программным обеспечением;

- User story – пользовательское-ориентированное описание целей, которые люди смогут достичь, используя наш продукт, написанный повседневным языком -
а) как пользователь я хочу регистрироваться онлайн, для того чтоб регистрироваться быстро и снизить бумажную работу; 
б) Как пользователь я хочу получить такую функциональность которая позволяла бы мне сделать следующее.

Должны быть критерии приемки – что должно быть сделано, чтоб критерии были реализованы.
Тестировщик должен придумать тест-кейсы чтоб проверить данные требования)

- UI mockup -шаблоны нашего UI 

- Спецификация – в текстовой форме, структурированный набор требований к программному обеспечению и его внешним интерфейсам. Предназначен для того, чтобы установить базу для соглашения между заказчиком и командой разработки о том, как должен функционировать программный продукт. Уклон сделан в техническую сторону.

Требования к продукты будут постоянно обновляться, у заказчика будут постоянно появляться новые пожелания к улучшению продукта и к реализации нового функционала. При это первоначальные требования будут часто обновляться, а как следствие должна обновляться и тестовая документация, о которых мы поговорим в следующих видео.



************************************

5.2 - Чек-лист. Тест-кейс. Тестовый набор

Порядок прохождения уроков на тему: Чек-лист. Тест-кейс. Тестовый набор

Шаг №1 - Порядок изучения

Шаг №2 - Чек-лист - видео-лекция

Шаг №3 - Чек-лист - текстовый вариант лекции

Шаг №9 - Тест-кейс - видео-лекция

Шаг №10 - Тест-кейс - текстовый вариант лекции

Шаг №15 - Тестовый набор - видео-лекция

Шаг №16 - Тестовый набор - текстовый вариант лекции

Документация для проверки функционала программного продукта - 
1 - Чек-лист 
2 - Тест-кейс 
3 - Тестовый набор 

В системе не должно быть два чек-листа с одинаковым id 

Под каждый тип тестирования - отдельный чек-лист (под функциональное, производительное и т.д.)

на видео 1 - пример чек-листа (12-50 - низ листа, 12-56 - верх листа)

Чек-лист - список проверок, в котором мы указываем, что мы будем тестировать, результат и статус проверок.

Давайте рассмотрим кто может составлять чек-листы: во-первых, сам тестировщик, когда он получает в работу задачу, он изучает требования и на основе своего опыта и знания бизнес логики продукта начинает составлять сценарии, как он будет его тестировать. Без детальной разбивки на шаги прохождения тестов.

Во-вторых, чек-листы могут составлять бизнес-аналитики и руководитель проекта, то есть, когда они создают задачу по разработке, они могут прописать в ней список сценариев, которые они хотят проверить. Это очень удобно для всей команды, так как ускоряет процесс тестирования и подсказывает тестировщику в каком направлении ему необходимо двигаться.

Теперь давайте рассмотрим, где именно составляются и хранятся чек-листы – они могут храниться в Office документах, например word, excel - как в примере нашего урока. В google документах. Или же в специализированном ПО, например Jira, в самой задаче или же в приложениях, которые специально созданы для этого – Test IT, Testrail, Testlink и т.д. С данными программами Вы можете ознакомиться в последующем видео «Приложения для хранения тестовой документации».

Он включает в себя следующие атрибуты:
- Проект – здесь указывается название проекта, для которого мы пишем сценарии проверки;
- Цель проверки - здесь идет название модуля который будет проверять в данном документе;
- Идентификатор - это уникальный Идентификатор документа;
- Требования - ссылка на документ, на основании которого составлен данный документ;
- Дата проведения;
- Исполнитель;
- Среда тестирования – здесь мы указываем окружение, на котором мы будем проводить тестирование – то есть наша платформа, версия браузера (если это веб-продукт) и т.д.
- Тип тестов;
- Название проверок - здесь идет название нашей проверки, отображающее то, что именно мы будет проверять в данном тесте;
- Результат проверки

Данные атрибуты являются обязательными. Чек-лист не включает в себя детальное перечисление шагов, которые необходимо выполнить, для выполнения данных проверок, основная его задача перечислить различные сценарии тестирования данного функционала.

пример тест-кейса - видео 2 - 5-45 

обязательно чтобы каждый тест-кейс на проекте имел уникальный номер (ID) 

добавить в тест-кейс новую колонку - столбец "H" в excel - "Предварительные условия"

в каждом тест-кейсе идет своя нумерация шагов - 1-2-3-4...

#####################
ПО ДЗ - 
Вы можете просто сделать успешную авторизацию и регистрацию, а остальные 8 сценариев на отправку сообщений 
В рамках домашнего задания лучше разнообразить тесты, а не делать 10 тестов на регистрацию с проверкой одного поля на разные комбинации
- На любой какой хотите, главное чтобы это был почтовый сервис
- Что письмо пришло по указанному адресу электронной почты, или это не важно, просто получили уведомление, что письмо отправлено
- Написать текст сообщения другим курсивом/шрифтом/размером
- проверить возможность в целом отправлять сообщение, то делается только это. Если цель проверить функционал изменения шрифта, текста, вставку ссылок,изображений и т.д, то делюется  отдельный кейсы, иначе может получиться что у Вас будет тест-кейс с сотней шагов
- чек-лист - для формы Регистрации один, для формы Авторизации один и т.д, но в нем много проверок, его пишут в качестве наброска проверок (если прям простыми словами), а вот уже в тест-кейсе расписывают подробно только одна проверка (сценарий), чтоб каждый смог его пройти
- вы можете сделать один большой тест-кейс, который будет включать в себя шаги:
1. авторизация на сайте. Открыть форму написания письма .......
2.выделить текст и установить курсивом
3.выделить текст и сделать жирным
........
100500.изменить цвет текста
- делаю в тест-кейсе проверку возможности отправки сообщения двум пользователям одновременно
#####################

Тест-кейс – пошаговый сценарий, описывающий как проводится тестирование, и включающий более детализированные проверки (шаги).

То есть если в чек-листах мы указывали название самих проверок, не детализировали их, то в тест-кейсах необходимо расписать каждый шаг, то есть переход по ссылкам, заполнение полей, нажатие кнопок и т.д.

Это необходимо для того, чтоб тестировщик смог воспроизвести данный сценарий. Есть одно правило, которое мне нравится, оно звучит так «Тест-кейс необходимо писать так, чтоб его мог повторить любой человек с улицы». Это говорит о том, что Ваш тест-кейс должен бать максимально подробным.

Давайте рассмотрим кто может составлять тест-кейсы: во-первых, сам тестировщик, когда он получает в работу задачу, он изучает требования и на основе своего опыта и знания бизнес логики продукта начинает составлять тест-кейсы, как он будет его тестировать.

Во-вторых, тест-кейсы могут составлять бизнес-аналитики и руководитель проекта, то есть, когда они создают задачу по разработке, они могут прописать в ней список сценариев и шагов как их пройти, которые они хотят проверить. Это очень удобно для всей команды, так как ускоряет процесс тестирования и подсказывает тестировщику в каком направлении ему необходимо двигаться.

Теперь давайте рассмотрим, где именно составляются и хранятся тест-кейсы – так же как и чек-листы, они могут храниться в office документах, например word, excel - как в примере нашего урока. В google документах. Или же в специализированном ПО, например Jira, в самой задаче или же в приложениях, которые специально созданы для этого – Test IT, Testrail, testlink и т.д. С данными программами Вы можете ознакомиться в последующем видео «Приложения для хранения тестовой документации».

Теперь давайте рассмотрим обязательные атрибуты тест-кейсов, он плотно пересекаются с атрибутами чек-листов -

1 - Название проекта – здесь указывается название проекта, для которого мы пишем сценарии проверки

2 - Id – это уникальный Идентификатор, уникальный номер тест-кейса, в нашей системе, на одном проекте не должно быть 2-х одинаковых тест-кейсов, это необходимо для того чтоб мы могли всегда корректно ссылаться на наш документ, при общении с другими коллегами, указанием в других системах и т.д. Данный идентификатор не должен биться с id чек-листа, то есть если здесь у нас id 1, то это не значит что все тест-кейсы которые будут написаны по сценариям данного документа должны иметь id1, у них идет своя нумерация.

3 - Требования – ссылка на документ, на основании которого составлен данный документ

4 - Модуль – название модуля к которому относится данный функционал

5 - Название - здесь идет название нашей проверки, отображающее то, что именно мы будет проверять в данном тесте

6 - Приоритет - показывает, на сколько важно проведение данного теста -
- P1 Высокий (High)
- P2 Средний (Medium)
- P3 Низкий (Low)
Тестировщик самостоятельно выставляет данный приоритет, основываясь на своем опыте.

7 - Среда тестирования – здесь мы указываем окружение, на котором мы будем проводить тестирование – то есть наша платформа, версия браузера (если это веб-продукт) и т.д.

8 - Шаги-теста – самый главный атрибут нашего документа, в котором мы подробно расписываем все шаги прохождения нашего теста

9 - Ожидаемый результат – в данном атрибуте мы указываем, а какой именно результат мы ожидаем получить, после того как мы выполним данный шаг, очень важно писать результат по каждому шагу, а не один для всех шагов. Это позволит любому члену команды повторить данный тест.

Так же полезно знать свойства тест-кейсов которыми они должны обладать в идеале:
- Уникальность (Uniqueness):
Описание: Каждый тест-кейс должен быть уникальным и не дублировать другие тест-кейсы. Это помогает избежать избыточности и обеспечивает более эффективное тестирование.
Пример: Если у вас уже есть тест-кейс для проверки успешного входа в систему, не нужно создавать другой такой же тест-кейс.
- Точность (Accuracy):
Описание: Тест-кейсы должны быть точными и четко описывать ожидаемый результат. Это помогает тестировщикам точно понять, что именно проверяется.
Пример: Вместо "Проверить вход в систему" следует написать "Проверить, что пользователь с правильными учетными данными может войти в систему".

- Полнота (Completeness):
Описание: Тест-кейсы должны охватывать все возможные сценарии и аспекты функциональности, которую они тестируют.
Пример: Если вы тестируете форму ввода, включите тесты для проверки всех полей формы, включая обязательные и необязательные поля.

- Исполнимость (Executability):
Описание: Тест-кейсы должны быть выполнимыми, то есть их можно выполнить в реальной среде тестирования.
Пример: Тест-кейс, требующий недоступных или нереалистичных условий, не является исполнимым.

- Повторяемость (Repeatability):
Описание: Тест-кейсы должны быть написаны таким образом, чтобы их можно было повторно выполнять с одинаковыми результатами.
Пример: Тест-кейс должен включать четкие шаги и предусловия, чтобы любой тестировщик мог его выполнить и получить тот же результат.

- Атомарность (Atomicity):
Описание: Каждый тест-кейс должен проверять только одну функциональность или аспект системы, чтобы легко определить причину провала теста.
Пример: Вместо тест-кейса, который проверяет и регистрацию, и вход в систему, лучше разделить на два отдельных тест-кейса.

- Трассируемость (Traceability):
Описание: Тест-кейсы должны быть связаны с требованиями или спецификациями, чтобы можно было отследить, какие требования покрыты тестированием.
Пример: Каждый тест-кейс должен ссылаться на соответствующее требование или пользовательскую историю.

- Актуальность (Up-to-date):
Описание: Тест-кейсы должны быть актуальными и отражать текущее состояние системы. При изменении требований или функциональности тест-кейсы должны быть обновлены.
Пример: Если в системе изменился процесс регистрации, соответствующие тест-кейсы должны быть обновлены.

Тестовый набор (Test suite) – набор тест-кейсов, объединенный по одному модулю или цели проверки




















