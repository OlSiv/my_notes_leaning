
эти 2 курса - telegram - избранное - 13-07-2025 и 14-07-2025
+
жд4тб - _CODING/_QA/Nikita API + UI + нагрузочное


проходить так - сначала изучить весь текст темы, и только после этого смотреть видео, глядя на свои заметки по этой теме


******************************************

Автоматизация тестирования API с Python -

******************************************
******************************************
******************************************

1 - 1.1 -

В этом курсе мы буквально разберем на атомы тему автоматизации тестирования API. Наша цель — не просто научиться отправлять запросы к API и проверять коды ответа, а построить полноценный фреймворк автотестов, который можно использовать в реальных проектах.

Этот курс — не про "как отправить запрос"
Большинство API-курсов поверхностны и учат только "как отправить запрос". Этот курс — совершенный технический фундамент для становления QA Automation Engineer.

Большинство курсов ограничиваются HTTP-запросами и называют это "API-тестами". В реальности API — это не только HTTP. Мы будем работать с gRPC, WebSocket, TCP/IP и детально разберем принципы HTTP.



******************************************

1 - 1.2 -

сначала прочитать тест урока а потом уже смотреть видео 

повторять все действия за автором 

после каждого задания добавлять код на GitHub (коммит)

не пропускать уроки и задания 

если не хватает теории - попробуй разобратся самостоятельно, почитай документацию к фреймворку или библиотеке, загугли вопрос 

данный курс предусматривает что у тебя уже есть базовое понимание python 



******************************************

в 1 - 1.1 - 3 - ссылки на уроки по основам python -

Этот курс предполагает базовые знания Python. Если вы не уверены в следующих темах, рекомендую сначала их повторить:

Переменные -
https://www.w3schools.com/python/python_variables.asp

Типы данных -
https://www.w3schools.com/python/python_datatypes.asp

Функции -
https://www.w3schools.com/python/python_functions.asp

Логические операторы -
https://www.w3schools.com/python/python_conditions.asp

Циклы -
https://www.w3schools.com/python/python_for_loops.asp

Lambda-функции -
https://www.w3schools.com/python/python_lambda.asp

Классы -
https://www.w3schools.com/python/python_classes.asp

Знакомство с пакетным менеджером pip -
https://www.w3schools.com/python/python_pip.asp

Работа со строками и форматирование строк -
https://www.w3schools.com/python/python_string_formatting.asp

Для закрепления основ Python, рекомендую следующие бесплатные курсы, которые можно пройти за одну-две недели -

Бесплатный курс по Python от W3Schools -
https://www.w3schools.com/python/default.asp

Бесплатный курс по Python от Metanit -
https://metanit.com/python/tutorial/



******************************************

1 - 1.3 -

выполнить задание - зафиксировать в коммите  



******************************************

1 - 1.4 -

гугление и самостоятельный поиск информации - это очень важный навык 

не пропускать уроки и задания 



******************************************

2 - 2.1 -

Основы тестирования программного обеспечения

Что такое Quality Assurance (QA)? -
Quality Assurance (QA) или Обеспечение качества — это совокупность мер и процессов, направленных на предотвращение дефектов в продуктах или услугах компании. QA сосредоточено на повышении качества разработки и поддержке стабильности продукта, что позволяет сократить количество ошибок на всех стадиях жизненного цикла продукта. Это не только тестирование, но и стандартизация, контроль и оптимизация всех процессов разработки, начиная от планирования до финальной сдачи продукта.

QA не отвечает напрямую за обнаружение ошибок. Его главная задача — предотвратить их появление, что достигается путём создания четких процессов разработки и тестирования, вовлечения всех участников и внедрения лучших практик.

Что такое тестирование? -
Тестирование — это процесс проверки работы программного обеспечения для выявления ошибок, отклонений от требований и обеспечения качества продукта. Тестирование проводится для того, чтобы подтвердить, что продукт работает корректно и соответствует ожиданиям пользователей и техническим требованиям. Оно помогает обнаружить ошибки на разных уровнях разработки и тем самым улучшить качество продукта.

Тестирование делится на несколько видов, включая функциональное, нефункциональное (например, производительность), автоматизированное и ручное тестирование, и охватывает широкий спектр методов и техник.



Цели тестирования - Тестирование преследует несколько целей:

1 - Обнаружение ошибок: Основная цель тестирования — выявить ошибки и проблемы в программном обеспечении, которые могут негативно повлиять на пользователей или функциональность продукта.

2 - Проверка соответствия требованиям: Тестирование позволяет убедиться, что продукт соответствует требованиям, которые к нему предъявляются, и ведёт себя предсказуемо в соответствии с бизнес-логикой.

3 - Повышение надежности и стабильности продукта: Регулярное тестирование помогает обнаружить и устранить потенциальные дефекты, повышая устойчивость и стабильность программного обеспечения.

4 - Уменьшение рисков: Чем раньше найдена ошибка, тем дешевле и проще её исправить. Это снижает финансовые риски и помогает избежать критических проблем на поздних стадиях.

5 - Обеспечение пользовательского опыта: Хорошо протестированный продукт создаёт положительный пользовательский опыт, что повышает лояльность пользователей и положительно влияет на имидж компании.

6 - Поддержка команды разработки: Тестирование помогает разработчикам получать быструю обратную связь по внесённым изменениям и исправлениям, что ускоряет и облегчает процесс разработки.



Зачем компании нужны тестировщики? - Компании нанимают тестировщиков для обеспечения качества выпускаемого программного обеспечения по нескольким важным причинам:

1 - Предотвращение ошибок до выхода в продакшен: Тестировщики помогают находить ошибки до того, как продукт увидит конечный пользователь. Это снижает затраты на исправление ошибок и позволяет избежать негативной реакции со стороны пользователей.

2 - Снижение нагрузки на разработчиков: С помощью тестировщиков разработчики могут сосредоточиться на кодировании и внедрении новых функций, тогда как тестировщики берут на себя задачу проверки качества продукта.

3 - Поддержка стандартов качества: Тестировщики следят за соблюдением стандартов качества, которые важны для репутации компании, особенно если продукт ориентирован на массовый рынок или критически важные процессы.

4 - Понимание пользовательских сценариев: Тестировщики часто рассматривают продукт с точки зрения пользователя, что помогает обнаружить проблемы с удобством использования и логику, которые могут быть упущены разработчиками.

5 - Ускорение выхода продукта: Автоматизация тестирования и другие методики помогают ускорить процесс выпуска новых версий продукта. Это особенно важно в компаниях, где необходимо поддерживать высокий темп разработки и быструю реакцию на требования рынка.



Базовая терминология тестирования -

- Smoke-тестирование: Это быстрое тестирование, направленное на проверку работоспособности основных функций системы после сборки или внедрения изменений. Если smoke-тесты проходят успешно, можно продолжать более глубокое тестирование.

- Регрессионное тестирование: Оно проверяет, что новые изменения или исправления не нарушили работу уже существующих функциональностей. Регрессионное тестирование часто автоматизируется, чтобы быть уверенным в стабильности продукта после каждой итерации.

- Функциональное тестирование: Направлено на проверку функциональных аспектов продукта, таких как входные и выходные данные, а также соответствие требованиям, описанным в спецификации.

- Нефункциональное тестирование: Это тестирование таких характеристик, как производительность, надёжность и безопасность. Оно включает в себя тестирование скорости, устойчивости к нагрузке, удобства использования и других показателей, влияющих на пользовательский опыт.

- Тестирование черного и белого ящика: В черном ящике тестировщик не имеет доступа к коду и проверяет только функциональность, доступную пользователю. В белом ящике тестировщик анализирует внутреннюю структуру кода, что помогает в обнаружении ошибок на более низком уровне.



Подходы и методы тестирования -

1 - Ручное тестирование: Тестировщик вручную выполняет тесты, проверяя продукт на наличие ошибок, функциональных или нефункциональных отклонений.

2 - Автоматизированное тестирование: Использует программные инструменты и скрипты для автоматизации тестов, что помогает снизить время и ресурсы, требуемые для выполнения повторяющихся задач. Автоматизированные тесты идеально подходят для регрессионного тестирования.

3 - Интеграционное тестирование: Проверяет взаимодействие между компонентами или модулями системы, чтобы убедиться, что они работают вместе корректно.

4 - Системное тестирование: Осуществляется на полностью интегрированной системе и проверяет её соответствие всем заданным требованиям.

5 - Приемочное тестирование: Проводится в конце цикла разработки для подтверждения, что продукт готов к выпуску и отвечает требованиям клиентов.



Схема по видам тестирования - в основной папке где этот курс - 
для курсов по ручному тестированию или ISTQB-подготовке она может быть особенно полезна. В рамках курса по автоматизации я намеренно оставляю только наиболее прикладные виды: те, с которыми вы будете реально работать — функциональное, регрессионное, модульное, интеграционное и т.п.

Остальные категории — конечно, тоже существуют, но они либо редко автоматизируются, либо требуют отдельной специализации (как, например, тестирование локализации или тестирование восстановления после сбоев).



Резюме -

Тестирование — это важный процесс, который помогает компании выпускать качественный продукт, избегать ошибок на ранних этапах разработки и строить репутацию надёжного поставщика ПО. Тестировщики, как часть процесса обеспечения качества, играют ключевую роль в достижении этих целей, помогая создавать продукты, которые не только работают корректно, но и удовлетворяют потребности конечных пользователей.



******************************************

2 - 2.2 -

Основные виды тестирования



1 - Функциональное тестирование (Functional Testing)

Это вид тестирования, направленный на проверку функциональности приложения и его соответствия требованиям. Он проверяет, насколько правильно работает каждая функция, описанная в технической спецификации.
- Примеры: Тестирование ввода данных в форму, проверка нажатия кнопок, валидация полей, логика калькулятора.
- Когда используется: В основном на всех этапах разработки, чтобы убедиться, что функции работают корректно.



2 - Нефункциональное тестирование (Non-Functional Testing)

Нефункциональное тестирование охватывает такие аспекты, как производительность, надежность, безопасность и удобство использования. Этот вид тестирования проверяет, как приложение работает, а не то, что оно делает.
- Примеры: Тестирование производительности, безопасности, удобства использования.
- Когда используется: При необходимости проверить поведение системы при различных нагрузках, доступах, ситуациях и других условиях, влияющих на качество работы приложения.



3 - Smoke-тестирование

Smoke-тестирование выполняется для быстрого анализа основных функций продукта после сборки. Оно помогает убедиться, что система готова к более детальному тестированию.
- Примеры: Проверка входа в систему, загрузки главной страницы, работы ключевых функциональностей.
- Когда используется: В начале каждого нового цикла тестирования, чтобы проверить стабильность основной функциональности.



4 - Регрессионное тестирование (Regression Testing)

Регрессионное тестирование проводится для проверки того, что изменения или новые функции не повлияли на работу существующего функционала. Это тестирование повторяется после каждого изменения.
- Примеры: Перепроверка работы логики авторизации, функциональности корзины после добавления новых функций.
- Когда используется: После каждого изменения кода, исправления ошибок или добавления новых функций.



5 - Тестирование безопасности (Security Testing)

Это тестирование направлено на проверку безопасности системы и её защиты от различных угроз. Оно включает проверку на уязвимости, которые могут позволить злоумышленникам получить несанкционированный доступ.
- Примеры: Проверка защиты паролей, тестирование SQL-инъекций, тестирование уязвимостей при доступе к файлам.
- Когда используется: Обычно проводится на всех проектах, особенно если данные, хранимые в приложении, являются конфиденциальными.



6 - Тестирование производительности (Performance Testing)

Тестирование производительности определяет, как система работает под нагрузкой и каковы её пределы. Включает тесты на скорость отклика, устойчивость и пропускную способность.
- Примеры: Тестирование времени отклика сервера, устойчивости системы при большом числе запросов.
- Когда используется: При необходимости проверить масштабируемость и производительность, особенно для высоконагруженных систем.



7 - Тестирование совместимости (Compatibility Testing)

Этот вид тестирования проверяет, как система работает на разных устройствах, браузерах и операционных системах, обеспечивая её кроссплатформенность.
- Примеры: Проверка корректности отображения сайта на мобильных устройствах, совместимость с различными версиями браузеров.
- Когда используется: Для кроссплатформенных и кроссбраузерных приложений, которые должны работать на разных устройствах и ОС.



8 - Интеграционное тестирование (Integration Testing)

Интеграционное тестирование проверяет взаимодействие между модулями системы, чтобы убедиться, что компоненты работают вместе корректно.
- Примеры: Проверка взаимодействия между модулями аутентификации и авторизации, взаимодействие фронтенда и бэкенда.
- Когда используется: После модульного тестирования, когда модули объединены в систему.



9 - Системное тестирование (System Testing)

Это тестирование полной, интегрированной системы для проверки её соответствия всем функциональным и нефункциональным требованиям.
- Примеры: Проверка общей работоспособности приложения, функциональности, производительности и безопасности на конечной системе.
- Когда используется: Когда все модули объединены, и продукт готов к выпуску.



10 - Приемочное тестирование (Acceptance Testing)

Это тестирование проводится для подтверждения, что продукт удовлетворяет требованиям бизнеса и готов к выпуску. Включает сценарии, приближенные к реальной работе пользователей.
- Примеры: Проверка всей пользовательской функциональности перед выпуском.
- Когда используется: Перед выпуском продукта клиенту или на рынок.



11 - Тестирование пользовательского интерфейса (UI Testing)

UI-тестирование проверяет, как выглядят и функционируют элементы интерфейса, такие как кнопки, поля ввода, меню.
- Примеры: Проверка цвета кнопок, правильного расположения и размера элементов.
- Когда используется: Когда необходимо убедиться в правильности отображения и работы интерфейса.



12 - Тестирование удобства использования (Usability Testing, тестируем UX - удобство использования)

Usability Testing определяет, насколько удобно и просто использовать продукт. Часто проводится с участием конечных пользователей.
- Примеры: Проверка того, насколько легко пользователю выполнить основные операции.
- Когда используется: Для продуктов, ориентированных на конечных пользователей, где важен удобный интерфейс.



13 - Тестирование интерфейсов (API Testing)

Тестирование интерфейсов, или API, проверяет взаимодействие между клиентом и сервером, а также корректность работы API, его ответов и обработки ошибок.
- Примеры: Проверка работы запросов GET, POST, корректного ответа API при неверных данных.
- Когда используется: Для приложений с архитектурой клиент-сервер и взаимодействующих через API.



14 - Альфа-тестирование и бета-тестирование

Эти виды тестирования проводятся на финальных этапах разработки. Альфа-тестирование выполняется внутри компании, а бета-тестирование — с участием конечных пользователей.
- Примеры: Альфа-тестирование — внутренняя проверка с устранением всех выявленных ошибок. Бета-тестирование — использование продукта конечными пользователями для оценки удобства и поиска багов.
- Когда используется: Перед финальным релизом продукта.



15 - Эксплуатационное тестирование (Operational Testing)

Проводится в условиях, максимально приближенных к реальной эксплуатации, чтобы убедиться, что продукт готов к использованию и выдерживает реальные нагрузки и эксплуатационные условия.
- Примеры: Проверка системы в рабочем окружении компании-клиента.
- Когда используется: На завершающем этапе разработки и в процессе внедрения продукта.



Резюме -

Каждый вид тестирования имеет свои цели и отвечает на определённые вопросы: насколько функционально, безопасно, производительно или удобно использовать систему. Выбор видов тестирования зависит от специфики проекта, требований к нему и стадии разработки, на которой находится продукт. Правильная комбинация этих методов позволяет создавать качественный продукт, который соответствует ожиданиям пользователей и требованиям бизнеса.



Практикуемся по видам тестирования

В данном задании вам необходимо самостоятельно провести смоук-тестирование для приложения UI Course по ссылке: 
https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login

Перед началом выполнения задания рекомендую внимательно изучить функционал приложения UI Course, чтобы лучше понять, какие основные функции необходимо протестировать.



Что такое смоук-тестирование?

Смоук-тестирование — это базовый уровень тестирования, который позволяет проверить, что основные функции приложения работают корректно после внесения изменений или обновлений. Основная цель заключается в выявлении критических ошибок, которые могут помешать дальнейшему тестированию приложения.



Основные функции приложения -
1 - Регистрация и авторизация
2 - Навигация
3 - Функциональность курсов
4 - Выход из приложения



Задача

Вашим ответом на данное задание будет описание действий, которые необходимо совершить для проведения смоук-тестирования этого приложения. Опишите каждый из вышеуказанных модулей, указав, что вы проверяли, какие результаты ожидали, и что фактически наблюдали. Если во время тестирования вы столкнулись с какими-либо проблемами или ошибками, обязательно упомяните их в своем ответе



Пример

1 - Открываем приложение UI Course https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login
2 - Переходим на страницу регистрации https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration
3 - Регистрируемся в приложении UI Course
4 - ...



******************************************

2 - 2.3 -

Техники тест-дизайна

Техники тест-дизайна — это методы, которые помогают тестировщикам создавать тесты, покрывающие функциональные и нефункциональные требования к системе. Эти техники позволяют оптимизировать процесс тестирования, сократить количество тестов без потери качества, повысить вероятность выявления ошибок и улучшить эффективность тестирования. Разберём основные техники.



Основные техники тест-дизайна - 


1 - Эквивалентное разделение (Equivalence Partitioning)

Эта техника подразумевает разделение всех возможных входных данных на несколько групп или классов эквивалентности. Каждая группа или класс представляет собой подмножество значений, которые, по предположению, обрабатываются системой одинаково. Тестирование одной группы эквивалентно тестированию других значений из той же группы.
- Пример: Поле для ввода возраста принимает значения от 18 до 60. Можно создать три группы эквивалентности:
    - допустимые значения (18–60),
    - значения ниже допустимого диапазона (меньше 18),
    - значения выше допустимого диапазона (больше 60).
- Когда используется: При необходимости сократить количество тестов и избежать тестирования каждого значения в диапазоне.


2 - Анализ граничных значений (Boundary Value Analysis)

Этот метод используется для тестирования крайних значений диапазона. Граничные значения — это те, которые находятся на границе классов эквивалентности, и часто именно они могут вызывать ошибки.
- Пример: Если допустимый диапазон значений 18–60, то тестировать можно значения 17, 18, 60, 61.
- Когда используется: В ситуациях, когда существует ограниченный диапазон допустимых значений, особенно если ошибки часто появляются на границах диапазона.


3 - Таблица решений (Decision Table Testing)

Таблица решений помогает тестировать сложные комбинации условий, показывая зависимость между входными данными и ожидаемыми результатами. В ней описаны условия и действия, которые позволяют тестировщику учитывать различные комбинации входных значений и реакции системы.
- Пример: Вход в систему возможен при условии, что введены верные логин и пароль, и двухфакторная аутентификация пройдена успешно. Таблица решений поможет учесть все возможные комбинации этих условий.
- Когда используется: Для тестирования сложной логики, когда результат зависит от множества условий и их комбинаций.


4 - Таблица переходов состояний (State Transition Testing)

Техника применяется для тестирования систем, поведение которых зависит от текущего состояния и событий, которые приводят к переходу из одного состояния в другое.
- Пример: Система банкомата, в которой переходы зависят от состояний пользователя (введен ли PIN, достаточно ли средств на счету и т.д.).
- Когда используется: Когда система имеет различные состояния, зависящие от последовательности выполненных операций.


5 - Метод причинно-следственного графа (Cause-Effect Graphing)

Техника включает построение графа, в котором отображены причины (условия) и следствия (результаты), после чего составляются тест-кейсы для покрытия различных путей графа. Это позволяет проверить, как система обрабатывает комбинации различных условий.
- Пример: В логике приложения есть несколько условий, и для различных их комбинаций выполняются разные действия. Граф причин и следствий помогает учесть все возможные комбинации этих условий и результаты.
- Когда используется: В сложных системах, где есть много логических зависимостей и комбинаций условий.


6 - Исчерпывающее тестирование (Exhaustive Testing)

Техника подразумевает тестирование всех возможных значений входных данных. Хотя это практически невозможно для большинства случаев, исчерпывающее тестирование целесообразно при наличии малого набора входных значений.
- Пример: Если есть поле для ввода дня недели (7 вариантов), можно протестировать все 7 вариантов.
- Когда используется: В редких случаях, когда число входных данных ограничено.


7 - Комбинаторное тестирование (Pairwise Testing)

В комбинаторном тестировании используются пары всех возможных значений для переменных, чтобы минимизировать число тестов, одновременно покрывая основные комбинации. Метод pairwise testing тестирует каждую пару возможных значений хотя бы один раз, что позволяет выявить большую часть ошибок.
- Пример: Если есть три настройки, каждая из которых может принимать два значения, комбинаций может быть 8. Техника Pairwise позволяет протестировать только 4, охватывая все возможные комбинации пар значений.
- Когда используется: Когда нужно уменьшить количество тестов для многофакторных данных без потери покрытия.


8 - Исследовательское тестирование (Exploratory Testing)

Исследовательское тестирование — это неформальная техника, в рамках которой тестировщик изучает продукт, импровизирует и находит возможные ошибки, тестируя функциональность с точки зрения пользователя.
- Пример: Тестировщик, исследуя новый функционал без заранее подготовленных тест-кейсов, выявляет неожиданное поведение системы.
- Когда используется: На любом этапе разработки, особенно в условиях ограниченного времени и для поиска скрытых дефектов.


9 - Адаптивное тестирование (Ad-Hoc Testing)

Адаптивное тестирование представляет собой непринужденное тестирование без какого-либо плана или структуры. Тестировщик проверяет систему по своему усмотрению, стараясь выявить возможные дефекты.
- Пример: Тестировщик проверяет произвольные функции или комбинации данных, просто чтобы увидеть, как система на них отреагирует.
- Когда используется: В случае отсутствия времени на детальную подготовку или для быстрого поиска ошибок.


10 - Тестирование на основе использования (Use Case Testing)

Тестирование на основе использования ориентируется на сценарии использования и тестирует, насколько правильно система выполняет определенные задачи с точки зрения пользователя.
- Пример: Создание и исполнение тест-кейсов для выполнения конкретных пользовательских действий, таких как «заказ товара» или «вход в аккаунт».
- Когда используется: В случае тестирования бизнес-процессов и задач, важных для пользователей.


11 - Тестирование по сценарию (Scenario Testing)

Сценарное тестирование представляет собой тестирование через сценарии, которые описывают реальные ситуации использования. Оно позволяет охватить множество условий в одном тесте и проверить сложные пользовательские пути.
- Пример: Тестирование процесса покупки на сайте, начиная с поиска товара и заканчивая оплатой и получением квитанции.
- Когда используется: В случаях, когда нужно проверить целостные сценарии, охватывающие разные функции и логические блоки приложения.


12 - Метод сравнения с эталоном (Benchmark Testing)

Это техника тестирования, при которой результаты работы программы сравниваются с эталонными значениями или показателями. Она позволяет оценить качество и производительность системы.
- Пример: Сравнение времени отклика приложения с установленными стандартами.
- Когда используется: Для проверки производительности и соответствия установленным стандартам.



Заключение -

Техники тест-дизайна позволяют тестировщикам более эффективно проверять систему, избегая излишнего дублирования и увеличивая вероятность обнаружения ошибок. Выбор техник зависит от типа тестируемой системы, требований к качеству и ресурсов, доступных для тестирования.



Практикуемся по техникам тест-дизайна

В данном задании вам необходимо протестировать форму регистрации приложения UI Course https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration. Используйте техники тест-дизайна, которые вы изучили, чтобы обеспечить качественное тестирование формы.

Задачи:

1 - Выбор техник: Прежде чем начать тестирование, внимательно проанализируйте форму регистрации и выберите техники тест-дизайна, которые наиболее подходящие для её тестирования. Не обязательно использовать все доступные техники; выбирайте только те, которые помогут вам добиться максимального покрытия и выявления возможных ошибок.

2 - Составление списка проверок: Ответом на задание должен быть список проверок, которые вы будете выполнять при тестировании формы регистрации. Для каждой проверки укажите:
- Конкретные действия, которые необходимо выполнить.
- Ожидаемый результат.
- Применяемую технику тест-дизайна.

Пример формата ответа:

1 - Проверка на допустимость ввода электронной почты:
- Действие: Ввести некорректный формат электронной почты (например, "test@").
- Ожидаемый результат: Появление сообщения об ошибке "Некорректный формат электронной почты".
- Применяемая техника: Эквивалентное разделение.

2 - Проверка на обязательные поля:
- Действие: Оставить поля "Имя" и "Пароль" пустыми и нажать кнопку "Зарегистрироваться".
- Ожидаемый результат: Появление сообщений об ошибках, указывающих на необходимость заполнения этих полей.
- Применяемая техника: Исследовательское тестирование.



******************************************

2 - 2.4 -

Артефакты тестирования и тестовая документация

Артефакты тестирования и тестовая документация — это набор документов, созданных в процессе тестирования для описания, планирования, отслеживания и анализа качества продукта. Они служат основой для организации тестирования, дают общую картину качества продукта и упрощают взаимодействие между участниками проекта. Тестовая документация также помогает зафиксировать и сохранить результаты тестирования для последующего анализа и использования.



Основные артефакты тестирования -


1 - Тест-план (Test Plan)

Тест-план — это документ, в котором описываются цели, объем, подходы и виды тестирования, которые будут применяться. Он определяет, какие функции и компоненты будут тестироваться, в какие сроки, какие ресурсы необходимы, а также включает критерии начала и окончания тестирования.
- Содержание: Цели тестирования, подход к тестированию, артефакты и процессы, которые будут использоваться, риски, сроки, роли и обязанности.
- Зачем нужен: Обеспечивает структурированный подход к тестированию и помогает команде понимать общий план и цели тестирования.


2 - Тест-кейсы (Test Cases)

Тест-кейс — это пошаговое описание действий и условий, необходимых для проверки определенной функции или функционала продукта. Каждый тест-кейс включает входные данные, действия и ожидаемый результат.
- Содержание: ID тест-кейса, название, предусловия, шаги выполнения, ожидаемый результат, постусловия.
- Зачем нужны: Обеспечивают системное покрытие функционала и позволяют проводить повторное тестирование на всех этапах разработки.


3 - Тест-сьют (Test Suite)

Тест-сьют — это набор связанных тест-кейсов, который объединяется для выполнения определенного типа тестирования или проверки функциональности. Например, тесты для функционального, smoke или регрессионного тестирования.
- Содержание: Список тест-кейсов, сгруппированных по определенным характеристикам или функциональным областям.
- Зачем нужен: Упрощает запуск и организацию тестов, особенно для автоматизированного тестирования.


4 - Чек-листы (Checklists)

Чек-лист — это упрощенный вариант тест-кейсов, содержащий только основные проверки без детализированных шагов. Используется для быстрой проверки ключевых функций или на этапе приемочного тестирования.
- Содержание: Список проверок или условий, которые должны быть выполнены для успешного завершения тестирования.
- Зачем нужен: Для проведения быстрого тестирования и оценки базовых функциональностей без глубокого погружения в детали.


5 - Трассировочная матрица (Traceability Matrix)

Матрица трассировки — это документ, который связывает требования с тест-кейсами. Она помогает убедиться, что все требования покрыты тестами, и позволяет отслеживать выполнение тестирования по требованиям.
- Содержание: Сопоставление требований и соответствующих тест-кейсов.
- Зачем нужна: Обеспечивает полное покрытие требований тестами и помогает отследить, какие из них прошли проверку, а какие ещё нет.


6 - Отчеты о дефектах (Bug Reports)

Отчет о дефекте (баг-репорт) — это документ, который описывает обнаруженные ошибки, их характеристики и статус. Он включает информацию о месте обнаружения дефекта, условиях его воспроизведения и ожидаемом результате.
- Содержание: ID дефекта, название, описание, шаги для воспроизведения, ожидаемый и фактический результат, статус, приоритет, скриншоты и другая информация.
- Зачем нужны: Для фиксации обнаруженных ошибок и передачи их разработчикам для исправления.


7 - Отчет о тестировании (Test Report)

Это документ, в котором фиксируются результаты тестирования, включая успешные и неуспешные тесты, процент покрытия тестами и выявленные дефекты. Отчет о тестировании может быть промежуточным (ежедневный, еженедельный) или итоговым.
- Содержание: Результаты тестирования, метрики покрытия, статистика по дефектам, анализ рисков, рекомендации по релизу.
- Зачем нужен: Для подведения итогов тестирования и принятия решения о готовности продукта к релизу.


8 - Тест-стратегия (Test Strategy)

Это высокоуровневый документ, который описывает общие подходы, принципы и виды тестирования, применяемые в проекте. Тест-стратегия может входить в состав тест-плана или быть отдельным документом.
- Содержание: Подход к тестированию, типы и уровни тестирования, используемые инструменты, критерии выхода.
- Зачем нужна: Определяет основные принципы тестирования и помогает согласовать процесс между всеми участниками.


9 - Протоколы тестирования (Test Logs)

Протокол тестирования содержит записи о выполнении тестов, включая результаты каждого теста. Этот документ может быть автоматическим, если используется инструмент тестирования.
- Содержание: Дата и время выполнения тестов, статус каждого теста (пройден/не пройден), ID тест-кейсов, комментарии.
- Зачем нужны: Для документирования хода тестирования и дальнейшего анализа проблем, если тест не прошел.


10 - Сценарии тестирования (Test Scenarios)

Тест-сценарий — это высокоуровневое описание действий, которые должен выполнить пользователь или система. В отличие от тест-кейсов, сценарии не содержат детализированных шагов и охватывают целостные пользовательские действия.
- Содержание: Краткое описание действия, которое должно быть проверено.
- Зачем нужны: Для проверки логики и основных пользовательских потоков без детализации.


11 - План приемочного тестирования (Acceptance Test Plan)

Это документ, который описывает план проведения приемочного тестирования, чтобы проверить, соответствует ли система бизнес-требованиям. Обычно составляется клиентом или представителями бизнеса.
- Содержание: Критерии приемки, сценарии приемочного тестирования, роли и обязанности участников.
- Зачем нужен: Для определения готовности продукта к внедрению или передаче клиенту.


12 - Руководства и инструкции по тестированию (Testing Guidelines and Instructions)

Эти документы содержат инструкции и рекомендации по выполнению тестов, настройке тестового окружения и использованию тестовых инструментов.
- Содержание: Описание методик, используемых инструментов, подходов к тестированию.
- Зачем нужны: Обеспечивают единые стандарты выполнения тестирования и помогают новым членам команды быстро освоиться.



Метрики и показатели тестирования

Метрики — это количественные и качественные показатели, которые помогают оценить эффективность и прогресс тестирования, а также качество продукта. Они могут включать:

- Покрытие тестами (Test Coverage) — процент требований или функциональных модулей, покрытых тестами.

- Процент успешных тестов (Pass Rate) — соотношение пройденных тестов к общему количеству.

- Плотность дефектов (Defect Density) — количество дефектов на единицу объема кода.

- Среднее время исправления дефекта (Defect Fix Time) — среднее время, требуемое на исправление дефектов.



Зачем нужна тестовая документация

1 -Планирование и управление процессом тестирования: позволяет организовать процесс, установить сроки, определить объем работы и распределить задачи между участниками.

2 - Обеспечение прозрачности и понимания: упрощает коммуникацию между разработчиками, тестировщиками и заказчиками, особенно на крупных проектах.

3 - Снижение рисков и улучшение качества: хорошо организованная документация помогает снизить вероятность пропуска ошибок и повысить качество конечного продукта.

4 - Обеспечение воспроизводимости и повторяемости: документация позволяет воспроизводить тесты в будущем, особенно при регрессионном тестировании.

5 - Поддержка обучения и адаптации новых сотрудников: документация помогает новым тестировщикам быстрее войти в проект и освоиться с процессами.


Артефакты тестирования — это основа, обеспечивающая качественное тестирование, прозрачность процесса и предсказуемость результатов.



Практикуемся с написанием тестовой документации

В этом задании вам необходимо:

1 - Написать чек-листы для проверки страницы авторизации (https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login) в приложении UI Course.

2 - Написать тест-кейсы для проверки страницы регистрации (https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration) в приложении UI Course.

Примечание: Обратите внимание на оформление и структуру, соблюдайте последовательность и ясность шагов. Чек-листы должны быть сжатыми, но содержать все необходимые проверки. Тест-кейсы — детализированными, с описанием ожидаемого результата для каждого шага.



Формат ответа:

Чек-лист для проверки страницы авторизации -
1 - Проверка отображения страницы авторизации.
2 - Проверка наличия поля для ввода электронной почты.
3 - Проверка кнопки "Войти" (Login) и ее состояния при пустых полях.
4 - ...


Тест-кейсы для проверки страницы регистрации

Тест-кейс 1: Проверка регистрации с корректными данными
Предусловие: Открыта страница регистрации.
Шаги:
1 - Ввести корректный email в поле "Email".
2 - Ввести корректный пароль в поле "Password".
3 - Ввести корректный пароль повторно в поле "Confirm Password".
4 - Нажать кнопку "Регистрация" (Register).
Ожидаемый результат: Пользователь успешно зарегистрирован, отображается сообщение о подтверждении регистрации.

Тест-кейс 2: Проверка сообщения об ошибке при несоответствии паролей
Предусловие: Открыта страница регистрации.
Шаги:
1 - Ввести корректный email в поле "Email".
2 - Ввести пароль в поле "Password".
3 - Ввести другой пароль в поле "Confirm Password".
4 - Нажать кнопку "Регистрация" (Register).
Ожидаемый результат: Отображается сообщение об ошибке, сообщающее о несовпадении паролей.



******************************************

2 - 2.5 -

Введение в автоматизацию тестирования



О профессии QA Automation Engineer

QA Automation Engineer (инженер по автоматизированному обеспечению качества) — это специалист, занимающийся тестированием программного обеспечения с помощью автоматизированных тестов. В отличие от ручного тестировщика, его основной фокус — разработка и поддержка автоматизированных тестов, которые позволяют проверять стабильность и функциональность системы более эффективно и быстро.



Чем занимается QA Automation Engineer? - В обязанности QA Automation Engineer входят следующие задачи:

1 - Создание автоматизированных тестов: разработка тестовых сценариев для различных аспектов приложения, включая функциональное, регрессионное и интеграционное тестирование.

2 - Настройка тестового окружения и инфраструктуры: подготовка и конфигурирование среды для запуска тестов, чтобы обеспечить воспроизводимость и стабильность тестов в разных условиях.

3 - Поддержка актуальности тестов: регулярное обновление тестов, чтобы они соответствовали текущим требованиям продукта и не содержали устаревших данных, особенно после обновления функциональности.

4 - Анализ результатов тестов: оценка результатов автоматизированных тестов для обнаружения проблем и аномалий. При выявлении ошибок QA Automation Engineer создает баг-репорты, описывая найденные дефекты.

5 - Отчётность по результатам тестирования: настройка и генерация отчетов, которые помогают команде видеть результаты тестирования и анализировать состояние качества продукта. Такие отчеты часто включают метрики, статистику по пройденным и не пройденным тестам, выявленные дефекты и другие данные для оценки стабильности продукта.

6 - Взаимодействие с разработчиками и другими командами: QA Automation Engineer тесно сотрудничает с разработчиками, менеджерами по продукту и другими участниками проекта, чтобы оперативно решать выявленные проблемы и планировать улучшения.



Зачем QA Automation Engineer нужен компании?
QA Automation Engineer приносит компании ценность за счет:

- Повышения скорости тестирования: автоматизация позволяет значительно сократить время, необходимое для проведения тестов, особенно при частом выпуске обновлений.

- Снижения затрат на тестирование: автоматизация тестов позволяет избежать затрат на многократное ручное тестирование, особенно при масштабном проекте.

- Повышения качества продукта: QA Automation Engineer помогает вовремя выявлять дефекты, что снижает риски для компании и улучшает доверие к продукту.

- Поддержания стабильности системы: благодаря автоматизированным тестам можно быстро проверить продукт на соответствие основным требованиям после каждого изменения, что поддерживает стабильность и предотвращает регрессии.

- QA Automation Engineer играет ключевую роль в обеспечении качества продукта и помогает компании выпускать обновления быстрее, минимизируя риски и улучшая общий опыт пользователей.



Принципы автоматизации тестирования


Какие тестовые сценарии подлежат автоматизации?

Необходимо учитывать, что автоматизация подходит не для всех тестов. Попытка автоматизировать каждый сценарий — это плохая практика, которая не только затратно, но и нецелесообразно.



Что не следует автоматизировать:

1 - Очень длинные и сложные сценарии, занимающие несколько минут: Если тестовый сценарий длится более одной-двух минут, автоматизация становится невыгодной. Такие тесты трудно анализировать, они требуют больших временных затрат на запуск и поддержку, что часто дороже, чем ручное тестирование. Ваша задача — уметь выявлять такие сценарии и объяснять команде, почему их не стоит автоматизировать. Члены команды часто просят автоматизировать всё подряд, но здесь важно придерживаться разумного подхода.

2 - Нестабильные сценарии без предсказуемого результата: Если система нестабильна или результат непредсказуем, автоматизация теряет смысл. Например, автоматизация интерфейсов для сложных симуляций или виртуальных сред (как виртуальные лаборатории с операционными системами) будет крайне нестабильной. Отображение операционной системы в браузере в виде "картинки" затрудняет предсказание и автоматизацию взаимодействия.

3 - Сложно воспроизводимые сценарии: Автоматизация тестов для систем, работающих только в определённые временные промежутки, например, биржевых приложений, может быть крайне сложной. Такие тесты требуют наличия условий, доступных только в определенное время суток или в особых обстоятельствах.



Что следует автоматизировать:

1 - Тесты, которые можно быстро выполнить и для которых известен точный ожидаемый результат: Это тесты, которые легко настроить и анализировать, например, смоук-тесты, регрессионные тесты, интеграционные и юнит-тесты.

2 - Стабильные сценарии: Автоматизируйте сценарии, которые дают предсказуемые результаты и не зависят от внешних факторов.

3 - Тесты, которые используются часто и необходимы для проверки ключевой функциональности: Например, критические пользовательские пути, где малейший сбой может нарушить работу всей системы.



Пирамида автоматизации

Помимо выбора сценариев для автоматизации, важно также понимать, сколько и какие типы тестов нужно автоматизировать. Это иллюстрирует пирамида автоматизации — схема, показывающая оптимальное соотношение различных типов тестов.

Картинка с пирамидой - telegram - избранное - 17.01.2026 (14:27)



Рассмотрим уровни пирамиды автоматизации:

1 - UI/E2E тесты: Этот уровень занимает минимальное количество тестов, так как такие тесты сложны в разработке, запуске и поддержке. UI-тесты, по сути, являются E2E-тестами, так как они проверяют функциональность от начала до конца. Они требуют значительных ресурсов и при этом являются самыми медленными и наименее стабильными.

2 - API/Интеграционные тесты: Должны занимать средний уровень в пирамиде. Эти тесты направлены на проверку серверной части приложения и тестируют взаимодействие между системами. Они быстрее, стабильнее и проще в поддержке, чем UI-тесты.

3 - Изоляционные/Юнит/Компонентные тесты: Занимают самую большую часть тестов и обычно пишутся разработчиками. Эти тесты выполняются на уровне отдельных модулей или компонентов, не затрагивая внешние зависимости. Они выполняются очень быстро, стабильны и легко поддерживаются.

Пирамида автоматизации помогает построить эффективную тестовую модель и правильно распределить ресурсы, но важно помнить, что она является общей рекомендацией и не всегда подходит для всех продуктов.



Исключения

Иногда пирамида тестирования может не работать. Например, если ваше приложение состоит в основном из клиентской части и очень небольшой серверной части, процент UI/E2E-тестов может быть выше. В таких случаях рекомендуется адаптировать подход к тестированию с учётом особенностей продукта, а не строго следовать пирамиде. Анализ тестируемого продукта и гибкость в подходе к автоматизации позволят вам эффективно распределить усилия и ресурсы.



******************************************

2 - 2.6 -

Основные инструменты автоматизации тестирования


Язык программирования -
Выбор инструментов автоматизации тестирования начинается с выбора языка программирования, на котором будут написаны автотесты. В данном курсе мы будем работать с Python, и все инструменты будут ориентированы на этот язык. Python — один из самых популярных языков для автоматизации тестирования благодаря простоте синтаксиса и обширной экосистеме библиотек.

Основные языки, используемые в автоматизации тестирования:
- Python (https://www.python.org/)
- Java (https://www.java.com/ru/)
- TypeScript/JavaScript (https://www.typescriptlang.org/, https://www.javascript.com/)
- C# (https://learn.microsoft.com/en-us/dotnet/csharp/)
- Golang (https://go.dev/)

Остальные языки применяются намного реже. Лично я считаю Python оптимальным выбором для автоматизации тестирования, так как эта область часто требует написания множества скриптов для проверки функциональности, и в этом Python особенно хорош. Благодаря его выразительному синтаксису и множеству библиотек, разработка и поддержка автотестов на Python становятся более эффективными.


Инструмент для работы с HTTP -
В рамках данного курса мы будем взаимодействовать с API через HTTP-протокол. Поэтому важно выбрать подходящий инструмент для отправки HTTP-запросов. Рассмотрим наиболее популярные библиотеки:
- HTTPX (https://www.python-httpx.org/)
- Requests (https://requests.readthedocs.io/en/latest/)
- (Дополнительно: aiohttp (https://docs.aiohttp.org/en/stable/) - но мы её использовать не будем)


Почему HTTPX?
Мы будем использовать HTTPX в данном курсе по нескольким причинам:

1 - Поддержка асинхронности - 
    - HTTPX позволяет писать как синхронный, так и асинхронный код (async/await).
    - Requests не поддерживает асинхронность и никогда не будет её поддерживать.

Даже если в рамках курса мы будем писать только синхронные API-тесты, возможность работы с асинхронностью даёт большую гибкость. В реальных проектах всё чаще встречаются асинхронные сервисы, и в будущем это знание может пригодиться.

2 - Встроенная аннотация типов -
    - HTTPX имеет хорошую поддержку type hints, что упрощает разработку, повышает читаемость кода и помогает избежать ошибок.
    - Requests до сих пор не имеет встроенных аннотаций типов.

В больших проектах аннотации типов помогают избежать множества ошибок и делают код понятнее. Использование библиотеки с хорошей типизацией позволяет писать более надёжный код, особенно если в тестах активно используются IDE и статический анализатор (например, mypy).

3 - Удобный клиент (Client) -
HTTPX предоставляет объект Client, который поддерживает:
    - Параметр base_url — позволяет задать базовый URL для всех запросов.
    - Пул соединений — улучшает производительность при множественных запросах.
    - В Requests такого удобного клиента нет.

Для API-тестов это особенно полезно: можно заранее задать базовый URL тестируемого сервиса и не дублировать его в каждом запросе.

4 - Поддержка Event Hooks -
    - HTTPX позволяет легко обрабатывать события запроса и ответа с помощью event hooks.
    - Requests не поддерживает аналогичного механизма.

В API-тестах часто возникает необходимость логирования запросов и ответов, а также добавления кастомных обработчиков (например, для автоматического обновления токенов). В HTTPX это можно реализовать нативно и удобно.


Почему не Requests?
Requests остаётся отличной библиотекой, но:
- Requests — устаревшая библиотека без активного развития. HTTPX — более новая и учитывает современные требования к HTTP-клиентам.
- У неё нет встроенной асинхронности.
- Отсутствуют аннотации типов, что усложняет работу в больших проектах.
- Не поддерживает удобные механизмы, такие как base_url и event hooks.

В целом Requests и HTTPX очень похожи, и если вы уже работали с Requests, переход на HTTPX будет простым. Однако HTTPX предлагает больше возможностей и удобств.


Почему не aiohttp?
aiohttp — ещё одна библиотека для работы с HTTP, но:
- Она только асинхронная, что не всегда удобно для автотестов.
- Её основной сценарий — написание серверных приложений и высоконагруженных клиентов.

Поэтому aiohttp не является лучшим выбором для API-тестирования, где важно поддерживать и синхронный, и асинхронный подход.


Итог
Requests и HTTPX взаимозаменяемы, и принципиальной разницы в базовом использовании для API-тестов нет. Однако:
- HTTPX современнее и имеет активную поддержку.
- Гибкость — можно писать как синхронный, так и асинхронный код.
- Лучшая типизация, что помогает писать более чистый и надёжный код.
- Более удобный Client, который упрощает работу с API.
- Поддержка event hooks — это делает HTTPX мощным инструментом для тестирования.

Поэтому в данном курсе мы будем использовать именно HTTPX. Подробное сравнение с Requests будет в уроке "Введение в HTTPX".



Сериализация, десериализация и валидация данных

При работе с API-тестами нам необходим инструмент для работы с данными. Он должен:
- Преобразовывать JSON в объекты и обратно.
- Валидировать входные данные.
- Автоматически генерировать JSON Schema.
- Позволять работать с алиасами, кастомными типами данных и многим другим.

И здесь без альтернатив — мы будем использовать Pydantic (https://docs.pydantic.dev/latest/)


Почему именно Pydantic?
Pydantic — это самая мощная, удобная и популярная библиотека для работы с данными в Python. Её основные преимущества:

1 - Автоматическая валидация данных
- Pydantic проверяет соответствие типов данных при создании объектов.
- Возможность задавать кастомные валидации с помощью аннотаций и декораторов.

2 - Работа с JSON и сериализация
- Можно легко преобразовать объект в dict или JSON.
- Поддержка алиасов для удобства работы с API.

3 - Генерация JSON Schema
- Pydantic автоматически создаёт JSON Schema для моделей, что упрощает документацию API.

4 - Простота и читаемость кода
- Позволяет работать с данными как с объектами (model.attr), а не просто словарями.



Какие есть альтернативы?

Если кто-то не использует Pydantic, обычно применяются:

1 - Dataclasses (https://docs.python.org/3/library/dataclasses.html)
- По сути, "Pydantic на минималках".
- Позволяют представлять данные в виде объектов (dataclass), но:
    - Нет встроенной валидации типов.
    - Нет автоматической генерации JSON Schema.
    - Нельзя создавать объекты из JSON-строк.
    - Нет поддержки алиасов и сериализации.

2 - TypedDict и NamedTuple (https://peps.python.org/pep-0589/, https://docs.python.org/3/library/collections.html#collections.namedtuple)
- TypedDict — это словари с аннотацией типов. Они полезны, но не дают удобных механизмов валидации и сериализации.
- NamedTuple — это неизменяемые структуры данных, схожие с tuple, но с атрибутами. Они не предназначены для полноценной работы с API-данными.

3 - Игнорирование аннотаций типов
- Некоторые пишут тесты без аннотации типов, используя обычные dict. Это ведёт к большему количеству ошибок и усложняет поддержку кода.


Итог -
Pydantic — лучшее решение для работы с данными. Он заменяет dataclass, TypedDict, NamedTuple и любые кастомные решения. Тем не менее, многие QA Automation Engineers почему-то продолжают изобретать костыли вместо того, чтобы использовать Pydantic.

Мы будем работать с Pydantic в рамках курса, так как это самая мощная, удобная и широко используемая библиотека для валидации и сериализации данных.



Инструмент для запуска автотестов

После выбора инструмента для работы с браузером нам также нужен инструмент, который позволит эффективно писать, организовывать и запускать автотесты. Такой инструмент не обязателен, но он делает процесс написания и запуска автотестов значительно проще и удобнее.

В нашем случае основным инструментом будет pytest (https://docs.pytest.org/en/stable/) — самый популярный фреймворк для тестирования на языке Python. Pytest предоставляет широкие возможности для запуска тестов, фильтрации, параметризации, а также интеграции с другими библиотеками. Если вы ещё не используете pytest, самое время познакомиться с ним, так как это действительно мощный и гибкий инструмент для автоматизации тестирования.


Преимущества pytest - 

1 - Запуск и фильтрация тестов: pytest позволяет удобно запускать тесты по имени, тегу или другим критериям, что делает процесс тестирования гибким.

2 - Параметризация тестов: возможность запускать один и тот же тест с различными входными данными, что упрощает создание вариативных тестов для одной и той же функциональности.

3 - Пропуск и повторный запуск тестов: pytest позволяет временно пропускать тесты, например, если на них заведены баги, а также перезапускать тесты, чтобы снизить вероятность ложных падений из-за нестабильности среды.

4 - Поддержка плагинов и расширяемость: у pytest есть огромная экосистема плагинов, таких как pytest-xdist для параллельного запуска тестов и pytest-html для генерации отчетов. Это делает его гибким инструментом, способным покрыть практически любые потребности в тестировании.



Другие инструменты для запуска автотестов

Существует также ряд альтернатив pytest, таких как:
- Behave (https://behave.readthedocs.io/en/latest/)
- Robot Framework (https://robotframework.org/)
- Unittest, встроенный в Python (https://docs.python.org/3/library/unittest.html)

Behave и Robot Framework используют язык Gherkin, позволяя описывать тестовые сценарии в человекочитаемом формате. Пример сценария на Gherkin:
--
Scenario: Breaker guesses a word
  Given the Maker has chosen a word
  When the Breaker makes a guess
  Then the Maker is asked to score
----

На первый взгляд это кажется удобным, но на практике Gherkin может усложнять разработку автотестов, делая их поддержание и расширение более трудоемкими. Если хотите получить глубокий и прикладной опыт в автоматизации, я рекомендую избегать использования Behave и Robot Framework, так как они могут ограничивать гибкость и усложнять написание тестов.

Unittest — это стандартный модуль для тестирования в Python. Он прост, но достаточно ограничен по возможностям, что делает его менее удобным для сложных тестовых сценариев. Unittest лучше всего подходит для простых юнит-тестов, но даже в этом случае многие специалисты предпочитают писать их на pytest, благодаря его гибкости и широким возможностям.

Вывод -
Pytest — это незаменимый инструмент для написания и запуска автотестов на Python. Он предоставляет гибкие возможности для работы с тестами и является стандартом в индустрии автоматизации на Python.



Инструмент для формирования отчетов по тестированию

После выбора инструмента для запуска автотестов нам нужен инструмент для анализа результатов тестирования. В данном случае отличным выбором является Allure (https://allurereport.org/) — популярный и мощный инструмент для создания отчетов, который наглядно отображает результаты тестов, улучшая процесс анализа.

Преимущества Allure -

1 - Интерактивный интерфейс: Allure предоставляет удобный и интуитивно понятный интерфейс, где можно видеть состояние тестов, время их выполнения, шаги, логирование и даже вложенные скриншоты и видео.

2 - Поддержка шагов и тегов: Allure позволяет легко разбивать тесты на шаги, что улучшает читаемость и понимание логики тестов, а также предоставляет возможность фильтрации по тегам.

3 - Интеграция с инструментами CI/CD: Allure легко интегрируется с популярными системами CI/CD, такими как Jenkins, GitLab, TeamCity и другие, что упрощает автоматическое создание отчетов после каждого запуска тестов.

4 - Гибкость и расширяемость: Allure поддерживает расширения и плагины, что позволяет адаптировать отчеты под нужды команды и включать в них дополнительные данные (например, окружение, версии зависимостей).


Сравнение с другими инструментами

Allure стал стандартом для отчетов в автоматизации тестирования и практически не имеет достойных альтернатив. Если сравнить Allure с другими решениями, то они зачастую проигрывают по функциональности и удобству. Можно сказать, что Allure в мире отчетов для автотестов — это как Telegram среди мессенджеров: есть аналоги, но все они уступают по удобству и возможностям.

Заключение

Allure — это незаменимый инструмент для создания отчетов по автотестам, который улучшает видимость результатов, облегчает анализ ошибок и помогает командам эффективно отслеживать статус тестов.



Система контроля версий

После написания автотестов и формирования отчетов необходимо сохранить код и организовать совместную работу над проектом, особенно если в нем участвует несколько автоматизаторов. Здесь на помощь приходит система контроля версий, позволяющая отслеживать изменения в коде, управлять ветками, разрешать конфликты и организовывать работу над проектом в команде.

Система контроля версий (или VCS — Version Control System) позволяет хранить код проекта, управлять изменениями, вести историю правок и облегчать командное взаимодействие. Основные и самые популярные системы контроля версий включают:

1 - GitHub (https://github.com/)
Самая популярная VCS, особенно среди open-source проектов и разработчиков по всему миру. GitHub предоставляет удобный интерфейс для совместной работы, обсуждения кода, создания пул-реквестов и управления версиями. Благодаря доступности и поддержке множества интеграций, GitHub стал стандартом в индустрии для многих команд и компаний.

2 - GitLab (https://about.gitlab.com/)
Очень популярен в корпоративной среде, так как имеет встроенные инструменты CI/CD, удобные для внутренних корпоративных проектов. GitLab можно использовать как облачное решение или установить на собственные серверы, что повышает его привлекательность для компаний с высокими требованиями безопасности и приватности данных.

3 - Bitbucket (https://bitbucket.org/product/)
Еще одно корпоративное решение, но менее распространенное, чем GitLab. Bitbucket поддерживает интеграцию с другими продуктами Atlassian, такими как Jira и Confluence, что делает его полезным для команд, активно работающих с экосистемой Atlassian.

4 - Gerrit (https://www.gerritcodereview.com/)
Старый инструмент, который в основном используется в устаревших проектах или проектах с высокой степенью контроля кода. Gerrit может быть полезен для строгого контроля над ревью, но на сегодняшний день он все реже используется в новых проектах.


Заключение

Наиболее современным и гибким решением является Git, с его популярными платформами — GitHub, GitLab и Bitbucket. Эти платформы позволяют эффективно управлять кодом, организовывать совместную работу, легко интегрироваться с CI/CD и другими инструментами, что делает их незаменимыми в процессе разработки автотестов.



CI/CD система

CI/CD — это Continuous Integration (непрерывная интеграция) и Continuous Deployment/Delivery (непрерывное развертывание/доставка). Эти процессы помогают автоматизировать сборку, тестирование и развертывание кода, делая его обновление более быстрым и надежным.

- Continuous Integration (CI) — практика частого объединения кода, написанного разработчиками, в общую кодовую базу. CI-системы автоматически проверяют каждый коммит, выполняют сборку проекта и запускают тесты, что помогает оперативно находить и устранять ошибки.

- Continuous Delivery (CD) — автоматизация последующих этапов, которая позволяет подготовить изменения в коде для развертывания на продакшн или другие среды. Этот процесс включает упаковку, создание релизов и тестирование на этапах ближе к реальному развертыванию.

- Continuous Deployment (CD) — следующая ступень автоматизации, при которой изменения, прошедшие все тесты и проверки, автоматически развертываются на продакшн-среде.

Цель CI/CD — упростить и ускорить выпуск обновлений, снижая вероятность ошибок и увеличивая частоту релизов.



Рассмотрим несколько популярных CI/CD систем, используемых в индустрии:

1 - GitLab CI/CD (https://about.gitlab.com/)
GitLab имеет встроенную CI/CD систему, что делает его отличным выбором для компаний, которые уже используют GitLab как систему контроля версий. GitLab CI/CD позволяет автоматизировать процесс сборки, тестирования и развертывания прямо на платформе. Интеграция с GitLab, гибкость в настройке пайплайнов, управление окружениями и поддержка Docker делают его особенно популярным в корпоративной среде.

2 - Jenkins (https://www.jenkins.io/)
Один из самых известных и универсальных инструментов для CI/CD, с поддержкой множества плагинов и интеграций. Jenkins — это open-source решение, которое можно гибко настроить под любые требования. Подходит для организаций, желающих полной кастомизации, но требует времени на установку и настройку.

3 - CircleCI (https://circleci.com/)
Облачная CI/CD платформа, которая отлично подходит для автоматизации сборок и тестов в распределённых командах. CircleCI легко интегрируется с GitHub и GitLab, что делает его популярным среди команд, которые хотят быстро развернуть CI/CD процессы с минимальными настройками.

4 - GitHub Actions (https://github.com/features/actions)
Инструмент CI/CD, встроенный в GitHub, который позволяет создавать автоматизированные пайплайны для проверки, сборки и развертывания кода. GitHub Actions предоставляет отличные возможности для интеграции, а также мощный и гибкий синтаксис для создания воркфлоу с событиями, такими как коммиты, пул-реквесты и релизы.

5 - TeamCity (https://www.jetbrains.com/teamcity/)
Коммерческая CI/CD система от компании JetBrains, известной своими инструментами для разработки. TeamCity поддерживает множество языков и платформ, легко интегрируется с другими продуктами JetBrains и предоставляет мощные возможности для настройки и анализа пайплайнов.


Выбор CI/CD системы зависит от требований проекта, инфраструктуры и используемых систем контроля версий. GitLab CI/CD и GitHub Actions популярны благодаря своей интеграции с платформами GitLab и GitHub, CircleCI и Jenkins предлагают гибкость и мощные возможности для кастомизации, а TeamCity подойдет для компаний, которые используют JetBrains и готовы инвестировать в коммерческое решение.



- А когда requests / aiohttp используется с BeautifulSoup и DOM - это какое взаимодействие считается, через UI?
- Не совсем, использование requests или aiohttp с BeautifulSoup не считается взаимодействием через UI. Это работа напрямую с HTML-документом, как с текстом — мы не запускаем браузер, не эмулируем действия пользователя, не взаимодействуем с JavaScript или DOM в живом виде.
- requests / aiohttp скачивают HTML как обычный текст.
- BeautifulSoup просто парсит этот текст и даёт нам удобный доступ к тегам.
- Это статический анализ HTML, а не взаимодействие с реальным DOM в браузере. 
Я бы отнес это к обычному парсингу документов 



******************************************

3 - 3.1 -

Установка и настройка окружения Python

=
































