
эти 2 курса - telegram - избранное - 13-07-2025 и 14-07-2025
+
жд4тб - _CODING/_QA/Nikita API + UI + нагрузочное


проходить так - сначала изучить весь текст темы, и только после этого смотреть видео, глядя на свои заметки по этой теме


******************************************

Автоматизация тестирования API с Python -

******************************************
******************************************
******************************************

1 - 1.1 -

В этом курсе мы буквально разберем на атомы тему автоматизации тестирования API. Наша цель — не просто научиться отправлять запросы к API и проверять коды ответа, а построить полноценный фреймворк автотестов, который можно использовать в реальных проектах.

Этот курс — не про "как отправить запрос"
Большинство API-курсов поверхностны и учат только "как отправить запрос". Этот курс — совершенный технический фундамент для становления QA Automation Engineer.

Большинство курсов ограничиваются HTTP-запросами и называют это "API-тестами". В реальности API — это не только HTTP. Мы будем работать с gRPC, WebSocket, TCP/IP и детально разберем принципы HTTP.



******************************************

1 - 1.2 -

сначала прочитать тест урока а потом уже смотреть видео 

повторять все действия за автором 

после каждого задания добавлять код на GitHub (коммит)

не пропускать уроки и задания 

если не хватает теории - попробуй разобратся самостоятельно, почитай документацию к фреймворку или библиотеке, загугли вопрос 

данный курс предусматривает что у тебя уже есть базовое понимание python 



******************************************

в 1 - 1.1 - 3 - ссылки на уроки по основам python -

Этот курс предполагает базовые знания Python. Если вы не уверены в следующих темах, рекомендую сначала их повторить:

Переменные -
https://www.w3schools.com/python/python_variables.asp

Типы данных -
https://www.w3schools.com/python/python_datatypes.asp

Функции -
https://www.w3schools.com/python/python_functions.asp

Логические операторы -
https://www.w3schools.com/python/python_conditions.asp

Циклы -
https://www.w3schools.com/python/python_for_loops.asp

Lambda-функции -
https://www.w3schools.com/python/python_lambda.asp

Классы -
https://www.w3schools.com/python/python_classes.asp

Знакомство с пакетным менеджером pip -
https://www.w3schools.com/python/python_pip.asp

Работа со строками и форматирование строк -
https://www.w3schools.com/python/python_string_formatting.asp

Для закрепления основ Python, рекомендую следующие бесплатные курсы, которые можно пройти за одну-две недели -

Бесплатный курс по Python от W3Schools -
https://www.w3schools.com/python/default.asp

Бесплатный курс по Python от Metanit -
https://metanit.com/python/tutorial/



******************************************

1 - 1.3 -

выполнить задание - зафиксировать в коммите  



******************************************

1 - 1.4 -

гугление и самостоятельный поиск информации - это очень важный навык 

не пропускать уроки и задания 



******************************************

2 - 2.1 - Основы тестирования программного обеспечения

Что такое Quality Assurance (QA)? -
Quality Assurance (QA) или Обеспечение качества — это совокупность мер и процессов, направленных на предотвращение дефектов в продуктах или услугах компании. QA сосредоточено на повышении качества разработки и поддержке стабильности продукта, что позволяет сократить количество ошибок на всех стадиях жизненного цикла продукта. Это не только тестирование, но и стандартизация, контроль и оптимизация всех процессов разработки, начиная от планирования до финальной сдачи продукта.

QA не отвечает напрямую за обнаружение ошибок. Его главная задача — предотвратить их появление, что достигается путём создания четких процессов разработки и тестирования, вовлечения всех участников и внедрения лучших практик.

Что такое тестирование? -
Тестирование — это процесс проверки работы программного обеспечения для выявления ошибок, отклонений от требований и обеспечения качества продукта. Тестирование проводится для того, чтобы подтвердить, что продукт работает корректно и соответствует ожиданиям пользователей и техническим требованиям. Оно помогает обнаружить ошибки на разных уровнях разработки и тем самым улучшить качество продукта.

Тестирование делится на несколько видов, включая функциональное, нефункциональное (например, производительность), автоматизированное и ручное тестирование, и охватывает широкий спектр методов и техник.



Цели тестирования - Тестирование преследует несколько целей:

1 - Обнаружение ошибок: Основная цель тестирования — выявить ошибки и проблемы в программном обеспечении, которые могут негативно повлиять на пользователей или функциональность продукта.

2 - Проверка соответствия требованиям: Тестирование позволяет убедиться, что продукт соответствует требованиям, которые к нему предъявляются, и ведёт себя предсказуемо в соответствии с бизнес-логикой.

3 - Повышение надежности и стабильности продукта: Регулярное тестирование помогает обнаружить и устранить потенциальные дефекты, повышая устойчивость и стабильность программного обеспечения.

4 - Уменьшение рисков: Чем раньше найдена ошибка, тем дешевле и проще её исправить. Это снижает финансовые риски и помогает избежать критических проблем на поздних стадиях.

5 - Обеспечение пользовательского опыта: Хорошо протестированный продукт создаёт положительный пользовательский опыт, что повышает лояльность пользователей и положительно влияет на имидж компании.

6 - Поддержка команды разработки: Тестирование помогает разработчикам получать быструю обратную связь по внесённым изменениям и исправлениям, что ускоряет и облегчает процесс разработки.



Зачем компании нужны тестировщики? - Компании нанимают тестировщиков для обеспечения качества выпускаемого программного обеспечения по нескольким важным причинам:

1 - Предотвращение ошибок до выхода в продакшен: Тестировщики помогают находить ошибки до того, как продукт увидит конечный пользователь. Это снижает затраты на исправление ошибок и позволяет избежать негативной реакции со стороны пользователей.

2 - Снижение нагрузки на разработчиков: С помощью тестировщиков разработчики могут сосредоточиться на кодировании и внедрении новых функций, тогда как тестировщики берут на себя задачу проверки качества продукта.

3 - Поддержка стандартов качества: Тестировщики следят за соблюдением стандартов качества, которые важны для репутации компании, особенно если продукт ориентирован на массовый рынок или критически важные процессы.

4 - Понимание пользовательских сценариев: Тестировщики часто рассматривают продукт с точки зрения пользователя, что помогает обнаружить проблемы с удобством использования и логику, которые могут быть упущены разработчиками.

5 - Ускорение выхода продукта: Автоматизация тестирования и другие методики помогают ускорить процесс выпуска новых версий продукта. Это особенно важно в компаниях, где необходимо поддерживать высокий темп разработки и быструю реакцию на требования рынка.



Базовая терминология тестирования -

- Smoke-тестирование: Это быстрое тестирование, направленное на проверку работоспособности основных функций системы после сборки или внедрения изменений. Если smoke-тесты проходят успешно, можно продолжать более глубокое тестирование.

- Регрессионное тестирование: Оно проверяет, что новые изменения или исправления не нарушили работу уже существующих функциональностей. Регрессионное тестирование часто автоматизируется, чтобы быть уверенным в стабильности продукта после каждой итерации.

- Функциональное тестирование: Направлено на проверку функциональных аспектов продукта, таких как входные и выходные данные, а также соответствие требованиям, описанным в спецификации.

- Нефункциональное тестирование: Это тестирование таких характеристик, как производительность, надёжность и безопасность. Оно включает в себя тестирование скорости, устойчивости к нагрузке, удобства использования и других показателей, влияющих на пользовательский опыт.

- Тестирование черного и белого ящика: В черном ящике тестировщик не имеет доступа к коду и проверяет только функциональность, доступную пользователю. В белом ящике тестировщик анализирует внутреннюю структуру кода, что помогает в обнаружении ошибок на более низком уровне.



Подходы и методы тестирования -

1 - Ручное тестирование: Тестировщик вручную выполняет тесты, проверяя продукт на наличие ошибок, функциональных или нефункциональных отклонений.

2 - Автоматизированное тестирование: Использует программные инструменты и скрипты для автоматизации тестов, что помогает снизить время и ресурсы, требуемые для выполнения повторяющихся задач. Автоматизированные тесты идеально подходят для регрессионного тестирования.

3 - Интеграционное тестирование: Проверяет взаимодействие между компонентами или модулями системы, чтобы убедиться, что они работают вместе корректно.

4 - Системное тестирование: Осуществляется на полностью интегрированной системе и проверяет её соответствие всем заданным требованиям.

5 - Приемочное тестирование: Проводится в конце цикла разработки для подтверждения, что продукт готов к выпуску и отвечает требованиям клиентов.



Схема по видам тестирования - в основной папке где этот курс - 
для курсов по ручному тестированию или ISTQB-подготовке она может быть особенно полезна. В рамках курса по автоматизации я намеренно оставляю только наиболее прикладные виды: те, с которыми вы будете реально работать — функциональное, регрессионное, модульное, интеграционное и т.п.

Остальные категории — конечно, тоже существуют, но они либо редко автоматизируются, либо требуют отдельной специализации (как, например, тестирование локализации или тестирование восстановления после сбоев).



Резюме -

Тестирование — это важный процесс, который помогает компании выпускать качественный продукт, избегать ошибок на ранних этапах разработки и строить репутацию надёжного поставщика ПО. Тестировщики, как часть процесса обеспечения качества, играют ключевую роль в достижении этих целей, помогая создавать продукты, которые не только работают корректно, но и удовлетворяют потребности конечных пользователей.



******************************************

2 - 2.2 - Основные виды тестирования



1 - Функциональное тестирование (Functional Testing)

Это вид тестирования, направленный на проверку функциональности приложения и его соответствия требованиям. Он проверяет, насколько правильно работает каждая функция, описанная в технической спецификации.
- Примеры: Тестирование ввода данных в форму, проверка нажатия кнопок, валидация полей, логика калькулятора.
- Когда используется: В основном на всех этапах разработки, чтобы убедиться, что функции работают корректно.



2 - Нефункциональное тестирование (Non-Functional Testing)

Нефункциональное тестирование охватывает такие аспекты, как производительность, надежность, безопасность и удобство использования. Этот вид тестирования проверяет, как приложение работает, а не то, что оно делает.
- Примеры: Тестирование производительности, безопасности, удобства использования.
- Когда используется: При необходимости проверить поведение системы при различных нагрузках, доступах, ситуациях и других условиях, влияющих на качество работы приложения.



3 - Smoke-тестирование

Smoke-тестирование выполняется для быстрого анализа основных функций продукта после сборки. Оно помогает убедиться, что система готова к более детальному тестированию.
- Примеры: Проверка входа в систему, загрузки главной страницы, работы ключевых функциональностей.
- Когда используется: В начале каждого нового цикла тестирования, чтобы проверить стабильность основной функциональности.



4 - Регрессионное тестирование (Regression Testing)

Регрессионное тестирование проводится для проверки того, что изменения или новые функции не повлияли на работу существующего функционала. Это тестирование повторяется после каждого изменения.
- Примеры: Перепроверка работы логики авторизации, функциональности корзины после добавления новых функций.
- Когда используется: После каждого изменения кода, исправления ошибок или добавления новых функций.



5 - Тестирование безопасности (Security Testing)

Это тестирование направлено на проверку безопасности системы и её защиты от различных угроз. Оно включает проверку на уязвимости, которые могут позволить злоумышленникам получить несанкционированный доступ.
- Примеры: Проверка защиты паролей, тестирование SQL-инъекций, тестирование уязвимостей при доступе к файлам.
- Когда используется: Обычно проводится на всех проектах, особенно если данные, хранимые в приложении, являются конфиденциальными.



6 - Тестирование производительности (Performance Testing)

Тестирование производительности определяет, как система работает под нагрузкой и каковы её пределы. Включает тесты на скорость отклика, устойчивость и пропускную способность.
- Примеры: Тестирование времени отклика сервера, устойчивости системы при большом числе запросов.
- Когда используется: При необходимости проверить масштабируемость и производительность, особенно для высоконагруженных систем.



7 - Тестирование совместимости (Compatibility Testing)

Этот вид тестирования проверяет, как система работает на разных устройствах, браузерах и операционных системах, обеспечивая её кроссплатформенность.
- Примеры: Проверка корректности отображения сайта на мобильных устройствах, совместимость с различными версиями браузеров.
- Когда используется: Для кроссплатформенных и кроссбраузерных приложений, которые должны работать на разных устройствах и ОС.



8 - Интеграционное тестирование (Integration Testing)

Интеграционное тестирование проверяет взаимодействие между модулями системы, чтобы убедиться, что компоненты работают вместе корректно.
- Примеры: Проверка взаимодействия между модулями аутентификации и авторизации, взаимодействие фронтенда и бэкенда.
- Когда используется: После модульного тестирования, когда модули объединены в систему.



9 - Системное тестирование (System Testing)

Это тестирование полной, интегрированной системы для проверки её соответствия всем функциональным и нефункциональным требованиям.
- Примеры: Проверка общей работоспособности приложения, функциональности, производительности и безопасности на конечной системе.
- Когда используется: Когда все модули объединены, и продукт готов к выпуску.



10 - Приемочное тестирование (Acceptance Testing)

Это тестирование проводится для подтверждения, что продукт удовлетворяет требованиям бизнеса и готов к выпуску. Включает сценарии, приближенные к реальной работе пользователей.
- Примеры: Проверка всей пользовательской функциональности перед выпуском.
- Когда используется: Перед выпуском продукта клиенту или на рынок.



11 - Тестирование пользовательского интерфейса (UI Testing)

UI-тестирование проверяет, как выглядят и функционируют элементы интерфейса, такие как кнопки, поля ввода, меню.
- Примеры: Проверка цвета кнопок, правильного расположения и размера элементов.
- Когда используется: Когда необходимо убедиться в правильности отображения и работы интерфейса.



12 - Тестирование удобства использования (Usability Testing, тестируем UX - удобство использования)

Usability Testing определяет, насколько удобно и просто использовать продукт. Часто проводится с участием конечных пользователей.
- Примеры: Проверка того, насколько легко пользователю выполнить основные операции.
- Когда используется: Для продуктов, ориентированных на конечных пользователей, где важен удобный интерфейс.



13 - Тестирование интерфейсов (API Testing)

Тестирование интерфейсов, или API, проверяет взаимодействие между клиентом и сервером, а также корректность работы API, его ответов и обработки ошибок.
- Примеры: Проверка работы запросов GET, POST, корректного ответа API при неверных данных.
- Когда используется: Для приложений с архитектурой клиент-сервер и взаимодействующих через API.



14 - Альфа-тестирование и бета-тестирование

Эти виды тестирования проводятся на финальных этапах разработки. Альфа-тестирование выполняется внутри компании, а бета-тестирование — с участием конечных пользователей.
- Примеры: Альфа-тестирование — внутренняя проверка с устранением всех выявленных ошибок. Бета-тестирование — использование продукта конечными пользователями для оценки удобства и поиска багов.
- Когда используется: Перед финальным релизом продукта.



15 - Эксплуатационное тестирование (Operational Testing)

Проводится в условиях, максимально приближенных к реальной эксплуатации, чтобы убедиться, что продукт готов к использованию и выдерживает реальные нагрузки и эксплуатационные условия.
- Примеры: Проверка системы в рабочем окружении компании-клиента.
- Когда используется: На завершающем этапе разработки и в процессе внедрения продукта.



Резюме -

Каждый вид тестирования имеет свои цели и отвечает на определённые вопросы: насколько функционально, безопасно, производительно или удобно использовать систему. Выбор видов тестирования зависит от специфики проекта, требований к нему и стадии разработки, на которой находится продукт. Правильная комбинация этих методов позволяет создавать качественный продукт, который соответствует ожиданиям пользователей и требованиям бизнеса.



Практикуемся по видам тестирования

В данном задании вам необходимо самостоятельно провести смоук-тестирование для приложения UI Course по ссылке: 
https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login

Перед началом выполнения задания рекомендую внимательно изучить функционал приложения UI Course, чтобы лучше понять, какие основные функции необходимо протестировать.



Что такое смоук-тестирование?

Смоук-тестирование — это базовый уровень тестирования, который позволяет проверить, что основные функции приложения работают корректно после внесения изменений или обновлений. Основная цель заключается в выявлении критических ошибок, которые могут помешать дальнейшему тестированию приложения.



Основные функции приложения -
1 - Регистрация и авторизация
2 - Навигация
3 - Функциональность курсов
4 - Выход из приложения



Задача

Вашим ответом на данное задание будет описание действий, которые необходимо совершить для проведения смоук-тестирования этого приложения. Опишите каждый из вышеуказанных модулей, указав, что вы проверяли, какие результаты ожидали, и что фактически наблюдали. Если во время тестирования вы столкнулись с какими-либо проблемами или ошибками, обязательно упомяните их в своем ответе



Пример

1 - Открываем приложение UI Course https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login
2 - Переходим на страницу регистрации https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration
3 - Регистрируемся в приложении UI Course
4 - ...



******************************************

2 - 2.3 - Техники тест-дизайна

Техники тест-дизайна — это методы, которые помогают тестировщикам создавать тесты, покрывающие функциональные и нефункциональные требования к системе. Эти техники позволяют оптимизировать процесс тестирования, сократить количество тестов без потери качества, повысить вероятность выявления ошибок и улучшить эффективность тестирования. Разберём основные техники.



Основные техники тест-дизайна - 


1 - Эквивалентное разделение (Equivalence Partitioning)

Эта техника подразумевает разделение всех возможных входных данных на несколько групп или классов эквивалентности. Каждая группа или класс представляет собой подмножество значений, которые, по предположению, обрабатываются системой одинаково. Тестирование одной группы эквивалентно тестированию других значений из той же группы.
- Пример: Поле для ввода возраста принимает значения от 18 до 60. Можно создать три группы эквивалентности:
    - допустимые значения (18–60),
    - значения ниже допустимого диапазона (меньше 18),
    - значения выше допустимого диапазона (больше 60).
- Когда используется: При необходимости сократить количество тестов и избежать тестирования каждого значения в диапазоне.


2 - Анализ граничных значений (Boundary Value Analysis)

Этот метод используется для тестирования крайних значений диапазона. Граничные значения — это те, которые находятся на границе классов эквивалентности, и часто именно они могут вызывать ошибки.
- Пример: Если допустимый диапазон значений 18–60, то тестировать можно значения 17, 18, 60, 61.
- Когда используется: В ситуациях, когда существует ограниченный диапазон допустимых значений, особенно если ошибки часто появляются на границах диапазона.


3 - Таблица решений (Decision Table Testing)

Таблица решений помогает тестировать сложные комбинации условий, показывая зависимость между входными данными и ожидаемыми результатами. В ней описаны условия и действия, которые позволяют тестировщику учитывать различные комбинации входных значений и реакции системы.
- Пример: Вход в систему возможен при условии, что введены верные логин и пароль, и двухфакторная аутентификация пройдена успешно. Таблица решений поможет учесть все возможные комбинации этих условий.
- Когда используется: Для тестирования сложной логики, когда результат зависит от множества условий и их комбинаций.


4 - Таблица переходов состояний (State Transition Testing)

Техника применяется для тестирования систем, поведение которых зависит от текущего состояния и событий, которые приводят к переходу из одного состояния в другое.
- Пример: Система банкомата, в которой переходы зависят от состояний пользователя (введен ли PIN, достаточно ли средств на счету и т.д.).
- Когда используется: Когда система имеет различные состояния, зависящие от последовательности выполненных операций.


5 - Метод причинно-следственного графа (Cause-Effect Graphing)

Техника включает построение графа, в котором отображены причины (условия) и следствия (результаты), после чего составляются тест-кейсы для покрытия различных путей графа. Это позволяет проверить, как система обрабатывает комбинации различных условий.
- Пример: В логике приложения есть несколько условий, и для различных их комбинаций выполняются разные действия. Граф причин и следствий помогает учесть все возможные комбинации этих условий и результаты.
- Когда используется: В сложных системах, где есть много логических зависимостей и комбинаций условий.


6 - Исчерпывающее тестирование (Exhaustive Testing)

Техника подразумевает тестирование всех возможных значений входных данных. Хотя это практически невозможно для большинства случаев, исчерпывающее тестирование целесообразно при наличии малого набора входных значений.
- Пример: Если есть поле для ввода дня недели (7 вариантов), можно протестировать все 7 вариантов.
- Когда используется: В редких случаях, когда число входных данных ограничено.


7 - Комбинаторное тестирование (Pairwise Testing)

В комбинаторном тестировании используются пары всех возможных значений для переменных, чтобы минимизировать число тестов, одновременно покрывая основные комбинации. Метод pairwise testing тестирует каждую пару возможных значений хотя бы один раз, что позволяет выявить большую часть ошибок.
- Пример: Если есть три настройки, каждая из которых может принимать два значения, комбинаций может быть 8. Техника Pairwise позволяет протестировать только 4, охватывая все возможные комбинации пар значений.
- Когда используется: Когда нужно уменьшить количество тестов для многофакторных данных без потери покрытия.


8 - Исследовательское тестирование (Exploratory Testing)

Исследовательское тестирование — это неформальная техника, в рамках которой тестировщик изучает продукт, импровизирует и находит возможные ошибки, тестируя функциональность с точки зрения пользователя.
- Пример: Тестировщик, исследуя новый функционал без заранее подготовленных тест-кейсов, выявляет неожиданное поведение системы.
- Когда используется: На любом этапе разработки, особенно в условиях ограниченного времени и для поиска скрытых дефектов.


9 - Адаптивное тестирование (Ad-Hoc Testing)

Адаптивное тестирование представляет собой непринужденное тестирование без какого-либо плана или структуры. Тестировщик проверяет систему по своему усмотрению, стараясь выявить возможные дефекты.
- Пример: Тестировщик проверяет произвольные функции или комбинации данных, просто чтобы увидеть, как система на них отреагирует.
- Когда используется: В случае отсутствия времени на детальную подготовку или для быстрого поиска ошибок.


10 - Тестирование на основе использования (Use Case Testing)

Тестирование на основе использования ориентируется на сценарии использования и тестирует, насколько правильно система выполняет определенные задачи с точки зрения пользователя.
- Пример: Создание и исполнение тест-кейсов для выполнения конкретных пользовательских действий, таких как «заказ товара» или «вход в аккаунт».
- Когда используется: В случае тестирования бизнес-процессов и задач, важных для пользователей.


11 - Тестирование по сценарию (Scenario Testing)

Сценарное тестирование представляет собой тестирование через сценарии, которые описывают реальные ситуации использования. Оно позволяет охватить множество условий в одном тесте и проверить сложные пользовательские пути.
- Пример: Тестирование процесса покупки на сайте, начиная с поиска товара и заканчивая оплатой и получением квитанции.
- Когда используется: В случаях, когда нужно проверить целостные сценарии, охватывающие разные функции и логические блоки приложения.


12 - Метод сравнения с эталоном (Benchmark Testing)

Это техника тестирования, при которой результаты работы программы сравниваются с эталонными значениями или показателями. Она позволяет оценить качество и производительность системы.
- Пример: Сравнение времени отклика приложения с установленными стандартами.
- Когда используется: Для проверки производительности и соответствия установленным стандартам.



Заключение -

Техники тест-дизайна позволяют тестировщикам более эффективно проверять систему, избегая излишнего дублирования и увеличивая вероятность обнаружения ошибок. Выбор техник зависит от типа тестируемой системы, требований к качеству и ресурсов, доступных для тестирования.



Практикуемся по техникам тест-дизайна

В данном задании вам необходимо протестировать форму регистрации приложения UI Course https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration. Используйте техники тест-дизайна, которые вы изучили, чтобы обеспечить качественное тестирование формы.

Задачи:

1 - Выбор техник: Прежде чем начать тестирование, внимательно проанализируйте форму регистрации и выберите техники тест-дизайна, которые наиболее подходящие для её тестирования. Не обязательно использовать все доступные техники; выбирайте только те, которые помогут вам добиться максимального покрытия и выявления возможных ошибок.

2 - Составление списка проверок: Ответом на задание должен быть список проверок, которые вы будете выполнять при тестировании формы регистрации. Для каждой проверки укажите:
- Конкретные действия, которые необходимо выполнить.
- Ожидаемый результат.
- Применяемую технику тест-дизайна.

Пример формата ответа:

1 - Проверка на допустимость ввода электронной почты:
- Действие: Ввести некорректный формат электронной почты (например, "test@").
- Ожидаемый результат: Появление сообщения об ошибке "Некорректный формат электронной почты".
- Применяемая техника: Эквивалентное разделение.

2 - Проверка на обязательные поля:
- Действие: Оставить поля "Имя" и "Пароль" пустыми и нажать кнопку "Зарегистрироваться".
- Ожидаемый результат: Появление сообщений об ошибках, указывающих на необходимость заполнения этих полей.
- Применяемая техника: Исследовательское тестирование.



******************************************

2 - 2.4 - Артефакты тестирования и тестовая документация

Артефакты тестирования и тестовая документация — это набор документов, созданных в процессе тестирования для описания, планирования, отслеживания и анализа качества продукта. Они служат основой для организации тестирования, дают общую картину качества продукта и упрощают взаимодействие между участниками проекта. Тестовая документация также помогает зафиксировать и сохранить результаты тестирования для последующего анализа и использования.



Основные артефакты тестирования -


1 - Тест-план (Test Plan)

Тест-план — это документ, в котором описываются цели, объем, подходы и виды тестирования, которые будут применяться. Он определяет, какие функции и компоненты будут тестироваться, в какие сроки, какие ресурсы необходимы, а также включает критерии начала и окончания тестирования.
- Содержание: Цели тестирования, подход к тестированию, артефакты и процессы, которые будут использоваться, риски, сроки, роли и обязанности.
- Зачем нужен: Обеспечивает структурированный подход к тестированию и помогает команде понимать общий план и цели тестирования.


2 - Тест-кейсы (Test Cases)

Тест-кейс — это пошаговое описание действий и условий, необходимых для проверки определенной функции или функционала продукта. Каждый тест-кейс включает входные данные, действия и ожидаемый результат.
- Содержание: ID тест-кейса, название, предусловия, шаги выполнения, ожидаемый результат, постусловия.
- Зачем нужны: Обеспечивают системное покрытие функционала и позволяют проводить повторное тестирование на всех этапах разработки.


3 - Тест-сьют (Test Suite)

Тест-сьют — это набор связанных тест-кейсов, который объединяется для выполнения определенного типа тестирования или проверки функциональности. Например, тесты для функционального, smoke или регрессионного тестирования.
- Содержание: Список тест-кейсов, сгруппированных по определенным характеристикам или функциональным областям.
- Зачем нужен: Упрощает запуск и организацию тестов, особенно для автоматизированного тестирования.


4 - Чек-листы (Checklists)

Чек-лист — это упрощенный вариант тест-кейсов, содержащий только основные проверки без детализированных шагов. Используется для быстрой проверки ключевых функций или на этапе приемочного тестирования.
- Содержание: Список проверок или условий, которые должны быть выполнены для успешного завершения тестирования.
- Зачем нужен: Для проведения быстрого тестирования и оценки базовых функциональностей без глубокого погружения в детали.


5 - Трассировочная матрица (Traceability Matrix)

Матрица трассировки — это документ, который связывает требования с тест-кейсами. Она помогает убедиться, что все требования покрыты тестами, и позволяет отслеживать выполнение тестирования по требованиям.
- Содержание: Сопоставление требований и соответствующих тест-кейсов.
- Зачем нужна: Обеспечивает полное покрытие требований тестами и помогает отследить, какие из них прошли проверку, а какие ещё нет.


6 - Отчеты о дефектах (Bug Reports)

Отчет о дефекте (баг-репорт) — это документ, который описывает обнаруженные ошибки, их характеристики и статус. Он включает информацию о месте обнаружения дефекта, условиях его воспроизведения и ожидаемом результате.
- Содержание: ID дефекта, название, описание, шаги для воспроизведения, ожидаемый и фактический результат, статус, приоритет, скриншоты и другая информация.
- Зачем нужны: Для фиксации обнаруженных ошибок и передачи их разработчикам для исправления.


7 - Отчет о тестировании (Test Report)

Это документ, в котором фиксируются результаты тестирования, включая успешные и неуспешные тесты, процент покрытия тестами и выявленные дефекты. Отчет о тестировании может быть промежуточным (ежедневный, еженедельный) или итоговым.
- Содержание: Результаты тестирования, метрики покрытия, статистика по дефектам, анализ рисков, рекомендации по релизу.
- Зачем нужен: Для подведения итогов тестирования и принятия решения о готовности продукта к релизу.


8 - Тест-стратегия (Test Strategy)

Это высокоуровневый документ, который описывает общие подходы, принципы и виды тестирования, применяемые в проекте. Тест-стратегия может входить в состав тест-плана или быть отдельным документом.
- Содержание: Подход к тестированию, типы и уровни тестирования, используемые инструменты, критерии выхода.
- Зачем нужна: Определяет основные принципы тестирования и помогает согласовать процесс между всеми участниками.


9 - Протоколы тестирования (Test Logs)

Протокол тестирования содержит записи о выполнении тестов, включая результаты каждого теста. Этот документ может быть автоматическим, если используется инструмент тестирования.
- Содержание: Дата и время выполнения тестов, статус каждого теста (пройден/не пройден), ID тест-кейсов, комментарии.
- Зачем нужны: Для документирования хода тестирования и дальнейшего анализа проблем, если тест не прошел.


10 - Сценарии тестирования (Test Scenarios)

Тест-сценарий — это высокоуровневое описание действий, которые должен выполнить пользователь или система. В отличие от тест-кейсов, сценарии не содержат детализированных шагов и охватывают целостные пользовательские действия.
- Содержание: Краткое описание действия, которое должно быть проверено.
- Зачем нужны: Для проверки логики и основных пользовательских потоков без детализации.


11 - План приемочного тестирования (Acceptance Test Plan)

Это документ, который описывает план проведения приемочного тестирования, чтобы проверить, соответствует ли система бизнес-требованиям. Обычно составляется клиентом или представителями бизнеса.
- Содержание: Критерии приемки, сценарии приемочного тестирования, роли и обязанности участников.
- Зачем нужен: Для определения готовности продукта к внедрению или передаче клиенту.


12 - Руководства и инструкции по тестированию (Testing Guidelines and Instructions)

Эти документы содержат инструкции и рекомендации по выполнению тестов, настройке тестового окружения и использованию тестовых инструментов.
- Содержание: Описание методик, используемых инструментов, подходов к тестированию.
- Зачем нужны: Обеспечивают единые стандарты выполнения тестирования и помогают новым членам команды быстро освоиться.



Метрики и показатели тестирования

Метрики — это количественные и качественные показатели, которые помогают оценить эффективность и прогресс тестирования, а также качество продукта. Они могут включать:

- Покрытие тестами (Test Coverage) — процент требований или функциональных модулей, покрытых тестами.

- Процент успешных тестов (Pass Rate) — соотношение пройденных тестов к общему количеству.

- Плотность дефектов (Defect Density) — количество дефектов на единицу объема кода.

- Среднее время исправления дефекта (Defect Fix Time) — среднее время, требуемое на исправление дефектов.



Зачем нужна тестовая документация

1 -Планирование и управление процессом тестирования: позволяет организовать процесс, установить сроки, определить объем работы и распределить задачи между участниками.

2 - Обеспечение прозрачности и понимания: упрощает коммуникацию между разработчиками, тестировщиками и заказчиками, особенно на крупных проектах.

3 - Снижение рисков и улучшение качества: хорошо организованная документация помогает снизить вероятность пропуска ошибок и повысить качество конечного продукта.

4 - Обеспечение воспроизводимости и повторяемости: документация позволяет воспроизводить тесты в будущем, особенно при регрессионном тестировании.

5 - Поддержка обучения и адаптации новых сотрудников: документация помогает новым тестировщикам быстрее войти в проект и освоиться с процессами.


Артефакты тестирования — это основа, обеспечивающая качественное тестирование, прозрачность процесса и предсказуемость результатов.



Практикуемся с написанием тестовой документации

В этом задании вам необходимо:

1 - Написать чек-листы для проверки страницы авторизации (https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/login) в приложении UI Course.

2 - Написать тест-кейсы для проверки страницы регистрации (https://nikita-filonov.github.io/qa-automation-engineer-ui-course/#/auth/registration) в приложении UI Course.

Примечание: Обратите внимание на оформление и структуру, соблюдайте последовательность и ясность шагов. Чек-листы должны быть сжатыми, но содержать все необходимые проверки. Тест-кейсы — детализированными, с описанием ожидаемого результата для каждого шага.



Формат ответа:

Чек-лист для проверки страницы авторизации -
1 - Проверка отображения страницы авторизации.
2 - Проверка наличия поля для ввода электронной почты.
3 - Проверка кнопки "Войти" (Login) и ее состояния при пустых полях.
4 - ...


Тест-кейсы для проверки страницы регистрации

Тест-кейс 1: Проверка регистрации с корректными данными
Предусловие: Открыта страница регистрации.
Шаги:
1 - Ввести корректный email в поле "Email".
2 - Ввести корректный пароль в поле "Password".
3 - Ввести корректный пароль повторно в поле "Confirm Password".
4 - Нажать кнопку "Регистрация" (Register).
Ожидаемый результат: Пользователь успешно зарегистрирован, отображается сообщение о подтверждении регистрации.

Тест-кейс 2: Проверка сообщения об ошибке при несоответствии паролей
Предусловие: Открыта страница регистрации.
Шаги:
1 - Ввести корректный email в поле "Email".
2 - Ввести пароль в поле "Password".
3 - Ввести другой пароль в поле "Confirm Password".
4 - Нажать кнопку "Регистрация" (Register).
Ожидаемый результат: Отображается сообщение об ошибке, сообщающее о несовпадении паролей.



******************************************

2 - 2.5 - Введение в автоматизацию тестирования



О профессии QA Automation Engineer

QA Automation Engineer (инженер по автоматизированному обеспечению качества) — это специалист, занимающийся тестированием программного обеспечения с помощью автоматизированных тестов. В отличие от ручного тестировщика, его основной фокус — разработка и поддержка автоматизированных тестов, которые позволяют проверять стабильность и функциональность системы более эффективно и быстро.



Чем занимается QA Automation Engineer? - В обязанности QA Automation Engineer входят следующие задачи:

1 - Создание автоматизированных тестов: разработка тестовых сценариев для различных аспектов приложения, включая функциональное, регрессионное и интеграционное тестирование.

2 - Настройка тестового окружения и инфраструктуры: подготовка и конфигурирование среды для запуска тестов, чтобы обеспечить воспроизводимость и стабильность тестов в разных условиях.

3 - Поддержка актуальности тестов: регулярное обновление тестов, чтобы они соответствовали текущим требованиям продукта и не содержали устаревших данных, особенно после обновления функциональности.

4 - Анализ результатов тестов: оценка результатов автоматизированных тестов для обнаружения проблем и аномалий. При выявлении ошибок QA Automation Engineer создает баг-репорты, описывая найденные дефекты.

5 - Отчётность по результатам тестирования: настройка и генерация отчетов, которые помогают команде видеть результаты тестирования и анализировать состояние качества продукта. Такие отчеты часто включают метрики, статистику по пройденным и не пройденным тестам, выявленные дефекты и другие данные для оценки стабильности продукта.

6 - Взаимодействие с разработчиками и другими командами: QA Automation Engineer тесно сотрудничает с разработчиками, менеджерами по продукту и другими участниками проекта, чтобы оперативно решать выявленные проблемы и планировать улучшения.



Зачем QA Automation Engineer нужен компании?
QA Automation Engineer приносит компании ценность за счет:

- Повышения скорости тестирования: автоматизация позволяет значительно сократить время, необходимое для проведения тестов, особенно при частом выпуске обновлений.

- Снижения затрат на тестирование: автоматизация тестов позволяет избежать затрат на многократное ручное тестирование, особенно при масштабном проекте.

- Повышения качества продукта: QA Automation Engineer помогает вовремя выявлять дефекты, что снижает риски для компании и улучшает доверие к продукту.

- Поддержания стабильности системы: благодаря автоматизированным тестам можно быстро проверить продукт на соответствие основным требованиям после каждого изменения, что поддерживает стабильность и предотвращает регрессии.

- QA Automation Engineer играет ключевую роль в обеспечении качества продукта и помогает компании выпускать обновления быстрее, минимизируя риски и улучшая общий опыт пользователей.



Принципы автоматизации тестирования


Какие тестовые сценарии подлежат автоматизации?

Необходимо учитывать, что автоматизация подходит не для всех тестов. Попытка автоматизировать каждый сценарий — это плохая практика, которая не только затратно, но и нецелесообразно.



Что не следует автоматизировать:

1 - Очень длинные и сложные сценарии, занимающие несколько минут: Если тестовый сценарий длится более одной-двух минут, автоматизация становится невыгодной. Такие тесты трудно анализировать, они требуют больших временных затрат на запуск и поддержку, что часто дороже, чем ручное тестирование. Ваша задача — уметь выявлять такие сценарии и объяснять команде, почему их не стоит автоматизировать. Члены команды часто просят автоматизировать всё подряд, но здесь важно придерживаться разумного подхода.

2 - Нестабильные сценарии без предсказуемого результата: Если система нестабильна или результат непредсказуем, автоматизация теряет смысл. Например, автоматизация интерфейсов для сложных симуляций или виртуальных сред (как виртуальные лаборатории с операционными системами) будет крайне нестабильной. Отображение операционной системы в браузере в виде "картинки" затрудняет предсказание и автоматизацию взаимодействия.

3 - Сложно воспроизводимые сценарии: Автоматизация тестов для систем, работающих только в определённые временные промежутки, например, биржевых приложений, может быть крайне сложной. Такие тесты требуют наличия условий, доступных только в определенное время суток или в особых обстоятельствах.



Что следует автоматизировать:

1 - Тесты, которые можно быстро выполнить и для которых известен точный ожидаемый результат: Это тесты, которые легко настроить и анализировать, например, смоук-тесты, регрессионные тесты, интеграционные и юнит-тесты.

2 - Стабильные сценарии: Автоматизируйте сценарии, которые дают предсказуемые результаты и не зависят от внешних факторов.

3 - Тесты, которые используются часто и необходимы для проверки ключевой функциональности: Например, критические пользовательские пути, где малейший сбой может нарушить работу всей системы.



Пирамида автоматизации

Помимо выбора сценариев для автоматизации, важно также понимать, сколько и какие типы тестов нужно автоматизировать. Это иллюстрирует пирамида автоматизации — схема, показывающая оптимальное соотношение различных типов тестов.

Картинка с пирамидой - telegram - избранное - 17.01.2026 (14:27)



Рассмотрим уровни пирамиды автоматизации:

1 - UI/E2E тесты: Этот уровень занимает минимальное количество тестов, так как такие тесты сложны в разработке, запуске и поддержке. UI-тесты, по сути, являются E2E-тестами, так как они проверяют функциональность от начала до конца. Они требуют значительных ресурсов и при этом являются самыми медленными и наименее стабильными.

2 - API/Интеграционные тесты: Должны занимать средний уровень в пирамиде. Эти тесты направлены на проверку серверной части приложения и тестируют взаимодействие между системами. Они быстрее, стабильнее и проще в поддержке, чем UI-тесты.

3 - Изоляционные/Юнит/Компонентные тесты: Занимают самую большую часть тестов и обычно пишутся разработчиками. Эти тесты выполняются на уровне отдельных модулей или компонентов, не затрагивая внешние зависимости. Они выполняются очень быстро, стабильны и легко поддерживаются.

Пирамида автоматизации помогает построить эффективную тестовую модель и правильно распределить ресурсы, но важно помнить, что она является общей рекомендацией и не всегда подходит для всех продуктов.



Исключения

Иногда пирамида тестирования может не работать. Например, если ваше приложение состоит в основном из клиентской части и очень небольшой серверной части, процент UI/E2E-тестов может быть выше. В таких случаях рекомендуется адаптировать подход к тестированию с учётом особенностей продукта, а не строго следовать пирамиде. Анализ тестируемого продукта и гибкость в подходе к автоматизации позволят вам эффективно распределить усилия и ресурсы.



******************************************

2 - 2.6 - Основные инструменты автоматизации тестирования


Язык программирования -
Выбор инструментов автоматизации тестирования начинается с выбора языка программирования, на котором будут написаны автотесты. В данном курсе мы будем работать с Python, и все инструменты будут ориентированы на этот язык. Python — один из самых популярных языков для автоматизации тестирования благодаря простоте синтаксиса и обширной экосистеме библиотек.

Основные языки, используемые в автоматизации тестирования:
- Python (https://www.python.org/)
- Java (https://www.java.com/ru/)
- TypeScript/JavaScript (https://www.typescriptlang.org/, https://www.javascript.com/)
- C# (https://learn.microsoft.com/en-us/dotnet/csharp/)
- Golang (https://go.dev/)

Остальные языки применяются намного реже. Лично я считаю Python оптимальным выбором для автоматизации тестирования, так как эта область часто требует написания множества скриптов для проверки функциональности, и в этом Python особенно хорош. Благодаря его выразительному синтаксису и множеству библиотек, разработка и поддержка автотестов на Python становятся более эффективными.


Инструмент для работы с HTTP -
В рамках данного курса мы будем взаимодействовать с API через HTTP-протокол. Поэтому важно выбрать подходящий инструмент для отправки HTTP-запросов. Рассмотрим наиболее популярные библиотеки:
- HTTPX (https://www.python-httpx.org/)
- Requests (https://requests.readthedocs.io/en/latest/)
- (Дополнительно: aiohttp (https://docs.aiohttp.org/en/stable/) - но мы её использовать не будем)


Почему HTTPX?
Мы будем использовать HTTPX в данном курсе по нескольким причинам:

1 - Поддержка асинхронности - 
    - HTTPX позволяет писать как синхронный, так и асинхронный код (async/await).
    - Requests не поддерживает асинхронность и никогда не будет её поддерживать.

Даже если в рамках курса мы будем писать только синхронные API-тесты, возможность работы с асинхронностью даёт большую гибкость. В реальных проектах всё чаще встречаются асинхронные сервисы, и в будущем это знание может пригодиться.

2 - Встроенная аннотация типов -
    - HTTPX имеет хорошую поддержку type hints, что упрощает разработку, повышает читаемость кода и помогает избежать ошибок.
    - Requests до сих пор не имеет встроенных аннотаций типов.

В больших проектах аннотации типов помогают избежать множества ошибок и делают код понятнее. Использование библиотеки с хорошей типизацией позволяет писать более надёжный код, особенно если в тестах активно используются IDE и статический анализатор (например, mypy).

3 - Удобный клиент (Client) -
HTTPX предоставляет объект Client, который поддерживает:
    - Параметр base_url — позволяет задать базовый URL для всех запросов.
    - Пул соединений — улучшает производительность при множественных запросах.
    - В Requests такого удобного клиента нет.

Для API-тестов это особенно полезно: можно заранее задать базовый URL тестируемого сервиса и не дублировать его в каждом запросе.

4 - Поддержка Event Hooks -
    - HTTPX позволяет легко обрабатывать события запроса и ответа с помощью event hooks.
    - Requests не поддерживает аналогичного механизма.

В API-тестах часто возникает необходимость логирования запросов и ответов, а также добавления кастомных обработчиков (например, для автоматического обновления токенов). В HTTPX это можно реализовать нативно и удобно.


Почему не Requests?
Requests остаётся отличной библиотекой, но:
- Requests — устаревшая библиотека без активного развития. HTTPX — более новая и учитывает современные требования к HTTP-клиентам.
- У неё нет встроенной асинхронности.
- Отсутствуют аннотации типов, что усложняет работу в больших проектах.
- Не поддерживает удобные механизмы, такие как base_url и event hooks.

В целом Requests и HTTPX очень похожи, и если вы уже работали с Requests, переход на HTTPX будет простым. Однако HTTPX предлагает больше возможностей и удобств.


Почему не aiohttp?
aiohttp — ещё одна библиотека для работы с HTTP, но:
- Она только асинхронная, что не всегда удобно для автотестов.
- Её основной сценарий — написание серверных приложений и высоконагруженных клиентов.

Поэтому aiohttp не является лучшим выбором для API-тестирования, где важно поддерживать и синхронный, и асинхронный подход.


Итог
Requests и HTTPX взаимозаменяемы, и принципиальной разницы в базовом использовании для API-тестов нет. Однако:
- HTTPX современнее и имеет активную поддержку.
- Гибкость — можно писать как синхронный, так и асинхронный код.
- Лучшая типизация, что помогает писать более чистый и надёжный код.
- Более удобный Client, который упрощает работу с API.
- Поддержка event hooks — это делает HTTPX мощным инструментом для тестирования.

Поэтому в данном курсе мы будем использовать именно HTTPX. Подробное сравнение с Requests будет в уроке "Введение в HTTPX".



Сериализация, десериализация и валидация данных

При работе с API-тестами нам необходим инструмент для работы с данными. Он должен:
- Преобразовывать JSON в объекты и обратно.
- Валидировать входные данные.
- Автоматически генерировать JSON Schema.
- Позволять работать с алиасами, кастомными типами данных и многим другим.

И здесь без альтернатив — мы будем использовать Pydantic (https://docs.pydantic.dev/latest/)


Почему именно Pydantic?
Pydantic — это самая мощная, удобная и популярная библиотека для работы с данными в Python. Её основные преимущества:

1 - Автоматическая валидация данных
- Pydantic проверяет соответствие типов данных при создании объектов.
- Возможность задавать кастомные валидации с помощью аннотаций и декораторов.

2 - Работа с JSON и сериализация
- Можно легко преобразовать объект в dict или JSON.
- Поддержка алиасов для удобства работы с API.

3 - Генерация JSON Schema
- Pydantic автоматически создаёт JSON Schema для моделей, что упрощает документацию API.

4 - Простота и читаемость кода
- Позволяет работать с данными как с объектами (model.attr), а не просто словарями.



Какие есть альтернативы?

Если кто-то не использует Pydantic, обычно применяются:

1 - Dataclasses (https://docs.python.org/3/library/dataclasses.html)
- По сути, "Pydantic на минималках".
- Позволяют представлять данные в виде объектов (dataclass), но:
    - Нет встроенной валидации типов.
    - Нет автоматической генерации JSON Schema.
    - Нельзя создавать объекты из JSON-строк.
    - Нет поддержки алиасов и сериализации.

2 - TypedDict и NamedTuple (https://peps.python.org/pep-0589/, https://docs.python.org/3/library/collections.html#collections.namedtuple)
- TypedDict — это словари с аннотацией типов. Они полезны, но не дают удобных механизмов валидации и сериализации.
- NamedTuple — это неизменяемые структуры данных, схожие с tuple, но с атрибутами. Они не предназначены для полноценной работы с API-данными.

3 - Игнорирование аннотаций типов
- Некоторые пишут тесты без аннотации типов, используя обычные dict. Это ведёт к большему количеству ошибок и усложняет поддержку кода.


Итог -
Pydantic — лучшее решение для работы с данными. Он заменяет dataclass, TypedDict, NamedTuple и любые кастомные решения. Тем не менее, многие QA Automation Engineers почему-то продолжают изобретать костыли вместо того, чтобы использовать Pydantic.

Мы будем работать с Pydantic в рамках курса, так как это самая мощная, удобная и широко используемая библиотека для валидации и сериализации данных.



Инструмент для запуска автотестов

После выбора инструмента для работы с браузером нам также нужен инструмент, который позволит эффективно писать, организовывать и запускать автотесты. Такой инструмент не обязателен, но он делает процесс написания и запуска автотестов значительно проще и удобнее.

В нашем случае основным инструментом будет pytest (https://docs.pytest.org/en/stable/) — самый популярный фреймворк для тестирования на языке Python. Pytest предоставляет широкие возможности для запуска тестов, фильтрации, параметризации, а также интеграции с другими библиотеками. Если вы ещё не используете pytest, самое время познакомиться с ним, так как это действительно мощный и гибкий инструмент для автоматизации тестирования.


Преимущества pytest - 

1 - Запуск и фильтрация тестов: pytest позволяет удобно запускать тесты по имени, тегу или другим критериям, что делает процесс тестирования гибким.

2 - Параметризация тестов: возможность запускать один и тот же тест с различными входными данными, что упрощает создание вариативных тестов для одной и той же функциональности.

3 - Пропуск и повторный запуск тестов: pytest позволяет временно пропускать тесты, например, если на них заведены баги, а также перезапускать тесты, чтобы снизить вероятность ложных падений из-за нестабильности среды.

4 - Поддержка плагинов и расширяемость: у pytest есть огромная экосистема плагинов, таких как pytest-xdist для параллельного запуска тестов и pytest-html для генерации отчетов. Это делает его гибким инструментом, способным покрыть практически любые потребности в тестировании.



Другие инструменты для запуска автотестов

Существует также ряд альтернатив pytest, таких как:
- Behave (https://behave.readthedocs.io/en/latest/)
- Robot Framework (https://robotframework.org/)
- Unittest, встроенный в Python (https://docs.python.org/3/library/unittest.html)

Behave и Robot Framework используют язык Gherkin, позволяя описывать тестовые сценарии в человекочитаемом формате. Пример сценария на Gherkin:
--
Scenario: Breaker guesses a word
  Given the Maker has chosen a word
  When the Breaker makes a guess
  Then the Maker is asked to score
----

На первый взгляд это кажется удобным, но на практике Gherkin может усложнять разработку автотестов, делая их поддержание и расширение более трудоемкими. Если хотите получить глубокий и прикладной опыт в автоматизации, я рекомендую избегать использования Behave и Robot Framework, так как они могут ограничивать гибкость и усложнять написание тестов.

Unittest — это стандартный модуль для тестирования в Python. Он прост, но достаточно ограничен по возможностям, что делает его менее удобным для сложных тестовых сценариев. Unittest лучше всего подходит для простых юнит-тестов, но даже в этом случае многие специалисты предпочитают писать их на pytest, благодаря его гибкости и широким возможностям.

Вывод -
Pytest — это незаменимый инструмент для написания и запуска автотестов на Python. Он предоставляет гибкие возможности для работы с тестами и является стандартом в индустрии автоматизации на Python.



Инструмент для формирования отчетов по тестированию

После выбора инструмента для запуска автотестов нам нужен инструмент для анализа результатов тестирования. В данном случае отличным выбором является Allure (https://allurereport.org/) — популярный и мощный инструмент для создания отчетов, который наглядно отображает результаты тестов, улучшая процесс анализа.

Преимущества Allure -

1 - Интерактивный интерфейс: Allure предоставляет удобный и интуитивно понятный интерфейс, где можно видеть состояние тестов, время их выполнения, шаги, логирование и даже вложенные скриншоты и видео.

2 - Поддержка шагов и тегов: Allure позволяет легко разбивать тесты на шаги, что улучшает читаемость и понимание логики тестов, а также предоставляет возможность фильтрации по тегам.

3 - Интеграция с инструментами CI/CD: Allure легко интегрируется с популярными системами CI/CD, такими как Jenkins, GitLab, TeamCity и другие, что упрощает автоматическое создание отчетов после каждого запуска тестов.

4 - Гибкость и расширяемость: Allure поддерживает расширения и плагины, что позволяет адаптировать отчеты под нужды команды и включать в них дополнительные данные (например, окружение, версии зависимостей).


Сравнение с другими инструментами

Allure стал стандартом для отчетов в автоматизации тестирования и практически не имеет достойных альтернатив. Если сравнить Allure с другими решениями, то они зачастую проигрывают по функциональности и удобству. Можно сказать, что Allure в мире отчетов для автотестов — это как Telegram среди мессенджеров: есть аналоги, но все они уступают по удобству и возможностям.

Заключение

Allure — это незаменимый инструмент для создания отчетов по автотестам, который улучшает видимость результатов, облегчает анализ ошибок и помогает командам эффективно отслеживать статус тестов.



Система контроля версий

После написания автотестов и формирования отчетов необходимо сохранить код и организовать совместную работу над проектом, особенно если в нем участвует несколько автоматизаторов. Здесь на помощь приходит система контроля версий, позволяющая отслеживать изменения в коде, управлять ветками, разрешать конфликты и организовывать работу над проектом в команде.

Система контроля версий (или VCS — Version Control System) позволяет хранить код проекта, управлять изменениями, вести историю правок и облегчать командное взаимодействие. Основные и самые популярные системы контроля версий включают:

1 - GitHub (https://github.com/)
Самая популярная VCS, особенно среди open-source проектов и разработчиков по всему миру. GitHub предоставляет удобный интерфейс для совместной работы, обсуждения кода, создания пул-реквестов и управления версиями. Благодаря доступности и поддержке множества интеграций, GitHub стал стандартом в индустрии для многих команд и компаний.

2 - GitLab (https://about.gitlab.com/)
Очень популярен в корпоративной среде, так как имеет встроенные инструменты CI/CD, удобные для внутренних корпоративных проектов. GitLab можно использовать как облачное решение или установить на собственные серверы, что повышает его привлекательность для компаний с высокими требованиями безопасности и приватности данных.

3 - Bitbucket (https://bitbucket.org/product/)
Еще одно корпоративное решение, но менее распространенное, чем GitLab. Bitbucket поддерживает интеграцию с другими продуктами Atlassian, такими как Jira и Confluence, что делает его полезным для команд, активно работающих с экосистемой Atlassian.

4 - Gerrit (https://www.gerritcodereview.com/)
Старый инструмент, который в основном используется в устаревших проектах или проектах с высокой степенью контроля кода. Gerrit может быть полезен для строгого контроля над ревью, но на сегодняшний день он все реже используется в новых проектах.


Заключение

Наиболее современным и гибким решением является Git, с его популярными платформами — GitHub, GitLab и Bitbucket. Эти платформы позволяют эффективно управлять кодом, организовывать совместную работу, легко интегрироваться с CI/CD и другими инструментами, что делает их незаменимыми в процессе разработки автотестов.



CI/CD система

CI/CD — это Continuous Integration (непрерывная интеграция) и Continuous Deployment/Delivery (непрерывное развертывание/доставка). Эти процессы помогают автоматизировать сборку, тестирование и развертывание кода, делая его обновление более быстрым и надежным.

- Continuous Integration (CI) — практика частого объединения кода, написанного разработчиками, в общую кодовую базу. CI-системы автоматически проверяют каждый коммит, выполняют сборку проекта и запускают тесты, что помогает оперативно находить и устранять ошибки.

- Continuous Delivery (CD) — автоматизация последующих этапов, которая позволяет подготовить изменения в коде для развертывания на продакшн или другие среды. Этот процесс включает упаковку, создание релизов и тестирование на этапах ближе к реальному развертыванию.

- Continuous Deployment (CD) — следующая ступень автоматизации, при которой изменения, прошедшие все тесты и проверки, автоматически развертываются на продакшн-среде.

Цель CI/CD — упростить и ускорить выпуск обновлений, снижая вероятность ошибок и увеличивая частоту релизов.



Рассмотрим несколько популярных CI/CD систем, используемых в индустрии:

1 - GitLab CI/CD (https://about.gitlab.com/)
GitLab имеет встроенную CI/CD систему, что делает его отличным выбором для компаний, которые уже используют GitLab как систему контроля версий. GitLab CI/CD позволяет автоматизировать процесс сборки, тестирования и развертывания прямо на платформе. Интеграция с GitLab, гибкость в настройке пайплайнов, управление окружениями и поддержка Docker делают его особенно популярным в корпоративной среде.

2 - Jenkins (https://www.jenkins.io/)
Один из самых известных и универсальных инструментов для CI/CD, с поддержкой множества плагинов и интеграций. Jenkins — это open-source решение, которое можно гибко настроить под любые требования. Подходит для организаций, желающих полной кастомизации, но требует времени на установку и настройку.

3 - CircleCI (https://circleci.com/)
Облачная CI/CD платформа, которая отлично подходит для автоматизации сборок и тестов в распределённых командах. CircleCI легко интегрируется с GitHub и GitLab, что делает его популярным среди команд, которые хотят быстро развернуть CI/CD процессы с минимальными настройками.

4 - GitHub Actions (https://github.com/features/actions)
Инструмент CI/CD, встроенный в GitHub, который позволяет создавать автоматизированные пайплайны для проверки, сборки и развертывания кода. GitHub Actions предоставляет отличные возможности для интеграции, а также мощный и гибкий синтаксис для создания воркфлоу с событиями, такими как коммиты, пул-реквесты и релизы.

5 - TeamCity (https://www.jetbrains.com/teamcity/)
Коммерческая CI/CD система от компании JetBrains, известной своими инструментами для разработки. TeamCity поддерживает множество языков и платформ, легко интегрируется с другими продуктами JetBrains и предоставляет мощные возможности для настройки и анализа пайплайнов.


Выбор CI/CD системы зависит от требований проекта, инфраструктуры и используемых систем контроля версий. GitLab CI/CD и GitHub Actions популярны благодаря своей интеграции с платформами GitLab и GitHub, CircleCI и Jenkins предлагают гибкость и мощные возможности для кастомизации, а TeamCity подойдет для компаний, которые используют JetBrains и готовы инвестировать в коммерческое решение.



- А когда requests / aiohttp используется с BeautifulSoup и DOM - это какое взаимодействие считается, через UI?
- Не совсем, использование requests или aiohttp с BeautifulSoup не считается взаимодействием через UI. Это работа напрямую с HTML-документом, как с текстом — мы не запускаем браузер, не эмулируем действия пользователя, не взаимодействуем с JavaScript или DOM в живом виде.
- requests / aiohttp скачивают HTML как обычный текст.
- BeautifulSoup просто парсит этот текст и даёт нам удобный доступ к тегам.
- Это статический анализ HTML, а не взаимодействие с реальным DOM в браузере. 
Я бы отнес это к обычному парсингу документов 



******************************************

3 - 3.1 - Установка и настройка окружения Python

Установка Python
Ссылки:
- Список доступных версий Python (https://www.python.org/downloads/)
- Версия Python 3.12.6 (https://www.python.org/downloads/release/python-3126/) – на момент написания курса это последняя стабильная версия. Рекомендуется скачивать именно ее



Установка Python на Windows

1 - Скачивание установщика:
- Перейдите на официальный сайт Python: https://www.python.org/downloads/.
- На главной странице отобразится кнопка Download Python X.X.X (где X.X.X – последняя версия Python). Нажмите на нее, чтобы загрузить установочный файл.

2 - Запуск установщика:
- Откройте загруженный файл python-X.X.X.exe.
- В появившемся окне обязательно установите флажок "Add Python to PATH" внизу окна, чтобы Python автоматически добавился в переменные среды (это упростит запуск Python в командной строке).
- Нажмите Install Now для быстрой установки или Customize installation для выбора дополнительных параметров.

3 - Проверка установки:
- После завершения установки откройте командную строку: нажмите Win + R, введите cmd, и нажмите Enter.
- Введите команду:
--
python --version
----
- Если вы увидите версию Python (например, Python 3.X.X), установка прошла успешно.



Установка Python на Linux

На большинстве дистрибутивов Linux Python уже предустановлен, но возможно, потребуется его обновление или установка новой версии. Инструкции могут отличаться в зависимости от дистрибутива.


Ubuntu / Debian -

1 - Обновите список пакетов:
--
sudo apt update
----

2 - Установите Python 3 и pip (менеджер пакетов Python):
--
sudo apt install python3 python3-pip -y
----

3 - Проверка установки:
- Введите команду:
--
python3 --version
----
- Если вы увидите версию Python, установка выполнена успешно.


CentOS / Fedora / RHEL -

1 - Установка Python 3 (на примере CentOS 8):
- Выполните следующую команду:
--
sudo dnf install python3
----

2 - Проверка установки:
- Введите команду:
--
python3 --version
----


Установка Python из исходного кода (если нужна последняя версия) -

1 - Установите зависимости для сборки:
--
sudo apt update
sudo apt install -y build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev curl
----

2 - Скачайте и установите Python:
--
curl -O https://www.python.org/ftp/python/X.X.X/Python-X.X.X.tgz
tar -xf Python-X.X.X.tgz
cd Python-X.X.X
./configure --enable-optimizations
make
sudo make altinstall
----
Замените X.X.X на номер версии, которую хотите установить.


Установка Python на macOS -

На macOS обычно установлена более старая версия Python. Для установки последней версии рекомендуется использовать Homebrew – пакетный менеджер для macOS.

1 - Установите Homebrew (если еще не установлен):
- Откройте Terminal и введите следующую команду:
--
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
----

2 - Установите Python с помощью Homebrew:
--
brew install python
----

3 - Проверка установки:
- Введите команду:
--
python3 --version
----
Должна отобразиться версия Python.

4 - Обновление pip:
- Убедитесь, что менеджер пакетов pip обновлен:
--
python3 -m pip install --upgrade pip
----


Проверка переменных окружения (все системы)

Для запуска Python в терминале или командной строке необходимо убедиться, что путь до Python добавлен в переменные среды (PATH):
- Windows: Если выбрано Add Python to PATH при установке, путь будет добавлен автоматически.
- Linux и macOS: Обычно путь добавляется автоматически, но можно проверить его в файле .bashrc, .bash_profile, или .zshrc:
--
export PATH="/usr/local/bin/python3:$PATH"
----



******************************************

3 - 3.2 - Установка и настройка PyCharm

PyCharm: Что это и зачем он нужен?

PyCharm — это мощная интегрированная среда разработки (IDE) для Python, разработанная JetBrains. Она предлагает множество инструментов для написания, тестирования и отладки кода, что делает его особенно популярным среди разработчиков на Python. PyCharm поддерживает автозавершение кода, отладку, контроль версий и интеграцию с популярными инструментами, такими как Docker и Kubernetes.

Альтернативы: Среди популярных альтернатив PyCharm можно выделить Visual Studio Code, Atom, Sublime Text и Spyder. Они предоставляют похожие возможности, но могут различаться по интерфейсу, поддержке плагинов и производительности.

Рейтинг IDE для питонистов в плане возможностей:
1) PyCharm Professional
2) Visual Studio Code
3) PyСharm Community

Чем отличаются Professional от Community версии? В Community урезаны возможности работы с Django и FastAPI, нет встроенных СУБД, неудобно работать с Markdown, HTML, CSS, не знаю, можно ли работать с JS, нельзя подключить бесплатного Copilot'а.

В Professional версии все это можно и удобно, в т.ч. любые СУБД, все существующие. 1 программа вообще для всего. И кроме Copilot'а, все из коробки.

Про VSC: можно все то же самое, что и в Professional версии PyCharm, но все нужно настраивать вручную, не очень быстро.

Для автотестов достаточно PyCharm Community.



Инструкции по установке PyCharm

Ссылки:
Установка PyCharm для Windows (https://www.jetbrains.com/pycharm/download/?section=windows)
Установка PyCharm для macOS (https://www.jetbrains.com/pycharm/download/?section=mac)
Установка PyCharm для Linux (https://www.jetbrains.com/pycharm/download/?section=linux)


Существует две версии PyCharm:

- PyCharm Community Edition (бесплатная): предназначена для обучения и разработки с базовым функционалом.
- PyCharm Professional Edition (платная): поддерживает расширенные возможности для профессионалов, такие как работа с веб-фреймворками (Django, Flask), поддержка работы с базами данных, поддержка JavaScript и других языков, а также интеграция с Docker и другими инструментами.



Установка PyCharm Community Edition


Windows -

1 - Перейдите на сайт JetBrains (https://www.jetbrains.com/pycharm/download/)
2 - Выберите версию PyCharm Community Edition и загрузите установочный файл для Windows.
3 - Запустите установочный файл.
4 - Следуйте инструкциям установщика, при этом:
    - Укажите путь для установки.
    - Выберите дополнительные опции, такие как создание ярлыка на рабочем столе и добавление PyCharm в PATH.
5 - По завершении установки запустите PyCharm и завершите настройку, следуя подсказкам на экране.


Linux -

1 - Загрузите архив для Linux с официального сайта (https://www.jetbrains.com/pycharm/download/)
2 - Распакуйте архив:
--
tar -xzf pycharm-community-*.tar.gz -C /opt/
----
3 - Перейдите в директорию, где установлен PyCharm:
--
cd /opt/pycharm-community-*/
----
4 - Запустите PyCharm:
--
./bin/pycharm.sh
----
5 - Вы можете создать ярлык или добавить путь к запускаемому файлу, чтобы запускать PyCharm из меню приложений.


macOS -

1 - Скачайте установочный файл с сайта JetBrains (выберите версию PyCharm Community Edition) (https://www.jetbrains.com/pycharm/download/)
2 - Откройте загруженный .dmg файл.
3 - Перетащите значок PyCharm в папку Applications.
4 - Откройте PyCharm через Finder или из Launchpad.



Создание проекта PyCharm

Чтобы создать первый проект в PyCharm, выполните следующие шаги:

1 - Откройте PyCharm: После запуска PyCharm вы окажетесь на начальном экране. Здесь можно создать новый проект или открыть существующий.

2 - Создание нового проекта:
- Нажмите кнопку "New Project".
- В появившемся окне настройте параметры проекта:
    - Location: выберите папку для проекта или оставьте путь по умолчанию. Название проекта должно быть autotests-api.
    - Python Interpreter: укажите интерпретатор Python, который будет использоваться в проекте. Можно выбрать существующий интерпретатор или установить новый, если он не настроен.

3 - Конфигурация интерпретатора:
- Если у вас ещё нет интерпретатора Python, нажмите "Add Interpreter" и выберите:
    - Virtual Environment: PyCharm создаст виртуальное окружение в папке проекта (рекомендуется для изоляции зависимостей).
    - System Interpreter: если у вас установлен Python на системе, выберите его.
    - Conda Environment: если используете Anaconda, укажите conda-окружение.

4 - Создание проекта:
- Нажмите "Create". PyCharm создаст проект и автоматически запустит его в основном окне.

5 - Первый файл:
- В панели проекта (справа) нажмите правой кнопкой на корневую папку проекта, выберите New > Python File, назовите файл, например main.py, и нажмите Enter.
- Откройте файл и напишите любой код, например:
--
print("Hello, PyCharm!")
----

6 - Запуск проекта:
- Чтобы запустить скрипт, правой кнопкой мыши кликните по файлу и выберите Run 'main'.
- Результаты выполнения появятся внизу в панели консоли.



******************************************

4 - 4.1 - Начало работы с Git

Знакомство с Git
Ссылки:
- Официальный сайт Git (https://git-scm.com/)
- Игра Learn Git Branching для изучения Git (https://learngitbranching.js.org/?locale=ru_RU)
- Документация на случай, если что-то пошло не так (https://ohshitgit.com/ru + https://dangitgit.com/ru)

Я настоятельно рекомендую вам пройти интерактивную игру Learn Git Branching для изучения принципов работы с Git. Перейдите по ссылке и пройдите игру полностью, вдумчиво читайте теорию и подсказки. Без завершения этого обучения я не рекомендую переходить к следующим шагам -
 
прохождение игры в моём канале в telegram - my_git 

Git — это распределенная система контроля версий, которая позволяет разработчикам отслеживать изменения в коде, работать над проектами совместно и управлять различными версиями файлов. Git был создан Линусом Торвальдсом в 2005 году и с тех пор стал одним из самых популярных инструментов для управления исходным кодом.



Основные характеристики Git -

1 - Контроль версий: Git хранит историю изменений, что позволяет разработчикам возвращаться к предыдущим версиям кода, если это необходимо. Каждое изменение фиксируется и сопровождается сообщением, описывающим суть изменений.

2 - Распределенность: В отличие от централизованных систем, таких как SVN, в Git каждый разработчик имеет полную копию репозитория на своем компьютере. Это позволяет работать без постоянного подключения к сети и ускоряет процесс работы.

3 - Работа с ветками: Git позволяет создавать ветки (branches) для разработки новых функций или исправления ошибок, не затрагивая основную (master или main) ветку проекта. Это облегчает управление разными направлениями разработки и упрощает слияние изменений.

4 - Слияние (merge): Git предоставляет мощные инструменты для слияния изменений из разных веток. Это позволяет командам эффективно работать над одной и той же кодовой базой, избегая конфликтов.

5 - Поддержка коллаборации: Git позволяет множеству разработчиков одновременно работать над проектом. Благодаря системе контроля версий, каждый может вносить изменения и интегрировать их в общий проект.



Зачем нужен Git? -

1 - Отслеживание изменений: Git позволяет легко отслеживать и документировать изменения в коде. Это полезно для анализа, почему были внесены те или иные изменения.

2 - Управление проектами: С помощью Git можно управлять большими проектами, организовывая код в ветках и фиксируя важные версии (релизы).

3 - Обратимость изменений: Если что-то пошло не так, Git позволяет быстро вернуть код к предыдущему состоянию.

4 - Совместная работа: Git обеспечивает эффективное сотрудничество между разработчиками, позволяя работать над одной кодовой базой без конфликтов.

5 - Интеграция с CI/CD: Git интегрируется с различными системами непрерывной интеграции и доставки (CI/CD), что позволяет автоматизировать тестирование и развертывание приложений.



Что такое ветка в Git? -

Ветка (branch) в Git — это отдельная "линия" разработки в проекте, которая позволяет вносить изменения в код без воздействия на основную версию проекта. Ветки дают возможность работать над разными задачами (например, новыми функциями, исправлением ошибок или экспериментами) независимо друг от друга. При этом изменения из одной ветки можно сливать с другими ветками, когда работа будет завершена.



Принципы работы с ветками -

1 - Изоляция изменений: Ветки позволяют изолировать изменения. Например, основная ветка (master или main) может оставаться стабильной, в то время как разработка новых функций или тестирование изменений выполняется в отдельной ветке.

2 - Совместная работа: Каждый разработчик может работать в своей ветке и затем сливать свои изменения с другими, избегая конфликтов в коде. Это удобно для командной работы, так как изменения не мешают работе других участников.

3 - Упрощение версионного контроля: Ветки позволяют легко вернуться к предыдущим версиям проекта, тестировать изменения и откатывать их при необходимости.



Зачем нужны ветки? -

1 - Изоляция работы: Вы можете работать над несколькими задачами одновременно, не мешая друг другу.

2 - Безопасное тестирование: Ветки позволяют тестировать экспериментальные функции или изменения, не затрагивая основную версию кода.

3 - Эффективное управление проектом: Ветки позволяют быстро переключаться между задачами и легко интегрировать готовые изменения в основной проект.



Что такое ветка master в Git? -

В Git основная ветка, которая обычно называется master (в некоторых проектах она переименована в main), представляет собой "главную" или "основную" версию вашего проекта. Эта ветка используется для хранения стабильной версии кода, которая готова к развертыванию или публикации.



Основные характеристики ветки master:

1 - Стабильная версия: Ветка master должна содержать код, который проходит все тесты и работает без ошибок. Это позволяет командам легко развертывать именно эту версию кода.

2 - Отправная точка: Ветка master служит отправной точкой для создания других веток. Разработчики могут создавать новые ветки от master, чтобы работать над новыми функциями или исправлениями ошибок.

3 - Слияние изменений: После завершения работы над функцией или исправления ошибки, изменения из соответствующей ветки обычно сливаются обратно в master, чтобы обновить основную версию кода.



Что такое коммит? -

Коммит в Git — это "снимок" текущего состояния файлов в проекте. Коммиты позволяют разработчикам фиксировать изменения в коде, создавая своего рода "контрольные точки". Это важный механизм, позволяющий отслеживать, какие изменения были внесены и почему. Каждый коммит сопровождается сообщением, описывающим суть изменений, что делает историю проекта понятной и прозрачной.



Основные особенности коммита -

1 - История изменений: Коммиты образуют цепочку изменений в проекте, где каждый новый коммит добавляется поверх предыдущих. Это позволяет легко отслеживать, что изменилось с течением времени.

2 - Уникальный идентификатор: Каждый коммит имеет уникальный идентификатор (хеш) — длинное строковое значение, например a1b2c3d, которое Git использует для точной идентификации изменений.

3 - Сообщение коммита: Каждое изменение сопровождается сообщением, которое поясняет, что было изменено и зачем. Хорошая практика — писать четкие и содержательные сообщения коммитов, чтобы другие разработчики могли понять суть изменений.

4 - Независимость от других изменений: Каждый коммит независим, поэтому вы можете вернуться к конкретному коммиту в любой момент и восстановить состояние проекта на тот момент.



Схема работы с ветками -

Вот простая схема, показывающая, как работают ветки в Git, включая ветку master:
--
          A---B---C  (master)
         /
        D---E---F  (new-feature)
----
- Ветка master содержит коммиты A, B и C.
- Ветка new-feature была создана от коммита D и содержит коммиты D, E и F.
- После слияния ветка master будет иметь все коммиты из new-feature



Установка Git


Установка Git на Windows -

1 - Скачайте установочный файл:
- Перейдите на официальный сайт Git для Windows (https://git-scm.com/download/win) и загрузите последнюю версию.

2 - Запустите установку:
- Откройте загруженный установочный файл и следуйте инструкциям на экране.
- В процессе установки оставьте настройки по умолчанию. Они подходят для большинства случаев.

3 - Настройка среды PATH:
- При установке вы увидите несколько вариантов настройки PATH. Рекомендуется выбрать "Git from the command line and also from 3rd-party software", чтобы Git был доступен как в командной строке Windows, так и в других инструментах.

4 - Выберите текстовый редактор:
- Git предложит выбрать текстовый редактор по умолчанию для редактирования сообщений коммитов. По умолчанию Git предлагает Vim, но вы можете выбрать любой удобный редактор, например VS Code или Notepad++.

5 - Проверьте установку:
- Откройте командную строку (нажмите Win + R, введите cmd, нажмите Enter).
- Введите команду:
--
git --version
----
- Если всё установлено правильно, вы увидите версию Git.


Установка Git на Linux

Git обычно доступен в репозиториях Linux, поэтому установить его можно через менеджер пакетов.

1 - Установите Git:
- Для Ubuntu/Debian:
--
sudo apt update
sudo apt install git
----

- Для CentOS/Fedora:
--
sudo dnf install git
----

Для Arch Linux:
--
sudo pacman -S git
----

2 - Проверьте установку:
- Введите команду:
--
git --version
----
- Убедитесь, что Git установлен, и отобразилась его версия.


Установка Git на macOS

На macOS можно установить Git несколькими способами:

1 - Через Xcode Command Line Tools (рекомендуется):
- Откройте терминал и выполните команду:
--
xcode-select --install
----
Появится запрос на установку инструментария командной строки Xcode. Подтвердите его и дождитесь завершения установки.

2 - Через Homebrew:
- Если у вас установлен Homebrew, установите Git командой:
--
brew install git
----

3 - Проверка установки:
- В терминале введите:
--
git --version
----
- Должна отобразиться версия Git.



Основные команды Git


Начальные настройки

Перед началом работы с Git важно выполнить начальные настройки, чтобы Git мог идентифицировать пользователя.

# Установка имени пользователя
git config --global user.name "Ваше Имя"

# Установка email
git config --global user.email "ваш.email@example.com"

# Проверка текущих настроек
git config --list

Сейчас данные команды выполнять не нужно, с ними необходимо просто ознакомиться и знать об их существовании


1 - Инициализация нового репозитория
--
git init
----
Команда инициализирует новый локальный репозиторий в текущей папке, добавляя скрытую папку .git, которая будет хранить все изменения и коммиты проекта.


2 - Клонирование существующего репозитория
--
git clone <URL-репозитория>
----
Команда клонирует существующий репозиторий с сервера или другой машины на локальный компьютер. Она копирует все файлы и историю изменений.


3 - Добавление файлов в индекс
--
git add <имя_файла>
----
Эта команда добавляет указанный файл в индекс (или staging area) — временное хранилище перед коммитом.
--
git add .
----
С добавлением . все файлы, изменённые или новые, будут добавлены в индекс.


4 - Создание коммита
--
git commit -m "Сообщение коммита"
----
Коммит фиксирует изменения, которые были добавлены в индекс, в историю проекта. Сообщение коммита должно быть кратким и описывать суть изменений.


5 - Просмотр состояния репозитория
--
git status
----
Эта команда отображает текущие изменения, которые ещё не закоммичены, а также информацию о том, какие файлы находятся в индексе или были изменены.


6 - Просмотр истории коммитов
--
git log
----
git log выводит список коммитов в репозитории с указанием авторов, дат и сообщений. Для более краткого вывода можно использовать:
--
git log --oneline
----


7 - Сравнение изменений
--
git diff
----
Команда git diff показывает различия между текущей версией файлов и последним коммитом. Полезно для анализа изменений перед коммитом.


8 - Отмена изменений
--
git checkout -- <имя_файла>
----
Эта команда отменяет изменения в файле, возвращая его к состоянию последнего коммита.


9 - Работа с удалённым репозиторием
--
git remote add origin <URL-репозитория>
----
Добавляет ссылку на удалённый репозиторий с именем origin.

--
git push origin <ветка>
----
Отправляет все коммиты из указанной ветки (например, main) в удалённый репозиторий.

--
git pull origin <ветка>
----
Загружает изменения из указанной ветки удалённого репозитория и объединяет их с текущей веткой.


10 - Создание и переключение веток
--
git branch <имя_ветки>
----
Создаёт новую ветку.

--
git checkout <имя_ветки>
----
Переключает вас на другую ветку.

--
git checkout -b <имя_ветки>
----
Команда, объединяющая создание и переключение на новую ветку.


11 - Объединение веток
--
git merge <имя_ветки>
----
Объединяет изменения из указанной ветки в текущую ветку. Используется для слияния результатов работы разных разработчиков или задач.
пример - влить в текущую ветку vetka, на которой сейчас находимся, ветку main с удаленного репозитория - 
--
git merge origin main
----

12 - Удаление веток
--
git branch -d <имя_ветки>
----
Удаляет локальную ветку. Будьте осторожны: перед удалением убедитесь, что вам не нужны данные из этой ветки.


Мы рассмотрели основные команды Git, которые нужны для управления версиями и работы с репозиториями. Для успешного использования Git в командной работе важно регулярно практиковаться, а также помнить о хорошем описании коммитов и соблюдении порядка работы с ветками.



******************************************

4 - 4.2 - Публикация проекта на GitHub

Ссылки:
- Официальный сайт GitHub (https://github.com/)
- Пример репозитория с кодом (https://github.com/Nikita-Filonov/sample_api_testing)

В этом уроке мы познакомимся с платформой GitHub и научимся публиковать проекты на ней. Мы создадим репозиторий для нашего проекта autotests-api и загрузим его на GitHub, чтобы иметь централизованное хранилище кода и вести отслеживание всех изменений

Основные аспекты и функции GitHub:

1 - Хостинг репозиториев: GitHub хранит исходный код, историю изменений и обеспечивает удобный доступ к ним для команды или широкого круга пользователей. Он поддерживает как публичные (доступные всем), так и частные репозитории.

2 - Контроль версий с помощью Git: GitHub позволяет следить за изменениями кода, видеть его историю, восстанавливать прошлые версии и слияния (merge) веток. Это облегчает ведение проектов, позволяя организовать работу в команде без конфликта версий.

3 - Совместная работа:
    - Pull Requests (PR): механизм, который позволяет предложить изменения в коде, обсудить их и объединить с основным кодом при одобрении.
    - Issues: система для отслеживания задач, ошибок и улучшений, которые нужны проекту. Это удобно для планирования и организации.
    - Code Review: участники проекта могут просматривать и комментировать код до его объединения, что способствует поддержанию высокого качества.

4 - GitHub Actions: встроенная система CI/CD, с помощью которой можно автоматизировать тестирование, сборку и развертывание приложений.

5 - GitHub Pages: функция для создания и хостинга статических веб-страниц прямо из репозиториев, что позволяет быстро делиться документацией, сайтами проектов и другими материалами.

6 - Социальная составляющая: GitHub обладает элементами социальной сети для разработчиков. На платформе можно подписываться на проекты, ставить звезды (Stars) понравившимся репозиториям, создавать форки (Forks) чужих проектов и предлагать свои улучшения.

7 - Безопасность и контроль доступа: GitHub позволяет настраивать права доступа для участников проектов, а также включает автоматическое сканирование кода для поиска уязвимостей.

GitHub — это популярная веб-платформа для управления версиями кода и совместной разработки, построенная на основе системы контроля версий Git. Она предоставляет хостинг для репозиториев Git и множество инструментов для управления проектами, что делает её популярной среди разработчиков и команд.



Создаем репозиторий на GitHub

В этом уроке мы создадим репозиторий для проекта autotests-api на GitHub, чтобы впоследствии вести контроль версий и отслеживать изменения в проекте.


1 - Регистрация на GitHub
Первое, что необходимо сделать, — зарегистрироваться на GitHub. Перейдите по ссылке https://github.com/signup и следуйте инструкции для регистрации. При этом обязательно запомните указанные при регистрации электронный адрес, пароль и имя пользователя.

Подтверждение регистрации: для завершения регистрации потребуется решить простую задачу, чтобы подтвердить, что вы не робот.

Подтверждение электронной почты: на указанный электронный адрес придет письмо с кодом. Введите этот код в поле подтверждения на сайте.

Выбор плана: после подтверждения вам нужно будет авторизоваться, используя имя пользователя и пароль. Когда будет предложено выбрать план, выберите Free.

После выбора плана вы окажетесь на главной странице GitHub. Регистрация завершена


2 - Создание репозитория
Переход к созданию репозитория: на главной странице нажмите кнопку Create repository

Настройка репозитория:
- В поле Repository name введите название autotests-api.
- Выберите видимость репозитория: Public.
- Остальные настройки оставьте без изменений

Завершение создания репозитория: нажмите кнопку Create repository. Репозиторий будет создан, и вы попадете на его страницу, которая пока еще пустая

На странице нового репозитория найдите блок …or push an existing repository from the command line. Эти команды помогут синхронизировать локальный проект autotests-api с созданным удаленным репозиторием.

Регистрация на GitHub и создание репозитория завершены




Синхронизируем проект autotests-api с репозиторием GitHub

Ссылки:
- Настройки персональных токенов (https://github.com/settings/tokens)
- Инструкция по работе с персональными токенами (https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)

Теперь нам необходимо синхронизировать локальный проект autotests-api с удалённым репозиторием на GitHub.

1 - Инициализация Git-репозитория
Выполните следующую команду в корневой папке проекта autotests-api, чтобы инициализировать репозиторий:
--
git init
----

2 - Настройка имени пользователя и электронной почты
Перед началом работы необходимо настроить Git, указав имя пользователя и email:
--
git config --global user.name "<Ваше имя пользователя на GitHub>"
git config --global user.email "<Ваш электронный адрес на GitHub>"
----

3 - Добавление удалённого репозитория
Установите ссылку на ваш репозиторий на GitHub:
--
git remote add origin <Ссылка на репозиторий autotests-api>
----
Для проверки успешной установки выполните:
--
git remote -v
----

4 - Создание первого коммита
Проверьте текущие изменения в репозитории:
--
git status
----
Добавьте все файлы в индекс:
--
git add .
----
Убедитесь, что файлы добавлены:
--
git status
----
Создайте коммит с описанием:
--
git commit -m "Initial commit"
----
Проверьте, что коммит создан:
--
git log
----

5 - Публикация изменений в удалённый репозиторий
Создайте ветку main, если она ещё не создана:
--
git branch -M main
----
Перед публикацией изменений и выполнением команды git push необходимо авторизоваться в GitHub с использованием персонального токена. Без этого опубликовать изменения в удалённый репозиторий не получится.

1. Перейдите в раздел Developer Settings (https://github.com/settings/tokens) и нажмите Generate new token.
Это действие приведёт вас на страницу создания нового токена, как показано на скриншоте (4.2 - Шаг 5)

2 - Введите название токена. Название должно кратко отражать назначение токена. Оно не влияет на функциональность, но помогает в будущем идентифицировать токен и избежать случайного удаления. Например, вы можете назвать токен autotests-api или MyProjectToken.

Установите срок действия токена (Expiration). Рекомендуется выбрать значение No expiration, чтобы токен не имел срока действия. Если вы установите дату истечения срока действия, то после этой даты токен перестанет работать, и придётся создавать новый. Чтобы избежать подобных неудобств, всегда выбирайте No expiration, особенно для токенов, которые используются для длительных проектов.

Предоставьте права токену. Для этого выберите все необходимые права, отметив соответствующие чекбоксы. Это действие позволяет токену иметь доступ ко всем функциям, которые могут понадобиться для работы с вашим проектом, как показано на скриншоте ниже.

Нажмите кнопку Generate token в самом низу страницы, чтобы завершить процесс создания токена.

3. После генерации токена он будет отображён только один раз. Обязательно скопируйте его и сохраните в надёжном месте, так как после перезагрузки страницы вы больше не сможете увидеть его. Если токен будет утерян, его потребуется создать заново.

После успешного создания токена выполните команду:
--
git push -u origin main
----

После выполнения команды git push откроется окно авторизации GitHub. Если окно не появилось, выполните команду повторно. В окне авторизации:

Выберите вкладку Token.
В поле Personal access token введите токен, который вы сгенерировали ранее.

На скриншоте ниже показано, как выглядит окно авторизации и куда вводить токен (4.2 - Шаг 5)

После ввода токена нажмите кнопку Sign in. После успешной авторизации изменения будут опубликованы в удалённый репозиторий на GitHub



Практика работы с GitHub

В качестве ответа на данное задание вам необходимо предоставить ссылку на ваш репозиторий на GitHub с проектом autotests-api.

Требования к репозиторию:
1 - Репозиторий должен быть публичным (Public), чтобы любой пользователь мог получить доступ к вашему проекту без дополнительных разрешений.
2 - Название репозитория должно быть autotests-api, чтобы соответствовать требованиям урока.
3 - В репозитории должны быть опубликованы все изменения, выполненные в рамках данного урока, включая настройки, добавленные файлы и изменения кода.
4 - Репозиторий обязательно должен содержать ветку main.



******************************************

4 - 4.3 - Работа с GitHub Desktop

Что такое GitHub Desktop?

Ссылки:
- Официальный сайт GitHub Descktop (https://github.com/apps/desktop?ref_cta=download+desktop&ref_loc=installing+github+desktop&ref_page=docs)
- Скачать GitHub Desktop (https://desktop.github.com/download/)

GitHub Desktop — это официальное бесплатное приложение от GitHub, которое предоставляет удобный графический интерфейс (GUI) для работы с Git и GitHub. Оно упрощает управление репозиториями для пользователей, которые не хотят или не умеют работать с Git через командную строку. GitHub Desktop доступен для операционных систем Windows и macOS и предназначен как для новичков, так и для опытных разработчиков, которым нужен более визуальный подход к работе с кодом.



Зачем нужен GitHub Desktop?

GitHub Desktop помогает пользователям выполнять задачи, связанные с управлением версиями кода, с минимальными усилиями и без необходимости запоминать команды Git. Основные преимущества использования GitHub Desktop:

1 - Упрощённая работа с Git
GitHub Desktop делает доступными основные функции Git через графический интерфейс, такие как:
- Создание репозиториев.
- Клонирование (копирование) удалённых репозиториев на локальный компьютер.
- Управление ветками (branches).
- Создание, просмотр и применение коммитов.
- Отправка изменений в удалённый репозиторий (push).
- Получение изменений из удалённого репозитория (pull).
- Разрешение конфликтов при слиянии (merge conflicts).

2 - Поддержка GitHub-репозиториев
Приложение оптимизировано для работы с GitHub, предоставляя быстрый доступ к репозиториям, созданным на платформе. Это особенно удобно для пользователей, которые часто работают с GitHub и его функциональностью, такой как pull requests и issues.

3 - Повышение продуктивности для начинающих
Пользователи, которые ещё не освоили команды Git, могут сразу приступить к работе с системой контроля версий, используя понятный интерфейс. Это снижает порог входа для новичков.

4 - Визуализация изменений
GitHub Desktop предоставляет удобные инструменты для:
- Просмотра изменений в коде (diff).
- Отслеживания истории коммитов.
- Сравнения разных веток.

5 - Удобное разрешение конфликтов
При слиянии веток (merge) приложение упрощает процесс выявления и устранения конфликтов, предоставляя понятные подсказки и инструменты.

6 - Поддержка совместной работы
GitHub Desktop интегрируется с функциями GitHub, такими как pull requests и issues, что упрощает взаимодействие между членами команды.

7 - Кроссплатформенность
Приложение работает на Windows и macOS, позволяя командам использовать единый инструмент независимо от операционной системы.



Основные функции GitHub Desktop

1 - Клонирование репозиториев
Позволяет легко загрузить копию существующего репозитория с GitHub на локальный компьютер для работы.

2 - Создание коммитов
Приложение позволяет добавлять изменения в коммит и прикреплять описания через интуитивный интерфейс.

3 - Работа с ветками
- Создание новых веток.
- Переключение между ветками.
- Удобное слияние веток (merge)

4 - Синхронизация с удалённым репозиторием
- Отправка изменений (push).
- Получение новых изменений (pull) и обновление локального репозитория.

5 - Интеграция с GitHub
Поддерживает функциональность pull requests, позволяя просматривать и обсуждать изменения в коде.

6 - Просмотр изменений
Подсвечивает разницу между текущей версией файла и его предыдущей версией.



Когда использовать GitHub Desktop?

1 - Новичкам в Git
Если вы только начинаете изучать Git и GitHub, GitHub Desktop станет отличным инструментом для выполнения базовых операций без необходимости изучать команды в терминале.

2 - Для визуализации работы
Программисты, которые предпочитают видеть изменения в графическом формате, найдут GitHub Desktop полезным.

3 - При работе с GitHub
GitHub Desktop идеально подходит для пользователей, которые активно используют GitHub для управления проектами.

4 - Для небольших проектов или индивидуальной работы
GitHub Desktop удобен для локальной работы с репозиториями, особенно если вы работаете без сложных сценариев, таких как конфигурация CI/CD.



Ограничения GitHub Desktop -

- Приложение не поддерживает все функции Git, такие как управление подмодулями (submodules) или настройка сложных сценариев, требующих редактирования конфигурационных файлов.

- Работает только с репозиториями, основанными на Git.

- Подходит больше для небольших и средних проектов, а для крупных командных проектов опытные разработчики могут предпочесть командную строку или интеграцию с IDE.

GitHub Desktop — это полезный инструмент для упрощения работы с Git и GitHub, который особенно ценен для начинающих разработчиков или тех, кто предпочитает работать с системой контроля версий через графический интерфейс.



Инструкции по установке GitHub Desktop

Скачивание GitHub Desktop
1 - Перейдите на официальный сайт GitHub Desktop: https://desktop.github.com/download/
(telegram - избранное - 03.11.2025 (21:02))
2 - Нажмите кнопку Download for Windows или Download for macOS, в зависимости от вашей операционной системы.


Установка на Windows

Шаг 1. Запуск установщика
1 - Откройте скачанный файл установщика, обычно он называется GitHubDesktopSetup.exe (telegram - избранное - 03.11.2025 (21:02))
2 - В открывшемся окне установщика дождитесь завершения процесса установки. GitHub Desktop автоматически установится на ваш компьютер без необходимости дополнительной настройки.

Шаг 2. Первый запуск
1 - После завершения установки GitHub Desktop автоматически запустится. Если этого не произошло, найдите приложение в меню Пуск или через поиск в Windows.
2 - При первом запуске вам будет предложено:
    - Авторизоваться в вашей учётной записи GitHub. Нажмите Sign in to GitHub.com и введите данные для входа (логин и пароль). Если у вас ещё нет аккаунта, создайте его по ссылке https://github.com/signup
    - При необходимости ввести код подтверждения, отправленный на вашу электронную почту.

Шаг 3. Настройка приложения
1 - Выберите предпочтительный редактор кода (например, Visual Studio Code) из списка.
2 - Настройте параметры по умолчанию для работы с репозиториями:
    - Укажите, где будут храниться локальные копии ваших репозиториев.
    - Выберите опцию для автоматической отправки анонимных данных об использовании приложения, если хотите (опционально).


Установка на macOS

Шаг 1. Запуск установщика
1 - Откройте скачанный файл, который будет называться GitHubDesktop.zip.
2 - После распаковки вы увидите приложение GitHub Desktop. Перетащите его в папку Applications (Программы), чтобы установить.

Шаг 2. Первый запуск
1 - Перейдите в папку Applications и запустите приложение GitHub Desktop.
2 - macOS может запросить разрешение на открытие приложения, так как оно было загружено из интернета. Нажмите Open.
3 - При первом запуске вам будет предложено:
    - Авторизоваться в вашей учётной записи GitHub. Нажмите Sign in to GitHub.com и введите данные для входа (логин и пароль). Если у вас ещё нет аккаунта, создайте его по ссылке https://github.com/signup
    - Ввести код подтверждения, отправленный на вашу электронную почту, если включена двухфакторная аутентификация.

Шаг 3. Настройка приложения
1 - Выберите предпочтительный редактор кода (например, Visual Studio Code или Xcode).
2 - Укажите местоположение для хранения локальных копий ваших репозиториев.
3 - Настройте отправку анонимных данных об использовании приложения (опционально).



Проверка установки

1 - Убедитесь, что GitHub Desktop установлен:
    - На Windows: найдите приложение в меню Пуск или через поиск.
    - На macOS: найдите приложение в папке Applications или через поиск Spotlight.

2 - Запустите GitHub Desktop и убедитесь, что можете:
    - Авторизоваться в GitHub.
    - Подключиться к существующему репозиторию или создать новый.


ВАЖНО - научиться работать с Git командами в терминале



******************************************

5 - 5.1 - Установка и настройка локального сервера

Настройка локального тестового сервера

Ссылки:
- Репозиторий с сервером Course API (https://github.com/Nikita-Filonov/qa-automation-engineer-api-course)

В этом уроке мы настроим локальный сервер, который понадобится для изучения работы с API. На этот сервер мы будем писать автотесты и использовать его для обучения. Поэтому крайне важно выполнить все шаги по установке и настройке локального сервера. Без выполнения этих шагов дальнейшая работа с курсом будет невозможна.

Этот сервер написан на Python и специально содержит тестовый API для обучения. При запуске сервера автоматически будет создана локальная база данных, в которой будут храниться все данные.



1 - Создание папки для локального сервера
Перед тем как клонировать и запускать код сервера, создайте папку на вашем компьютере для хранения кода. Это может быть любая папка, главное, чтобы вы её запомнили. Например, я буду использовать папку C:/courses (C\code_my_projects\python)

Откройте командную строку и перейдите в выбранную папку:
--
cd C:/courses
----



2 - Склонируем репозиторий
Теперь используйте команду для клонирования репозитория с кодом сервера:
--
git clone https://github.com/Nikita-Filonov/qa-automation-engineer-api-course
----
После завершения клонирования, перейдите в папку с проектом:
--
cd qa-automation-engineer-api-course
----



3 - Настраиваем виртуальное окружение
Теперь настроим виртуальное окружение для работы с проектом. В зависимости от операционной системы используйте соответствующие команды:

Для Windows:
Выполните команду для создания виртуального окружения:
--
python -m venv venv
----
Активируйте виртуальное окружение:
--
.\venv\Scripts\activate
----

Для macOS/Linux:
Создайте виртуальное окружение:
--
python3 -m venv venv
----
Активируйте виртуальное окружение:
--
source venv/bin/activate
----



4 - Устанавливаем зависимости
После активации виртуального окружения установим все необходимые зависимости:
--
pip install -r requirements.txt
----



5 - Создаем файл .env
Теперь нужно создать файл .env в папке проекта qa-automation-engineer-api-course. Этот файл будет содержать настройки для корректной работы сервера. Создать файл можно любым удобным для вас способом, например, через проводник на Windows или Finder на macOS.

Внутри файла .env добавьте следующий контент:
--
APP_HOST="http://localhost:8000"

DATABASE_URL="sqlite+aiosqlite:///./local.db"

JWT_ALGORITHM="HS256"
JWT_SECRET_KEY="qa-automation-engineer-api-course-secret-key"
JWT_ACCESS_TOKEN_EXPIRE=1800
JWT_REFRESH_TOKEN_EXPIRE=5184000
----
Описание содержимого файла .env:

- DATABASE_URL — строка подключения к базе данных. В данном случае это SQLite база данных, которая будет храниться в текущей папке с именем local.db.

- JWT_ALGORITHM — алгоритм для подписи JWT. Мы используем алгоритм HS256.

- JWT_SECRET_KEY — секретный ключ для подписания JWT токенов.

- JWT_ACCESS_TOKEN_EXPIRE — время в секундах, через которое истечет срок действия access token (например, 1800 секунд — это 30 минут).

- JWT_REFRESH_TOKEN_EXPIRE — время в секундах, через которое истечет срок действия refresh token (например, 5184000 секунд — это 60 дней).


После того как файл .env будет создан и отредактирован, не забудьте его сохранить.



6 - Запускаем локальный сервер
Теперь мы можем запустить локальный сервер командой:
--
uvicorn main:app --reload
----
Команду необходимо выполнить внутри папки qa-automation-engineer-api-course

Чтобы остановить сервер, нажмите комбинацию клавиш CTRL + C



7 - Открываем проект в PyCharm
Чтобы облегчить работу с сервером и автотестами, откройте код локального сервера в IDE (например, PyCharm). Это позволит вам быстро переключаться между проектами и не нужно будет каждый раз активировать виртуальное окружение и переходить в папку сервера вручную.

Инструкции по открытию проекта в PyCharm:
1 - Откройте PyCharm и выберите Open (Открыть).
2 - Найдите и выберите папку qa-automation-engineer-api-course, затем нажмите OK

После открытия проекта в PyCharm, вы можете запустить сервер внутри IDE, используя встроенный терминал. В нем выполните команду:
--
uvicorn main:app --reload
----

Теперь сервер будет запущен локально на вашем компьютере и доступен по адресу 
http://localhost:8000

Чтобы открыть документацию к доступным эндпоинтам, перейдите по адресу
http://localhost:8000/docs

Здесь вы найдете Swagger документацию, где будут перечислены все доступные методы взаимодействия с сервером

Теперь ваш локальный сервер настроен и работает



- Столкнулся с проблемой на стадии запуска локального сервера. Получал ошибку [WinError 10013] Сделана попытка доступа к сокету методом, запрещенным правами доступа. Перепробовал все возможные способы починить ошибку, ничего не помогало. Решением для меня стало -
"uvicorn main:app --port xxx"
На случай если у кого-то будет похожая проблема
- Ошибка [WinError 10013] Сделана попытка доступа к сокету методом, запрещенным правами доступа действительно часто связана с тем, что порт (по умолчанию 8000) уже занят другим процессом или заблокирован на уровне системы.
Вы абсолютно правильно поступили, указав другой порт вручную с помощью команды:
--
uvicorn main:app --port 8001
----
Это одно из самых надёжных решений, если порт 8000 недоступен. 
На будущее: при появлении такой ошибки можно также проверить, кто использует порт, с помощью команды:
--
netstat -aon | findstr :8000
----


На macOS вы можете открыть файл .env через Finder. Если вы используете команду sudo nano .env, то система запросит пароль — это пароль от вашей учетной записи macOS.
Если вы не хотите работать через терминал или вам не очень удобно использовать nano, можно сделать проще:
Выполните команду touch .env, если файла еще нет — она создаст файл.
Затем выполните open .env — файл откроется в стандартном текстовом редакторе, и вы сможете спокойно внести нужные правки.



Шаг 3





















