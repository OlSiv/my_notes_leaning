
https://stepik.org/course/242935/syllabus

stepik - 16-07-2025
6_300 р.



Не задавайте вопросы, которые можно легко найти в сети. Если что-то непонятно, постарайтесь сначала найти ответ самостоятельно. Если же неясно, с чего начать, обратитесь ко мне через урок Поддержка преподавателя и вопросы -
https://stepik.org/lesson/1677142/step/1



******************************************

1.1 Знакомимся

Нагрузочное тестирование — глубокая, системная дисциплина, которая требует понимания:
- ресурсов системы (CPU, RAM, IO),
- сетевых протоколов (HTTP/gRPC),
- устройства БД,
- очередей и кешей,
- архитектуры приложений (монолит vs микросервисы),
- работы со стендом, сидинга данных и CI/CD.

Это не просто «открыть браузер и нажать кнопку», как в UI-автотестах. Здесь каждый тест — это инженерная гипотеза, которая проверяет прочность всей системы под реальной нагрузкой.

Что будем изучать в курсе?
Прежде всего — у нас будет отдельный тестовый стенд, и это не просто CRUD API и база данных под ним. Вы будете работать с настоящей учебной банковской системой, построенной по принципам микросервисной архитектуры. В ней есть всё, что используется в современных production-системах:
- Kafka — для асинхронных очередей,
- S3-совместимое файловое хранилище (MinIO) — для работы с документами и вложениями,
- Redis — для кеширования,
- PostgreSQL — как основная реляционная БД,
- Поддержка двух протоколов: HTTP и gRPC.

Это максимально приближённый к боевым условиям стенд, а не «игрушка с /ping» в блокноте. Мы будем не просто «посылать запросы», а тестировать поведение сложной системы под реальной нагрузкой.

С первых шагов вы будете работать руками. Первые модули курса посвящены настройке окружения и изучению инфраструктуры, чтобы вы понимали:
- как устроен стенд,
- как взаимодействуют сервисы,
- какие метрики важны,
- какие системные ресурсы участвуют в нагрузке.

Вы освоите и будете использовать вживую:
- docker, docker-compose,
- PostgreSQL и утилиту pgAdmin,
- Kafka UI для работы с очередями,
- MinIO как облачное хранилище,
- Grafana для метрик и анализа,
- Postman для ручного взаимодействия с API,
и многое другое.

В этом курсе вы будете работать сразу с двумя протоколами — HTTP и gRPC. Когда мы пишем функциональные тесты, разница между ними может быть не столь заметна — формат запроса разный, но бизнес-логика одна и та же. А вот в нагрузочном тестировании отличия становятся принципиальными.
- gRPC работает поверх HTTP/2, использует бинарную сериализацию (protobuf) и куда эффективнее в плане скорости и сетевых затрат.
- HTTP проще, но медленнее — особенно при большом количестве пользователей и высокой конкуренции за ресурсы.

Моки: создаём собственные сервисы для нагрузки
В курсе мы не просто «попробуем», а создадим собственный мок-сервис с нуля — и сразу в двух вариантах: для HTTP и для gRPC. Зачем это нужно?
- Во-первых, моки — это важнейший инструмент в нагрузочном тестировании, особенно при проверке систем, где реальные зависимости либо нестабильны, либо ресурсоёмки.
- Во-вторых, вы научитесь отделять нагрузку на конкретный компонент от нагрузки на всю систему.
- В-третьих, эти навыки полезны не только в нагрузке, но и в интеграционном, изоляционном и контрактном тестировании.

Мы реализуем мок-сервис с использованием FastAPI и grpcio, и это даст вам в руки ещё один универсальный инструмент, который пригодится как QA-инженеру, так и performance-инженеру.

Нагрузочное тестирование без анализа метрик — это просто цифры. Поэтому мы научимся работать с Grafana — одним из самых мощных инструментов для визуализации и анализа системных метрик. Вы не просто будете «смотреть графики», а разбираться в происходящем под капотом:
- Какой сервис даёт пиковую нагрузку?
- Куда уходит CPU?
- Что расходует память?
- Где реальное узкое место?
- Почему RPS начал падать?

Мы самостоятельно настроим Grafana-дэшборд, чтобы вы могли анализировать нагрузку не вслепую, а как инженер-исследователь, принимающий решения на основе объективных данных.

Нагрузочное тестирование начинается не с кода и не с графика. Оно начинается с понимания бизнес-контекста. Мы научимся:
- не просто «влепить 1000 виртуальных пользователей»,
- а проанализировать реальные сценарии поведения пользователей,
- рассчитать нагрузочные пики, типичные RPS, время активной сессии,
- построить реалистичный профиль нагрузки, отражающий реальную работу системы в проде.

Locust — наш основной инструмент нагрузочного тестирования, и мы разберём его на атомы. Вы научитесь:
- запускать базовые сценарии,
- использовать TaskSet, SequentialTaskSet, веса, тайминги,
- интегрировать кастомные HTTP и gRPC клиенты,
собирать единую архитектуру фреймворка, подходящую под разные типы API и сценариев.

Итогом станет универсальный нагрузочный фреймворк, который вы сможете:
- развернуть с нуля в любом проекте,
- адаптировать под любую систему,
- аргументировать его архитектуру перед командой или на собеседовании.

Сидинг — это то, о чём не говорят в большинстве курсов. И очень зря. Система не живёт в вакууме. На проде она работает с миллионами уже существующих пользователей, аккаунтов, историй операций. А значит — и в нагрузочных тестах база должна быть реалистично наполнена. В курсе вы научитесь:
- писать сидинг-сценарии,
- подготавливать начальные данные: пользователей, счета, документы,
- сохранять эти данные в JSON-файлы и использовать повторно,
- восстанавливать состояние базы перед каждым прогоном.

Это один из самых критически важных шагов, потому что нагрузка на пустую систему даёт ложные результаты.

В курсе мы активно будем использовать настоящие инструменты, с которыми работают инженеры в реальных проектах:
- Git — для версионирования кода,
- Docker и Docker Compose — для поднятия микросервисного стенда,
- Postman — для ручной работы с HTTP и gRPC API,
- MinIO — как S3-совместимое файловое хранилище,
- PostgreSQL + pgAdmin — для работы с базой,
- Kafka UI — для мониторинга и отправки сообщений в очереди.

Вы не просто «увидите их», вы будете использовать их каждый день: запускать контейнеры, подключаться к брокеру, писать запросы, читать логи. Например, вы научитесь:
- отправлять gRPC-запросы через Postman,
- смотреть состояние Kafka-топиков,
- визуализировать структуру БД через pgAdmin.

Интеграция с CI/CD — автоматизация нагрузки

Нагрузочные тесты не должны жить «в локалке». Я покажу, как:
- интегрировать нагрузочное тестирование в CI/CD-процессы,
- настроить запуск тестов по кнопке,
- автоматически поднимать тестовый стенд с помощью Docker и Docker Compose.

Цель — добиться того, чтобы любой член команды мог:
- запустить нужный сценарий,
- получить метрики,
- увидеть результат в Grafana или отчёте.

Вы научитесь создавать гибкие, универсальные API-клиенты как для HTTP, так и для gRPC. Причём речь не о «заглушках для одного теста», а о полноценных клиентах, которые можно использовать в разных целях:
- в нагрузочном тестировании (как часть сценариев Locust),
- в сидинге — для генерации данных,
- в автоматизированных API-тестах, если вы захотите использовать тот же клиент за пределами курса.

Клиенты будут построены по принципу модульности и переиспользуемости: их легко масштабировать, адаптировать под другие проекты или команды. Это навык, который пригодится вам вне зависимости от вашей роли: QA, перформанс-инженер, automation, SDET — все работают с API, и грамотный API-клиент — это основа продуктивной работы.

В курсе мы также разберёмся в терминологии и видах тестирования производительности, потому что тут важно понимать нюансы. Часто можно услышать: «нагрузим систему до упора — будет нагрузочное тестирование». Но на самом деле — это упрощение, и часто приводит к неправильным выводам. Мы научимся отличать:
- нагрузочное тестирование (load testing) — чтобы понять, выдерживает ли система ожидаемую нагрузку;
- стресс-тестирование — когда мы проверяем, на сколько система способна выйти за пределы нормы;
- тестирование отказоустойчивости — когда эмулируются сбои, ошибки сервисов, падение компонентов;
- резилианс-тестирование — способность восстанавливаться после сбоев без потери данных и целостности;



******************************************

1.2 Советы по изучению материала

урок состоит из - 
- видео 
- теория 
- тесты 
- практическое задание 

смотреть сначала текст (+ схемы, ссылки и т.п.) а потом видео 

делать самому всё что автор делает в видео 

смотреть все ссылки и рекомендации, которые дает автор 



Изучение Python -

Этот курс предполагает базовые знания Python. Если вы не уверены в следующих темах, рекомендую сначала их повторить:

Переменные -
https://www.w3schools.com/python/python_variables.asp

Типы данных -
https://www.w3schools.com/python/python_datatypes.asp

Функции -
https://www.w3schools.com/python/python_functions.asp

Логические операторы -
https://www.w3schools.com/python/python_conditions.asp

Циклы -
https://www.w3schools.com/python/python_for_loops.asp

Lambda-функции -
https://www.w3schools.com/python/python_lambda.asp

Классы -
https://www.w3schools.com/python/python_classes.asp

Знакомство с пакетным менеджером pip -
https://www.w3schools.com/python/python_pip.asp

Работа со строками и форматирование строк -
https://www.w3schools.com/python/python_string_formatting.asp



Для закрепления основ Python, рекомендую следующие бесплатные курсы, которые можно пройти за одну-две недели:

Бесплатный курс по Python от W3Schools -
https://www.w3schools.com/python/default.asp

Бесплатный курс по Python от Metanit -
https://metanit.com/python/tutorial/

Эти ресурсы помогут вам уверенно работать с нагрузочным тестами.



******************************************

1.3 Инструкции по отправке заданий на проверку

=





