
Прямая ссылка на курс:
https://stepik.org/242935

https://stepik.org/course/242935/promo

https://stepik.org/course/242935/syllabus

В курс входят -
74 урока
50 часов 9 минут видео
640 тестов
44 интерактивные задачи



stepik - 16-07-2025
~ 6_250 р.



Не задавайте вопросы, которые можно легко найти в сети. Если что-то непонятно, постарайтесь сначала найти ответ самостоятельно. Если же неясно, с чего начать, обратитесь ко мне через урок Поддержка преподавателя и вопросы -
https://stepik.org/lesson/1677142/step/1



Если у вас возникают вопросы в процессе прохождения курса и вы не можете найти на них ответы, вы можете задать вопрос преподавателю в Telegram по адресу -
@sound_right
Преподаватель постарается ответить вам в течение трех рабочих дней



папка для GitHub на диске С -
load_testing_from_my_work



******************************************

1.1 Знакомимся

Нагрузочное тестирование — глубокая, системная дисциплина, которая требует понимания:
- ресурсов системы (CPU, RAM, IO),
- сетевых протоколов (HTTP/gRPC),
- устройства БД,
- очередей и кешей,
- архитектуры приложений (монолит vs микросервисы),
- работы со стендом, сидинга данных и CI/CD.

Это не просто «открыть браузер и нажать кнопку», как в UI-автотестах. Здесь каждый тест — это инженерная гипотеза, которая проверяет прочность всей системы под реальной нагрузкой.

Что будем изучать в курсе?
Прежде всего — у нас будет отдельный тестовый стенд, и это не просто CRUD API и база данных под ним. Вы будете работать с настоящей учебной банковской системой, построенной по принципам микросервисной архитектуры. В ней есть всё, что используется в современных production-системах:
- Kafka — для асинхронных очередей,
- S3-совместимое файловое хранилище (MinIO) — для работы с документами и вложениями,
- Redis — для кеширования,
- PostgreSQL — как основная реляционная БД,
- Поддержка двух протоколов: HTTP и gRPC.

Это максимально приближённый к боевым условиям стенд, а не «игрушка с /ping» в блокноте. Мы будем не просто «посылать запросы», а тестировать поведение сложной системы под реальной нагрузкой.

С первых шагов вы будете работать руками. Первые модули курса посвящены настройке окружения и изучению инфраструктуры, чтобы вы понимали:
- как устроен стенд,
- как взаимодействуют сервисы,
- какие метрики важны,
- какие системные ресурсы участвуют в нагрузке.

Вы освоите и будете использовать вживую:
- docker, docker-compose,
- PostgreSQL и утилиту pgAdmin,
- Kafka UI для работы с очередями,
- MinIO как облачное хранилище,
- Grafana для метрик и анализа,
- Postman для ручного взаимодействия с API,
и многое другое.

В этом курсе вы будете работать сразу с двумя протоколами — HTTP и gRPC. Когда мы пишем функциональные тесты, разница между ними может быть не столь заметна — формат запроса разный, но бизнес-логика одна и та же. А вот в нагрузочном тестировании отличия становятся принципиальными.
- gRPC работает поверх HTTP/2, использует бинарную сериализацию (protobuf) и куда эффективнее в плане скорости и сетевых затрат.
- HTTP проще, но медленнее — особенно при большом количестве пользователей и высокой конкуренции за ресурсы.

Моки: создаём собственные сервисы для нагрузки
В курсе мы не просто «попробуем», а создадим собственный мок-сервис с нуля — и сразу в двух вариантах: для HTTP и для gRPC. Зачем это нужно?
- Во-первых, моки — это важнейший инструмент в нагрузочном тестировании, особенно при проверке систем, где реальные зависимости либо нестабильны, либо ресурсоёмки.
- Во-вторых, вы научитесь отделять нагрузку на конкретный компонент от нагрузки на всю систему.
- В-третьих, эти навыки полезны не только в нагрузке, но и в интеграционном, изоляционном и контрактном тестировании.

Мы реализуем мок-сервис с использованием FastAPI и grpcio, и это даст вам в руки ещё один универсальный инструмент, который пригодится как QA-инженеру, так и performance-инженеру.

Нагрузочное тестирование без анализа метрик — это просто цифры. Поэтому мы научимся работать с Grafana — одним из самых мощных инструментов для визуализации и анализа системных метрик. Вы не просто будете «смотреть графики», а разбираться в происходящем под капотом:
- Какой сервис даёт пиковую нагрузку?
- Куда уходит CPU?
- Что расходует память?
- Где реальное узкое место?
- Почему RPS начал падать?

Мы самостоятельно настроим Grafana-дэшборд, чтобы вы могли анализировать нагрузку не вслепую, а как инженер-исследователь, принимающий решения на основе объективных данных.

Нагрузочное тестирование начинается не с кода и не с графика. Оно начинается с понимания бизнес-контекста. Мы научимся:
- не просто «влепить 1000 виртуальных пользователей»,
- а проанализировать реальные сценарии поведения пользователей,
- рассчитать нагрузочные пики, типичные RPS, время активной сессии,
- построить реалистичный профиль нагрузки, отражающий реальную работу системы в проде.

Locust — наш основной инструмент нагрузочного тестирования, и мы разберём его на атомы. Вы научитесь:
- запускать базовые сценарии,
- использовать TaskSet, SequentialTaskSet, веса, тайминги,
- интегрировать кастомные HTTP и gRPC клиенты,
собирать единую архитектуру фреймворка, подходящую под разные типы API и сценариев.

Итогом станет универсальный нагрузочный фреймворк, который вы сможете:
- развернуть с нуля в любом проекте,
- адаптировать под любую систему,
- аргументировать его архитектуру перед командой или на собеседовании.

Сидинг — это то, о чём не говорят в большинстве курсов. И очень зря. Система не живёт в вакууме. На проде она работает с миллионами уже существующих пользователей, аккаунтов, историй операций. А значит — и в нагрузочных тестах база должна быть реалистично наполнена. В курсе вы научитесь:
- писать сидинг-сценарии,
- подготавливать начальные данные: пользователей, счета, документы,
- сохранять эти данные в JSON-файлы и использовать повторно,
- восстанавливать состояние базы перед каждым прогоном.

Это один из самых критически важных шагов, потому что нагрузка на пустую систему даёт ложные результаты.

В курсе мы активно будем использовать настоящие инструменты, с которыми работают инженеры в реальных проектах:
- Git — для версионирования кода,
- Docker и Docker Compose — для поднятия микросервисного стенда,
- Postman — для ручной работы с HTTP и gRPC API,
- MinIO — как S3-совместимое файловое хранилище,
- PostgreSQL + pgAdmin — для работы с базой,
- Kafka UI — для мониторинга и отправки сообщений в очереди.

Вы не просто «увидите их», вы будете использовать их каждый день: запускать контейнеры, подключаться к брокеру, писать запросы, читать логи. Например, вы научитесь:
- отправлять gRPC-запросы через Postman,
- смотреть состояние Kafka-топиков,
- визуализировать структуру БД через pgAdmin.

Интеграция с CI/CD — автоматизация нагрузки

Нагрузочные тесты не должны жить «в локалке». Я покажу, как:
- интегрировать нагрузочное тестирование в CI/CD-процессы,
- настроить запуск тестов по кнопке,
- автоматически поднимать тестовый стенд с помощью Docker и Docker Compose.

Цель — добиться того, чтобы любой член команды мог:
- запустить нужный сценарий,
- получить метрики,
- увидеть результат в Grafana или отчёте.

Вы научитесь создавать гибкие, универсальные API-клиенты как для HTTP, так и для gRPC. Причём речь не о «заглушках для одного теста», а о полноценных клиентах, которые можно использовать в разных целях:
- в нагрузочном тестировании (как часть сценариев Locust),
- в сидинге — для генерации данных,
- в автоматизированных API-тестах, если вы захотите использовать тот же клиент за пределами курса.

Клиенты будут построены по принципу модульности и переиспользуемости: их легко масштабировать, адаптировать под другие проекты или команды. Это навык, который пригодится вам вне зависимости от вашей роли: QA, перформанс-инженер, automation, SDET — все работают с API, и грамотный API-клиент — это основа продуктивной работы.

В курсе мы также разберёмся в терминологии и видах тестирования производительности, потому что тут важно понимать нюансы. Часто можно услышать: «нагрузим систему до упора — будет нагрузочное тестирование». Но на самом деле — это упрощение, и часто приводит к неправильным выводам. Мы научимся отличать:
- нагрузочное тестирование (load testing) — чтобы понять, выдерживает ли система ожидаемую нагрузку;
- стресс-тестирование — когда мы проверяем, на сколько система способна выйти за пределы нормы;
- тестирование отказоустойчивости — когда эмулируются сбои, ошибки сервисов, падение компонентов;
- резилианс-тестирование — способность восстанавливаться после сбоев без потери данных и целостности;



******************************************

1.2 Советы по изучению материала

урок состоит из - 
- видео 
- теория 
- тесты 
- практическое задание 

смотреть сначала текст (+ схемы, ссылки и т.п.) а потом видео 

делать самому всё что автор делает в видео 

смотреть все ссылки и рекомендации, которые дает автор 



Изучение Python -

Этот курс предполагает базовые знания Python. Если вы не уверены в следующих темах, рекомендую сначала их повторить:

Переменные -
https://www.w3schools.com/python/python_variables.asp

Типы данных -
https://www.w3schools.com/python/python_datatypes.asp

Функции -
https://www.w3schools.com/python/python_functions.asp

Логические операторы -
https://www.w3schools.com/python/python_conditions.asp

Циклы -
https://www.w3schools.com/python/python_for_loops.asp

Lambda-функции -
https://www.w3schools.com/python/python_lambda.asp

Классы -
https://www.w3schools.com/python/python_classes.asp

Знакомство с пакетным менеджером pip -
https://www.w3schools.com/python/python_pip.asp

Работа со строками и форматирование строк -
https://www.w3schools.com/python/python_string_formatting.asp



Для закрепления основ Python, рекомендую следующие бесплатные курсы, которые можно пройти за одну-две недели:

Бесплатный курс по Python от W3Schools -
https://www.w3schools.com/python/default.asp

Бесплатный курс по Python от Metanit -
https://metanit.com/python/tutorial/

Эти ресурсы помогут вам уверенно работать с нагрузочным тестами.



******************************************

1.3 Инструкции по отправке заданий на проверку

Инструкция по отправке на проверку -
1 - Выполните задание и опубликуйте результат на GitHub.

- Решение задания должно быть зафиксировано в одном коммите, если это возможно.
- Название коммита должно соответствовать следующему шаблону: {название урока}. {название шага}. Например, для задания ниже коммит должен быть назван так: 
"Введение в HTTPX. Практическое задание: работа с HTTPX"

- Если задание не получилось выполнить в одном коммите, это не критично. В этом случае просто добавьте еще один коммит с тем же названием, чтобы сохранить логическую структуру.

2 - Вставьте ссылку на GitHub репозиторий в поле ответа:
https://github.com/Nikita-Filonov/performance-tests

3 - Вы получите баллы за задание после его рецензирования

Важно! Если сейчас вам непонятны термины "репозиторий", "коммит" и структура GitHub, не беспокойтесь. Вы сможете пропустить данный шаг и вернуться к нему позже, после изучения основ работы с Git в уроке Начало работы с Git -
https://stepik.org/lesson/1799578/step/1?unit=1825311

- Обратите внимание, что задание не будет принято к оценке, если оно не соответствует указанному формату
- Отправить решение на рецензию можно только один раз!



Текстовый ответ -

Инструкция по отправке на проверку

1 - Составьте текстовый ответ:
- Напишите подробный ответ, следуя требованиям задания.
- Убедитесь, что ваш ответ содержит все необходимые шаги и пояснения.

2 - Вставьте решение в поле ответа

3 - Вы получите баллы за задание после его рецензирования



проверять ответы на задания, если ошибся - создать коммит с таким же названием 



******************************************

1.4 Поддержка от преподавателя и вопросы

Задавать вопросы рекомендуется в следующих ситуациях:
- Если при выполнении практического задания возникли трудности с пониманием условий и вы не уверены, как его выполнить.
- Если при изучении материала курса вы столкнулись с проблемой, которую не удается решить самостоятельно.
- Если вам непонятен процесс отправки домашнего задания на проверку.
- Если вы наткнулись на тему, в которой хотите разобраться глубже, и хотите получить дополнительные материалы для изучения.
- В любых других ситуациях, когда вам не удалось самостоятельно найти ответ, и вы исчерпали доступные ресурсы.



******************************************

2.1 Виды тестирования производительности

Виды тестирования производительности (Performance Testing)
Ссылки:

Performance Testing -
https://glossary.istqb.org/en_US/term/performance-testing
- Тип теста для определения эффективности работы компонента или системы.


Load Testing (нагрузочное тестирование) -
https://glossary.istqb.org/en_US/term/load-testing
- Тип тестирования производительности, проводимый для оценки поведения компонента или системы при различных нагрузках, обычно в интервале между ожидаемыми условиями низкой, типичной и пиковой нагрузки.
-
- что это - стандартная нагрузка, увеличенная в 2-3-5-6 раз 
- цель - нагрузить систему и собрать определенные метрики 
- когда проводится - после добавления новой функциональности или изменения старой (рефакторинга), либо перед каждым релизом и сравнивать метрики с предидущими релизами  


Stress Testing (стресс-тестирование) -
https://glossary.istqb.org/en_US/term/stress-testing
- Тип тестирования производительности, проводимый для оценки системы или компонента на пределе ожидаемых или указанных рабочих нагрузок или за их пределами, или при ограниченной доступности ресурсов, таких как доступ к памяти или серверам.
-
- что это - каждый раз повышаем нагрузку, пока система не откажет - 100-200-300-400-......
- цель - узнать максимальную нагрузку и увидеть какой компонент первым выходит из строя и как система будет восстанавливаться после сбоя, и вообще восстановится ли она 
- когда проводится - никогда не проводить на продакшине, только на тестовых стендах, проводится например при черной пятницей, акциями, когда ожидается большая пиковая нагрузка и нужно понять предел системы 


Soak Testing/Endurance Testing (тестирование выносливости) -
https://glossary.istqb.org/en_US/term/endurance-testing
- Тестирование для определения стабильности системы под значительной нагрузкой в течение значительного периода времени в контексте эксплуатации системы.
-
- что это - подаём ту же нагрузку что и обычно, но в течении нескольких часов или дней 
- цель - выявление утечек ресурсов либо накопительных эффектов - например есть система где кэшируются данные, и мы несколько часов или суток держим её под стандартной постоянной нагрузкой, и смотрим как ведут себя ресурсы, например каждый час по немногу возрастает нагрузка на память, то есть кэш не очищается и остается в памяти, и т.п. При обычном нагрузочном тестировании это может быть незаметно, а при долгом тестировании уже заметно 
- когда проводится - в системах которые долгое время работают под нагрузкой (банковские системы, телеком, чарты, биржи)


Spike Testing (тестирование всплесков) -
https://glossary.istqb.org/en_US/term/spike-testing
- Тестирование для определения способности системы восстанавливаться после внезапных скачков пиковых нагрузок и возвращаться в устойчивое состояние.
-
- что это - здесь нагрузка подаётся резким всплеском, например со 100 до 3000 
- цель - посмотреть как система переживает пик и как восстанавливается после этого, будет ли использоваться кэширование, будут ли увеличиваться ресурсы, масштабироваться система, либо вернутся ошибки, как при DDOS-атаке или когда клиент сразу отправляет очень много запросов на сервер 


Scalability Testing (тестирование масштабируемости) -
https://glossary.istqb.org/en_US/term/scalability-testing
- Тестирование для определения масштабируемости программного продукта.
-
- что это - подаем нагрузку и потихоньку её увеличиваем (тестируем вертикальное масштабирование(количество пользователей растет и соответственно растут потребляемые ресурсы) и горизонтальное масштабирование(растет количество инстансов, до 20-30 штук может расти (копий системы, контейнеров)))
- цель - снять метрики и посмотреть как система масштабируется (будет ли вообще масштабироваться) и что для нас выгоднее - рост ресурсов (вертикальное) или рост количества инстансов системы (горизонтальное) 
- когда проводится - когда поменяли инфраструктуру, настройки или переехали в облачное хранилище 


Failover / Resilience Testing (тестирование отказоустойчивости) -
-
- что это - подаём нагрузку, которая постоянно увеличивается, и смотрим как ведут себя компоненты системы на предмет отказоустойчивости, например есть сервис, который должен быть всегда доступен, сервер должен сам определить когда начинает давать сбой и включить механизм Circuit Breaker, при котором наша система начинает чуть медленее отвечать либо тротлить, то есть этот механизм защищает сервер от отказа (падения) при непомерной нагрузке  

Circuit Breaker распределяет - эти запросы в очередь, эти я замедляю, а эти я отклоняю 

Иногда мы сами можем отключить какой-то сервис, или иммитировать отказ БД, кэширования и посмотреть как себя ведет система, насколько наш сервис отказоустойчивый 


Chaos Testing (хаос-тестирование) -
-
- что это - подаем нагрузку на стенд и начинаем отключать или замедлять сервисы, уменьшать их ресурсы, не позволять им масштабироваться и т.д. 
- цель - Смотрим насколько система устойчивая и надежная. 


Circuit Breaker Design Pattern -
https://en.wikipedia.org/wiki/Circuit_breaker_design_pattern

Тестирование производительности (Performance Testing) включает в себя несколько подвидов, каждый из которых фокусируется на определённой характеристике системы: скорости отклика, устойчивости, масштабируемости и способности к восстановлению. Далее мы рассмотрим ключевые виды такого тестирования.



И ещё раз про то же самое -



1. Load Testing (нагрузочное тестирование)

Цель:
- Проверка, как система работает под нормальной и увеличенной ожидаемой нагрузкой в течение продолжительного времени.

Особенности:
- Эмулируется реалистичная пользовательская активность (например, 100–500 одновременных пользователей).
- Проверяются: производительность, стабильность, скорость отклика, throughput.
- Используется на этапе подготовки к реальному продакшену.

Типичные метрики:
- Время отклика (Response Time)
- Пропускная способность (Requests per Second, Throughput)
- Утилизация CPU / памяти / сети
- Количество ошибок

Когда использовать:
- Перед релизом или масштабированием
- Для выявления узких мест при ожидаемой нагрузке



2. Stress Testing (стресс-тестирование)

Цель:
Определить максимальную нагрузку, которую система может выдержать до деградации или сбоя. Проверяется поведение за пределами нормальных условий.

Особенности:
- Нагрузка постепенно или резко увеличивается выше проектной нормы.
- Цель — увидеть, когда и как "ломается" система, и как она восстанавливается после сбоя.
- Тестируется устойчивость и деградация, а не стабильная работа.

Нюансы:
- Может привести к серьёзным сбоям, поэтому не проводится в продакшене.
- Важно отслеживать, какие компоненты первыми выходят из строя.

Когда использовать:
- При оценке пределов масштабируемости
- При подготовке к резким пиковым нагрузкам (распродажи, маркетинговые кампании)



3. Soak Testing / Endurance Testing (тестирование выносливости)

Цель:
Проверить стабильность системы при продолжительной нагрузке (несколько часов или даже дней) с целью выявления утечек ресурсов и накопительных эффектов.

Особенности:
- Нагрузка может быть на уровне Load Testing, но важно время: часы, сутки.
- Ищутся памятные утечки, утечка соединений, ухудшение времени отклика со временем.
- Выявляются проблемы, которые не видны при коротком тестировании.

Когда использовать:
- В критических системах с длительной работой (банкинг, телеком)
- После обновлений, которые могут повлиять на сборку мусора, кеширование и пр.



4. Spike Testing (тестирование всплесков)

Цель:
Оценить реакцию системы на резкий, кратковременный всплеск нагрузки.

Особенности:
- В отличие от Stress Testing, нагрузка скачет внезапно и резко, а не нарастает.
- Имитируется ситуация, например, когда внезапно заходит 10 000 пользователей за 1 секунду.
- Проверяется, как система "переживает" пик и восстанавливается.

Когда использовать:
- Для оценки реакции на DDoS, флешмобы, баги в клиентском ПО
- Для тестирования автоскейлинга и кэширования



5. Scalability Testing (тестирование масштабируемости)

Цель:
Проверить, насколько хорошо система масштабируется при увеличении:
- числа пользователей,
- объёма данных,
- количества узлов и ресурсов (CPU, памяти и т.д.)

Особенности:
- Может проводиться как в вертикальном (увеличение ресурсов), так и в горизонтальном масштабе (добавление инстансов).
- Анализируется эффективность масштабирования: линейное, сублинейное или деградирующее.

Когда использовать:
- При выборе между горизонтальным и вертикальным масштабированием
- При тестировании облачных или распределённых архитектур



6. Failover / Resilience Testing (тестирование отказоустойчивости)

Цель:
Оценить, как система реагирует на сбой компонентов (сервисов, БД, сети, дисков), и способна ли она восстановиться.

Особенности:
- Имитируются реальные сбои: отключение узла, отказ БД, network partition, и т.д.
- Часто сочетается с Chaos Testing.
- Проверяются механизмы репликации, автоматического переключения, circuit breaker'ы и пр.

Когда использовать:
- При построении отказоустойчивых систем
- Для валидации резервирования и механизмов восстановления



Circuit Breaker

Circuit Breaker (в контексте распределённых систем и отказоустойчивости) — это паттерн устойчивости, который предотвращает повторяющиеся попытки обращения к зависимому (часто внешнему) компоненту, если он уже не отвечает или работает с ошибками. Другими словами это программный механизм, который временно блокирует вызовы к ресурсу (например, микросервису или базе данных), если обнаружено, что он находится в ошибочном или нестабильном состоянии. Это помогает избежать избыточной нагрузки на зависимость и позволяет системе восстанавливаться более эффективно.

Circuit Breaker имеет три состояния:

1 - Closed (закрыт):
- Всё работает нормально.
- Запросы проходят к целевому компоненту.
- При ошибках считает количество/частоту неудач.

2 - Open (открыт):
- Когда число неудач превышает порог — "перегорает".
- Запросы не отправляются, а сразу получают ошибку.
- Даёт целевому компоненту "время на восстановление".

3 - Half-Open (полуоткрыт):
- Через некоторое время позволяет отправить ограниченное количество пробных запросов.
- Если они успешны — возвращается в Closed.
- Если снова ошибка — возвращается в Open.

Зачем нужен:
- Защищает систему от каскадных сбоев.
- Улучшает восстанавливаемость и устойчивость.
- Избегает перегрузки зависимого сервиса в момент, когда он уже не работает.

Примеры применения:
- Между микросервисами, где один сервис зависит от другого.
- При работе с нестабильной внешней API.
- В связке с retry и fallback логикой.



7. Chaos Testing (хаос-тестирование)

Цель:
- Преднамеренно вносить хаос и неопределённость в систему, чтобы проверить её устойчивость и надёжность в условиях неожиданных сбоев.

Особенности:
- Выключение случайных сервисов, сетевых подключений, подмена данных.
- Нестабильность создаётся преднамеренно, часто в продакшене.
- Используется инструментами типа Chaos Monkey, Gremlin.

Нюансы:
- Требует зрелой инфраструктуры, мониторинга и автоматического восстановления.
- Очень мощный инструмент, но опасен без должного контроля.



Сводная таблица сравнения:

Вид теста         - Load Testing
Цель              - Проверить стабильность
Нагрузка          - В норме
Продолжительность - Средняя	
Пример метрик     - Время отклика, ошибки

Вид теста         - Stress Testing
Цель              - Найти пределы	
Нагрузка          - Сверх нормы
Продолжительность - Кратковременная
Пример метрик     - Точка отказа, деградация

Вид теста         - Soak Testing
Цель              - Найти утечки, дрейф
Нагрузка          - В норме	
Продолжительность - Долгая
Пример метрик     - Утечки памяти, рост latency

Вид теста         - Spike Testing	
Цель              - Проверить на всплески	
Нагрузка          - Резкие пики
Продолжительность - Кратковременная
Пример метрик     - Пиковое поведение, отклик

Вид теста         - Scalability Testing	
Цель              - Проверить масштабируемость	
Нагрузка          - Растущая
Продолжительность - Любая	
Пример метрик     - Throughput на ресурс

Вид теста         - Resilience Testing
Цель              - Проверить восстановление
Нагрузка          - Любая	
Продолжительность - По сценарию
Пример метрик     - Восстановление, ошибки

Вид теста         - Chaos Testing
Цель              - Проверить устойчивость к сбоям
Нагрузка          - Нестабильная
Продолжительность - Любая
Пример метрик     - Выживаемость, самовосстановление


Мы в рамках этого курса будем работать с Load Testing (нагрузочным тестированием) - время ответа, количество запросов в секунду, процессор, память, диск, сеть - то есть будем делать снятие всяких метрик 

Также в этом уроке мы разобрали все виды тестирования производительности 



******************************************

2.2 Системные ресурсы: CPU и память

=











	
	
	
	




