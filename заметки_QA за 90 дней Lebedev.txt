
telegram - избранное - 19.08.2025 

проходить - по 1 теме в день 



******************************************

ПОЛЕЗНЫЕ МАТЕРИАЛЫ - 

шпаргалка для тестировщиков - 
https://docs.google.com/spreadsheets/d/1YM8ey2VNZ63q-IQxQoitro7zNN_rcOfsUB-wCi_hMCY/edit?gid=38461779#gid=38461779

фундаментальная теория тестирования - 
https://habr.com/ru/articles/549054/

QA библия - 
https://vladislaveremeev.gitbook.io/qa_bible

бесплатный крутой курс по python -
https://stepik.org/course/67/promo

лучший курс по алгоритмам на python -
https://www.youtube.com/playlist?list=PLRDzFCPr95fK7tr47883DFUbm4GeOjjc0

роадмап тестировщика -
https://miro.com/app/board/uXjVOsbBpjE=/

roadmap по python -
https://habr.com/ru/articles/725930/



******************************************

неделя 1 - день 1 (18.08.2025) - 

виды компаний - 
https://www.youtube.com/watch?v=t6mQkEa4O90

виды IT компаний и специфика работы в них для тестировщика -

1 - продуктовые IT компании - сами разрабатывают  

2 - аутсорсинговые IT компании - предоставляют в аренду свой персонал 

3 - аутстаффинговые IT компании - в отличие от аутсорса, отвечает только за свой квалифицированный персонал, но не берет на себя обязательства по успешности проекта заказчика 

4 - стартапы - разрабатывают свой продукт 

Чем отличается работа тестировщика в разных IT компаниях?

- требования к тестировщику
- ценность роли тестировщика и процесса тестирования 
- наличие тестовой документации 
- экспертность команды по тестированию 
- возможность роста и уровень ЗП 



******************************************

неделя 1 - день 2 (19.08.2025) - 

команда разработки - 
https://habr.com/ru/articles/695944/

Стандартный список ролей -
- аккаунт менеджер 
- продакт менеджер 
- проджект менеджер
- менеджер по продажам (сейлз)
- архитектор ПО 
- бизнес аналитик
- системный аналитик 
- технический писатель 
- проектировщик (макеты интерфейса)
- дизайнер (внешний вид продукта)
- фронтенд разработчик (верстальщик)
- бекэнд разработчик (или фулстек)
- тестировщик 
- локализатор (переделывает приложение под другие языки, страны)
- тимлид 



******************************************

неделя 1 - день 3 (20.08.2025) - 

цикл разработки по -
https://testengineer.ru/sdlc/

SDLC (Software Development Life Cycle) - последовательность этапов разработки -
- идея 
- сбор требований и анализ 
- дизайн 
- разработка 
- тестирование 
- деплой 
- поддержка

В общем виде SDLC состоит из 6 этапов: 
- Планирование
- Анализ
- Дизайн
- Разработка и тестирование
- Имплементация (деплой)
- Поддержка (обслуживание)

модели SDLC -
- водопадная (каскадная)
- гибкие методологии 
- v-модель 
- интерактивная и инкрементальная 
- эволюционного прототипирования 
- спиральная 



******************************************

неделя 1 - день 4 (21.08.2025) - 

словарь itшника -
https://docs.google.com/document/d/192vMjZjdZX9IIXiHSN2UH8ZxKcKDCAWnBZIltK4Hdvw/edit?tab=t.0#heading=h.8i6o3gxucuuy

+++



******************************************

неделя 1 - день 5 (22.08.2025) - 

методологии разработки - 
https://habr.com/ru/companies/edison/articles/269789/

+++



******************************************

неделя 1 - день 6 (23.08.2025) - 

agile - 
https://habr.com/ru/companies/edison/articles/313410/

+++



******************************************

неделя 1 - день 7 (24.08.2025) - 

scrum -
https://www.youtube.com/watch?v=bv4L_32J-5A

scrum - это фреймворк agile для гибкого управления проектами 

итерационная модель - основополагающая в scrum 

в водопадной модели невозможно вернутся на предыдущий этап, приходится начинать всё с начала - в scrum это возможно, и можно изменять требования 

agile-манифест - 4 основопологающие ценности - 
- люди и взаимодействие важнее процессов и инструментов 
- рабочий продукт важнее исчерпывающей документации 
- сотрудничество с заказчиком важнее согласования условий контракта 
- готовность к изменениям важнее следования первоначальному плану 

scrum = фреймворк :
1 - scrum команда 
2 - события 
3 - артефакты 
4 - метрики 

scrum - не советует создавать команды численностью более 9 человек (разработчики, которые решают что будем делать на проекте)

разработчик тоже несет ответственность за баг в продукте (коллективная ответственность)

scrum master - обучение и понимание scrum членами команды 



спринт - отрезок 2-4 недели -

- планирование спринта - выбираем из бэклога продукта что мы возьмем для данного спринта 

- ежедневный дейлик (митинг) - примерно 15 минут - что делал вчера, что планируешь делать сегодня, какие есть трудности, проблемы (вчера я писал тест-кейс для такой-то юзерстори, сегодня я буду писать тест-кейс для такой-то юзерстори, мне не понятно как рабработчики будут реализовывать такую-то юзерстори, хочу сегодня связаться с разработчиком и это выяснить)

- подведение итогов спринта (ретроспектива) - 
    - что шло хорошо в спринте 
    - какие проблемы были в спринте 
    - как можно улучшить работу 
    - идеи по ходу ретроспективы 



пользовательская история - описание чего-то, что система должна делать для пользователя (как новый пользователь в системе я хочу купить телефон, чтобы порадовать себя)

стори-поинт - единица оценки юзер-стори (пользовательских историй) 



******************************************

неделя 2 - день 1 (25.08.2025) - 

rest - 
https://testengineer.ru/rest/ 

REST (Representational State Transfer) — это архитектурный стиль, используемый при разработке распределенных систем, веб-сервисов и API (Application Programming Interface). Он определяет набор принципов и ограничений для создания масштабируемых, гибких и легко поддерживаемых систем.



Основные принципы REST:

1 - Клиент-серверная архитектура: В REST-архитектуре существует четкое разделение между клиентом (который инициирует запросы) и сервером (который предоставляет ресурсы и обрабатывает запросы). Это позволяет независимо изменять и развивать обе стороны без влияния на другую

2 - Без состояния (Stateless): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для обработки этого запроса. Сервер не хранит информацию о состоянии клиента между запросами. Это позволяет легко масштабировать серверную часть, так как каждый запрос обрабатывается независимо

3 - Кэширование: REST поддерживает механизм кэширования, позволяющий клиентам сохранять локальные копии ответов сервера. Это улучшает производительность, снижает нагрузку на сервер и улучшает пользовательский опыт

4 - Единообразие интерфейса: REST определяет универсальный интерфейс, состоящий из четырех основных методов HTTP: GET (получение ресурса), POST (создание нового ресурса), PUT (обновление ресурса) и DELETE (удаление ресурса). Эти методы позволяют управлять ресурсами на сервере

5 - Слои: REST позволяет использовать промежуточные слои (например, прокси-серверы или кэши), которые могут улучшать безопасность, масштабируемость и производительность системы



RESTful API (RESTful Application Programming Interface) — это API, разработанное с использованием принципов REST. Оно предоставляет доступ к ресурсам и операциям через стандартные методы HTTP. RESTful API широко используется в веб-разработке для создания взаимодействия между клиентскими приложениями и серверами, обмена данными и выполнения операций над ресурсами



Различия между REST и SOAP - 
Во-первых SOAP — это протокол, а REST — архитектурный стиль.

Лучше сравнивать реализации:
- SOAP: XML поверх SOAP через HTTP
- RESTful: JSON через HTTP



******************************************

неделя 2 - день 2 (26.08.2025) - 

soap - 
https://testengineer.ru/soap/

SOAP (Simple Object Access Protocol) — это протокол обмена структурированными сообщениями в формате XML (eXtensible Markup Language) между клиентом и сервером. SOAP используется для создания веб-служб (web services), которые обеспечивают взаимодействие между различными приложениями и платформами.

SOAP был широко использован в прошлом для интеграции различных систем и веб-служб. Однако, в последние годы, многие разработчики перешли на использование более легковесных и простых в использовании протоколов, таких как REST.

Основные характеристики SOAP:

1 - XML-основа: SOAP использует XML для кодирования структурированных данных в сообщениях. XML обеспечивает гибкость и расширяемость для передачи различных типов данных.

2 - Протокол независимый: SOAP не привязан к конкретному протоколу передачи данных и может использовать различные протоколы для отправки сообщений, такие как HTTP, SMTP и другие.

3 - Структурированные сообщения: SOAP сообщения состоят из заголовков (headers) и тела (body). Заголовки могут содержать информацию о безопасности, маршрутизации, версии протокола и другие метаданные. Тело содержит фактические данные, передаваемые между клиентом и сервером.

4 - Операции и методы: SOAP определяет операции, которые можно вызвать на удаленном сервере, и методы, которые могут быть выполнены над ресурсами. Он использует специальный язык описания веб-службы (WSDL — Web Services Description Language) для описания доступных операций и формата сообщений.

5 - Протокол с высоким уровнем абстракции: SOAP обеспечивает высокий уровень абстракции, что позволяет разработчикам скрыть детали взаимодействия и реализации от клиентов, фокусируясь на логике бизнес-операций.



******************************************

неделя 2 - день 3 (27.08.2025) - 

монолит - 
https://www.youtube.com/watch?v=wypO96zubGc

монолиты и микросервисы - это про API, про тестирование бекенда, HTTP методов 

у каждого микросервиса, как и у монолита, свои API

микросервисы могут быть расположенны на разных серверах 



******************************************

неделя 2 - день 4 (28.08.2025) - 

микросервисы - 
https://www.youtube.com/watch?v=XtOJZ1T3qw4&t=1492s



проблема монолитов - 

- жесткое связывание
 
- ответственность за разные компоненты монолита
 
- при изменениях тратится много времени на перепроверку логики работы всех компонентов монолита 

- проблемы при деплое и развертывании монолита 



на стартапе лучше выбирать монолит 

на большом проекте лучше выбирать микросервисы 

в своем пет-проекте лучше выбрать микросервисы 



микросервисы сложнее разрабатывать, чем монолит 

по канонам - у каждого микросервиса должна быть своя база данных 



сообщество где шпаргалка по микросервисам и другие материалы -
https://www.faang.school/community

бесплатный курс по Java Core - 
https://www.faang.school/java-magics 



******************************************

неделя 2 - день 5 (29.08.2025) - 

HTTPS - 
https://selectel.ru/blog/http-request/

Данные между клиентом и сервером в рамках работы протокола передаются с помощью HTTP-сообщений. Они бывают двух видов:

- Запросы (HTTP Requests) — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.

- Ответы (HTTP Responses) — сообщения, которые сервер отправляет в ответ на клиентский запрос.



Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек.

В целом, как запросы HTTP, так и ответы имеют следующую структуру:

1 - Стартовая строка (start line) — используется для описания версии используемого протокола и другой информации — вроде запрашиваемого ресурса или кода ответа. Как можно понять из названия, ее содержимое занимает ровно одну строчку.

2 - HTTP-заголовки (HTTP Headers) — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо описывают содержимое тела сообщения.

3 - Пустая строка, которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены.

4 - Опциональное тело сообщения, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе.



Рассмотрим атрибуты HTTP-запроса подробнее - 



1. Стартовая строка
Стартовая строка HTTP-запроса состоит из трех элементов:

- Метод HTTP-запроса (method, реже используется термин verb). Обычно это короткое слово на английском, которое указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.

- Цель запроса. Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.

- Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.
В примере ниже стартовая строка указывает, что в качестве метода используется GET, обращение будет произведено к ресурсу /index.html, по версии протокола HTTP/1.1:
--
GET /index.html HTTP/1.1
----



Методы -
Методы позволяют указать конкретное действие, которое мы хотим, чтобы сервер выполнил, получив наш запрос. Так, некоторые методы позволяют браузеру (который в большинстве случаев является источником запросов от клиента) отправлять дополнительную информацию в теле запроса — например, заполненную форму или документ.



Метод - описание - 

GET - Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value).О составляющих URL мы поговорим чуть позже.

POST - Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.

HEAD - Здесь придется забежать немного вперед и сказать, что обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.

PUT - Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.

DELETE - Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.

OPTIONS - Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.

PATCH - Позволяет внести частичные изменения в указанный ресурс по указанному расположению.



URL

Получение доступа к ресурсам по HTTP-протоколу осуществляется с помощью указателя URL (Uniform Resource Locator). URL представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров.

Использование URL неразрывно связано с другими элементами протокола, поэтому далее мы рассмотрим его основные компоненты и строение:

Поле Scheme используется для указания используемого протокола, всегда сопровождается двоеточием и двумя косыми чертами (://).

Host указывает местоположение ресурса, в нем может быть как доменное имя, так и IP-адрес.

Port, как можно догадаться, позволяет указать номер порта, по которому следует обратиться к серверу. Оно начинается с двоеточия (:), за которым следует номер порта. При отсутствии данного элемента номер порта будет выбран по умолчанию в соответствии с указанным значением Scheme (например, для http:// это будет порт 80).

Далее следует поле Path. Оно указывает на ресурс, к которому производится обращение. Если данное поле не указано, то сервер в большинстве случаев вернет указатель по умолчанию (например index.html).

Поле Query String начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа амперсанд (&) в качестве разделителя.

Не все компоненты необходимы для доступа к ресурсу. Обязательно следует указать только поля Scheme и Host.



Версии HTTP

Раз уж мы упомянули версию протокола как элемента стартовой строки, то стоит сказать об основных отличиях версий HTTP/1.X от HTTP/2.X.

Последняя стабильная, наиболее стандартизированная версия протокола первого поколения (версия HTTP/1.1) вышла в далеком 1997 году. Годы шли, веб-страницы становились сложнее, некоторые из них даже стали приложениями в том виде, в котором мы понимаем их сейчас. Кроме того, объем медиафайлов и скриптов, которые добавляли интерактивность страницам, рос. Это, в свою очередь, создавало перегрузки в работе протокола версии HTTP/1.1.

Стало очевидно, что у HTTP/1.1 есть ряд значительных недостатков:

- Заголовки, в отличие от тела сообщения, передавались в несжатом виде.

- Часто большая часть заголовков в сообщениях совпадала, но они продолжали передаваться по сети.

- Отсутствовала возможность так называемого мультиплексирования — механизма, позволяющего объединить несколько соединений в один поток данных. Приходилось открывать несколько соединений на сервере для обработки входящих запросов.

С выходом HTTP/2 было предложено следующее решение: HTTP/1.X-сообщения разбивались на так называемые фреймы, которые встраивались в поток данных.

Фреймы данных (тела сообщения) отделялись от фреймов заголовка, что позволило применять сжатие. Вместе с появлением потоков появился и ранее описанный механизм мультиплексирования — теперь можно было обойтись одним соединением для нескольких потоков.

Единственное о чем стоит сказать в завершение темы: HTTP/2 перестал быть текстовым протоколом, а стал работать с «сырой» двоичной формой данных. Это ограничивает чтение и создание HTTP-сообщений «вручную». Однако такова цена за возможность реализации более совершенной оптимизации и повышения производительности.



Заголовки

HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.

В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:

1 - Общего назначения, которые применяются ко всему сообщению целиком.

2 - Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.

3 - Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.



Самые частые заголовки запроса

Заголовок - описание -

Host - Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.

User-Agent - Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.

Refer - Используется для указания того, откуда поступил текущий запрос. Например, если вы решите перейти по какой-нибудь ссылке в этой статье, то вероятнее всего к запросу будет добавлен заголовок Refer: https://selectel.ru

Accept - Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (‘ , ‘). А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.

Cookie - Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.

Authorization - Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.



Тело запроса

Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. Некоторые виды запросов  могут отправлять данные на сервер в теле запроса: самый распространенный из таких методов — POST.



Ответы HTTP

HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело.



Строка статуса (Status line)

Стартовая строка HTTP-ответа называется строкой статуса (status line). На ней располагаются следующие элементы:

1 - Уже известная нам по стартовой строке запроса версия протокола (HTTP/2 или HTTP/1.1).

2 - Код состояния, который указывает, насколько успешно завершилась обработка запроса.

3 - Пояснение — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.
--
HTTP/1.1 200 OK 
----



Коды состояния и текст статуса

Коды состояния HTTP используются для того, чтобы сообщить клиенту статус их запроса. HTTP-сервер может вернуть код, принадлежащий одной из пяти категорий кодов состояния:

Категория - описание - 

1xx - Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.

2xx - Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.

3xx - Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.

4xx - Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа.

5xx - Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.



Полный список кодов состояния доступен в спецификации к протоколу, ниже приведены только самые распространенные коды ответов:

Категория - описание - 

200 OK - Возвращается в случае успешной обработки запроса, при этом тело ответа обычно содержит запрошенный ресурс.

302 Found - Перенаправляет клиента на другой URL. Например, данный код может прийти, если клиент успешно прошел процедуру аутентификации и теперь может перейти на страницу своей учетной записи.

400 Bad Request - Данный код можно увидеть, если запрос был сформирован с ошибками. Например, в нем отсутствовали символы завершения строки.

403 Forbidden - Означает, что клиент не обладает достаточными правами доступа к запрошенному ресурсу. Также данный код можно встретить, если сервер обнаружил вредоносные данные, отправленные клиентом в запросе.

500 Internal Error - Данный код возвращается сервером, когда он не может по определенным причинам обработать запрос.



Помимо основных кодов состояния, описанных в стандарте, существуют и коды состояния, которые объявляются крупными сетевыми провайдерами и серверными платформами.



Заголовки ответа

Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела. Они существуют в том же формате, что и остальные заголовки, а именно  «Имя-Значение» с двоеточием (:) в качестве разделителя.

Ниже приведены наиболее часто встречаемые в ответах заголовки:

Категория - Пример - Описание - 

Server - Server: ngnix - Содержит информацию о сервере, который обработал запрос. 

Set-Cookie - Set-Cookie:PHPSSID=bf42938f - Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов.

WWW-Authenticate - WWW-Authenticate: BASIC realm=»localhost» - Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.



Тело ответа

Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является обязательным. Например, у кодов «201 Created» или «204 No Content» тело отсутствует, так как достаточную информацию для ответа на запрос они передают в заголовке.



Безопасность HTTP-запросов, или что такое HTTPs

HTTP является расширяемым протоколом, который предоставляет огромное количество возможностей, а также поддерживает передачу всевозможных типов файлов. Однако, вне зависимости от версии, у него есть один существенный недостаток, который можно заметить если перехватить отправленный HTTP-запрос -  данные передаются в открытом виде. HTTP сам по себе не предоставляет никаких средств шифрования.

HTTPs (HyperText Transfer Protocol, secure) является расширением HTTP-протокола, который позволяет шифровать отправляемые данные, перед тем как они попадут на транспортный уровень. Данный протокол по умолчанию использует порт 443.

Если мы перехватим не HTTP , а HTTPs-запрос, то не увидим здесь ничего интересного.

Данные передаются в едином зашифрованном потоке, что делает невозможным получение учетных данных пользователей и прочей критической информации средствами обычного перехвата.

Если хотите подробнее узнать о деталях работы протокола, читайте статью в нашем блоге - 
https://selectel.ru/blog/http-https/



Как отправить HTTP-запрос и прочитать его ответ 

Теория это, конечно, отлично, но ничего так хорошо не закрепляет материал, как практика

Мы рассмотрим несколько способов, как написать HTTP-запрос в браузер, послать HTTP-запрос на сервер и получить ответ:
1 - Инструменты разработчика в браузере. 
2 - Утилита cURL.



Инструменты разработчика

Основной программой на наших устройствах, которая работает с HTTP-протоколом, в большинстве случаев является браузер. Помимо обычных пользователей, с браузерами часто работают и разработчики веб-приложений. Именно их инструментами мы воспользуемся для работы с запросами и ответами.

По нажатию комбинации клавиш [Ctrl+Shift+I] или просто [F12] в подавляющем большинстве современных браузеров у нас откроется окно инструментов разработчика, которая представляет собой панель с несколькими вкладками. Нужная нам вкладка обычно называется Network. Перейдем в нее, а в адресной строке введем URL того сайта, на который хотим попасть. В качестве примера воспользуемся сайтом блога Selectel — https://selectel.ru/blog/.

После нажатия Enter сайт начнет загружаться, а открытая вкладка Network — заполняться различными элементами, начиная все больше напоминать приборную панель самолета.

Не спешите пугаться. Это всего лишь список ресурсов, которые нужны для правильного отображения и работы сайта.

Нажав на любой из них, мы можем увидеть детали обработки отправленного запроса

В данном запросе, например:
- URL, к которому было совершено обращение — https://selectel.ru/blog,
- Метод, который был использован в запросе — GET,
- И в качестве кода возврата сервер вернул нам страницу с кодом статуса — 200 OK 



После запуска утилита выполняет: 
- подключение к серверу, 
- самостоятельно разрешает все вопросы, необходимые для отправки запроса по HTTPs, 
- отправляет запрос, содержимое которого мы можем видеть благодаря флагу -v,
- принимая ответ от сервера, отображает его в командной строке «как-есть».  

Помимо этого, у данной утилиты есть огромное количество опций, которые предоставляют возможности по детальной настройке отправляемых запросов. Все эти возможности и делают ее такой популярной у веб-разработчиков и других специалистов, которым приходится работать с протоколом HTTP.

HTTP представляет собой расширяемый протокол прикладного уровня, на котором работает весь веб-сегмент интернета.



******************************************

неделя 2 - день 6 (30.08.2025) - 

API - 
https://habr.com/ru/articles/464261/

видео про API - 
https://www.youtube.com/watch?v=QYg5z6EGOk4

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это». Если переводить на русский, это было бы слово «договор». Договор между двумя сторонами, как договор на покупку машины:
- мои обязанности — внести такую то сумму,
- обязанность продавца — дать машину.

API отвечает на вопрос “Как ко мне, к моей системе можно обратиться?”, и включает в себя:
- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

API — это набор функций. Это может быть одна функция, а может быть много.

можно группировать API по функционалу. То есть:
- отдельно API для входа в систему, где будет регистрация и авторизация;
- отдельно API для отчетности — отчет 1, отчет 2, отчет 3… отчет N. Для разных отчетов у нас разные формулы = разные функции. И все мы их собираем в один набор, api для отчетности.
- отдельно API платежек — для работы с каждым банком своя функция.
- ...

Можно не группировать вообще, а делать одно общее API.

Можно сделать одно общее API, а остальные «под заказ». Если у вас коробочный продукт, то в него обычно входит набор стандартных функций. А любые хотелки заказчиков выносятся отдельно.

в нашей системе есть несколько разных API, на каждое из которых у нас написан контракт. В каждом контракте четко прописано, какие операции можно выполнять, какие функции там будут

И конечно, функции можно переиспользовать. То есть одну и ту же функцию можно включать в разные наборы, в разные апи. Никто этого не запрещает.

разработчик придумывает, какое у него будет API. Либо делает общее, либо распределяет по функционалу или каким-то своим критериям, и в каждое апи добавляет тот набор функций, который ему необходим.

API — это Application programming interface. Почему ты тогда говоришь о контракте, хотя там слово интерфейс? Да потому, что в программировании контракт — это и есть интерфейс. В классическом описании ООП (объектно-ориентированного программирования) есть 3 кита:
- Инкапсуляция
- Наследование
- Полиморфизм

Инкапсуляция — это когда мы скрываем реализацию. Для пользователя все легко и понятно. Нажал на кнопочку — получил отчет. А как это работает изнутри — ему все равно. Какая база данных скрыта под капотом? Oracle? MySQL? На каком языке программирования написана программа? Как именно организован код? Не суть. Программа предоставляет интерфейс, им он и пользуется.

Не всегда программа предоставляет именно графический интерфейс. Это может быть SOAP, REST интерфейс, или другое API. Чтобы использовать этот интерфейс, вы должны понимать:
- что подать на вход;
- что получается на выходе;
- какие исключения нужно обработать.

Пользователи работают с GUI — graphical user interface. Программы работают с API — Application programming interface. Им не нужна графика, только контракт.

Как вызывается API - Вызвать апи можно как напрямую, так и косвенно.

Напрямую:
- Система вызывает функции внутри себя
- Система вызывает метод другой системы
- Человек вызывает метод
- Автотесты дергают методы

Косвенно:
- Пользователь работает с GUI



Вызов API напрямую -



1. Система вызывает функции внутри себя

Разные части программы как-то общаются между собой. Они делают это на программном уровне, то есть на уровне API! Это самый «простой» в использовании способ, потому что автор API, которое вызывается — разработчик. И он же его потребитель, но проблемы с документацией есть всегда. Просто в этом случае в качестве документации будут комментарии в коде. А они, увы, тоже бывают неактуальны. Или разработчики разные, или один, но уже забыл, как делал исходное api и как оно должно работать…



2. Система вызывает метод другой системы

А вот это типичный кейс, которые тестируют тестировщики в интеграторах. Или тестировщики, которые проверяют интеграцию своей системы с чужой. Одна система дергает через api какой-то метод другой системы. Она может попытаться получить данные из другой системы. Или наоборот, отправить данные в эту систему. Допустим, я решила подключить подсказки из Дадаты к своему интернет-магазинчику, чтобы пользователь легко ввел адрес доставки. 
Я подключаю подсказки по API. И теперь, когда пользователь начинает вводить адрес на моем сайте, он видит подсказки из Дадаты. Как это получается:
- Он вводит букву на моем сайте
- Мой сайт отправляет запрос в подсказки Дадаты по API
- Дадата возвращает ответ
- Мой сайт его обрабатывает и отображает результат пользователю

Вон сколько шагов получилось! И так на каждый введенный символ. Пользователь не видит этого взаимодействия, но оно есть. И, конечно, не забываем про кейс, когда мы разрабатываем именно API-метод. Который только через SOAP и можно вызвать, в интерфейсе его нигде нет.

Пример можно посмотреть в Users. Метод MagicSearch создан на основе реальных событий - 
https://testbase.atlassian.net/wiki/spaces/USERS/pages/1249378773/MagicSearch

в самой системе в пользовательском интерфейсе есть только обычный поиск, просто строка ввода. Ну, может, парочка фильтров. А вот для интеграции нужна была целая куча доп возможностей, что и было сделано через SOAP-метод.

Функционал супер-поиска доступен только по API, пользователь в интерфейсе его никак не пощупает.

В этом случае у вас обычно есть ТЗ, согласно которому работает API-метод. Ваша задача — проверить его. Типичная задача тестировщика, просто добавьте к стандартным тестам на тест-дизайн особенности тестирования API, и дело в шляпе!



3. Человек вызывает метод

Причины разные:
- Для ускорения работы
- Для локализации бага (проблема где? На сервере или клиенте?)
- Для проверки логики без докруток фронта

Если система предоставляет API, обычно проще дернуть его, чем делать то же самое через графический интерфейс. Тем более что вызов API можно сохранить в инструменте. Один раз сохранил — на любой базе применяешь, пусть даже она по 10 раз в день чистится.

Для примера снова идем в Users (https://okiseleva.blogspot.com/2017/04/users-soap-rest.html). Если мы хотим создать пользователя, надо заполнить уйму полей!

Конечно, это можно сделать с помощью специальных плагинов типа Form Filler (https://okiseleva.blogspot.com/2019/04/form-filler.html). Но что, если вам нужны адекватные тестовые данные под вашу систему? И на русском языке?

Заполнение полей вручную — грустно и уныло! А уж если это надо повторять каждую неделю или день на чистой тестовой базе — вообще кошмар. Это сразу первый приоритет на автоматизацию рутинных действий.

И в данном случае роль автоматизатора выполняет… Postman. Пользователя можно создать через REST-запрос CreateUser (https://testbase.atlassian.net/wiki/spaces/USERS/pages/871924071/CreateUser). Один раз прописали нормальные “как настоящие” данные, каждый раз пользуемся. Профит!

Вместо ручного заполнения формы (1 минута бездумного заполнения полей значениями «лпрулпк») получаем 1 секунду нажатия на кнопку «Send». При этом значения будут намного адекватнее.

А еще в постмане можно сделать отдельную папку подготовки тестовой базы, напихать туда десяток запросов. И вот уже на любой базе за пару секунд вы получаете столько данных, сколько вручную вбивали бы часами!

Если вы нашли баг и не понимаете, на кого его вешать — разработчика front-end или back-end, уберите все лишнее. Вызовите метод без графического интерфейса. А еще вы можете тестировать логику программы, пока интерфейс не готов или сломан.



4. Автотесты дергают методы

Есть типичная пирамида автоматизации:
- GUI-тесты — честный тест, «как это делал бы пользователь».
- API-тесты — опускаемся на уровень ниже, выкидывая лишнее.
- Unit-тесты — тесты на отдельную функцию

Слово API как бы намекает на то, что будет использовано в тестах

Допустим, у нас есть:
- операция: загрузка отчета;
- на входе: данные из ручных или автоматических корректировок или из каких-то других мест;
- на выходе: отчет, построенный по неким правилам

Правила построения отчета:
Ячейка 1: Х — Y
Ячейка 2: Z * 6
...

Пирамида автоматизации - 
- UI - открыть браузер, кликнуть кнопочку
- API - загрузить отчет 
- Unit - забрать данные из А

GUI-тесты — честный тест, робот делает все, что делал бы пользователь. Открывает браузер, тыкает на кнопочки… Но если что-то упадет, будете долго разбираться, где именно.

API-тесты — все то же самое, только без браузера. Мы просто подаем данные на вход и проверяем данные на выходе. Например, можно внести итоговый ответ в эксельку, и пусть робот выверяет ее, правильно ли заполняются данные? Локализовать проблему становится проще.

Unit-тесты — это когда мы проверяем каждую функцию отдельно. Отдельно смотрим расчет для ячейки 1, отдельно — для ячейки 2, и так далее. Такие тесты шустрее всего гоняются и баги по ним легко локализовать.



Косвенный вызов API

Когда пользователь работает с GUI, на самом деле он тоже работает с API. Просто не знает об этом, ему это просто не нужно. То есть когда пользователь открывает систему и пытается загрузить отчет, ему не важно, как работает система, какой там magic внутри. У него есть кнопочка «загрузить отчет», на которую он и нажимает. Пользователь работает через GUI (графический пользовательский интерфейс).

Но на самом деле под этим графическим пользовательским интерфейсом находится API. И когда пользователь нажимает на кнопочку, кнопочка вызывает функцию построения отчета.

А функция построения отчета уже может вызывать 10 разных других функций, если ей это необходимо.

И вот уже пользователь видит перед собой готовый отчет. Он вызвал сложное API, даже не подозревая об этом!



Что значит «Тестирование API»

В первую очередь, мы подразумеваем тестирование ЧЕРЕЗ API. «Тестирование API» — общеупотребимый термин, так действительно говорят, но технически термин некорректен. Мы не тестируем API, мы не тестируем GUI (графический интерфейс). Мы тестируем какую-то функциональность через графический или программный интерфейс.

Но это устоявшееся выражение. Можно использовать его и говорить “тестирование API”. И когда мы про это говорим, мы имеем в виду:
- автотесты на уровне API
- или интеграцию между двумя разными системами.

Интеграция — когда одна система общается с другой по какому-то протоколу передачи данных. Это называется Remote API, то есть общение по сети, по некоему протоколу (HTTP, JMS и т.д.). В противовес ему есть еще Local API (он же «Shared memory API») — это то API, по которому программа общается сама с собой или общается с другой программой внутри одной виртуальной памяти.

Когда мы говорим про тестирование API, чаще всего мы подразумеваем тестирование Remote API. Когда у нас есть две системы, находящихся на разных компьютерах, которые как-то между собой общаются. И если вы видите в вакансии «тестирование API», скорее всего это подразумевает умение вызвать SOAP или REST сервис и протестировать его.



Резюме

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

Контракт включает в себя:
- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

Вызвать API можно как напрямую, так и косвенно:
- Система вызывает функции внутри себя
- Система вызывает метод другой системы
- Человек вызывает метод
- Автотесты дергают методы
- Пользователь работает с GUI

Когда говорят про API с тестировщиком, обсуждают два варианта:
- автотесты на уровне API (умение автоматизировать)
- интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP Ui или Postman).

Если вы хотите отработать второй вариант и поучиться отправлять запросики — используйте бесплатную систему Users (https://okiseleva.blogspot.com/2017/04/users-soap-rest.html)! И мои обучающие видосики, например, «Как отправить REST-запрос за 5 минут» - 
https://www.youtube.com/watch?v=U7-8ZmCBiPI&lc=z23qdpgwsv3wxzbsqacdp431jrsmac0ukr1vpbosgz1w03c010c



******************************************

неделя 2 - день 7 (31.08.2025) - 

ньюансы тестирования КСА (клиент-серверной архитектуры) - 
https://habr.com/ru/articles/495698/


Клиент — та программа, с которой работает пользователь. Он знать не знает, это у него на компьютере программа целиком, или где-то за ней прячутся сервер с базой, а то и целый RAID. Он работает в браузере или с desktop-приложением. И всё, что ему нужно знать — это «куда тут тыкать».

Клиенту не нужно много памяти, места на диске и других ресурсов. Поэтому рабочие места относительно дешево стоят. А это именно то, что нам нужно, особенно если нужно закупить оборудование для тысяч операционисток банка.

Сервер — компьютер, на котором хранится само приложение. Весь код, вся логика, все дополнительные материалы и справочники. Например, справочник адресов ФИАС или справочник юр лиц ЕГРЮЛ — они тоже занимают место, как сами по себе, так и в памяти приложения.

Иногда говорят «сервер приложения» и «сервер БД». Это нормально, ведь фактически сервер — это просто машина, компьютер. А базу и сервер приложения обычно хранят на разных машинах, ради безопасности. В таком случае, если говорят «сервер приложения» — речь о втором звене нашей схемы.

Приложения бывают самые разные. Есть ресурсоемкие, им нужно много памяти и места на диске. Есть «легкие», которые можно развернуть даже на домашнем компьютере.

БД (база данных) — хранилище данных. Тут вы можете легко поискать информацию + уверены в том, что она сохранится, даже если в приложении что-то сломается. Подробнее о ней — в статье «Что такое База Данных (БД)» - 
https://habr.com/ru/post/555760/

Сколько места нужно под базу, зависит от количества данных. Есть огромные базы в банках, где и 1тб будет мало. А есть совсем небольшие, которые вы можете установить на своей машине. Например, XAMPP можно поставить. И врядли вы напихаете туда столько данных, что у вас не останется под них место.

Отдельной базы может не быть, тогда структура станет двузвенной: клиент-сервер. И все!

Схема условная, в реальной жизни у нас как минимум будет больше клиентов. А если приложение высоконагруженное, то будет несколько серверов и несколько баз данных



Перед серверами ставят балансировщик, и клиент шлет запрос туда. Сколько бы серверов не поставили в кластер, клиенту это не интересно. У него есть один URL — адрес балансировщика.

Такая схема используется для высоконагруженного приложения — когда запросов поступает так много, что один сервер с ними просто не справляется.

Facebook, amazon, google — туда заходят миллионы пользователей. Один сервер с ними не справится. Поэтому ставят кластер, а балансировщик делит между ними нагрузку. И в таком случае в кластере может быть не 2 сервера, а 10, 15, сколько нужно, столько и ставим.

При этом мы можем точно также балансировать базу данных. У нас может быть несколько копий баз данных на самых разных машинах, и балансировщик отправляет запросы то к одной, то ко второй.

Такая схема называется горячий резерв — когда у нас есть несколько серверов, работающих в параллель, и балансировщик распределяет нагрузку между ними.

При этом может быть и схема холодного резерва — когда у нас второй сервер является резервной копией «на всякий случай». Все запросы идут на первый сервер, второй отдыхает.

Но если с первым сервером что-то случится и он помрет, балансировщик перенаправит нагрузку на второй сервер

В это время у администраторов будет время разобраться с проблемой на сервере 1.

Схема холодного резерва используется тогда, когда один сервер способен выдержать нагрузку и выдавать хорошую скорость работы. Но приложение при этом бизнес-критичное и простой неприемлем.

Простой может быть не только потому, что случилось что-то плохое. Есть еще штатное обновление приложения. Обе схемы резервирования позволяют обновляться безболезненно.



Сервера стоят дорого. Туда нельзя поставить обычный SSD как для домашнего компьютера. Почему? Потому что к железу для серверов совсем другие требования по надежности + есть поддержка специфичных функций -

— у HDD это специальная микропрограмма контроллера, которая оптимизирована для работы диска в RAID, дома это не нужно.

— у SSD это наличие группы конденсаторов, которые хранят энергию на случай отключения питания, чтобы хватило времени скинуть из DDR кэша данные в энергонезависимую память и данные не побились.

SSD — быстро работающий диск, HDD — обычный. RAID — когда мы N дисков вместе соединили, а DDR кэш — это оперативная память

По цене отличаются в 2 раза. Например, SSD:
- для дома гигабайт стоит 16,53р
- для сервера энтерпрайз гиг стоит 32 рубля



Чтобы понимать, что тестировать, надо понимать, с чем имеет дело человек.

Пользователь работает с клиентом. Это может быть web или desktop приложение, не суть. Операционистке Кате дали рабочее место, показали какую программу запускать и как с ней работать. Она знать не знает о наличии серверов и БД, она работает только с клиентом.

Поэтому тестировщик в первую очередь проверяет клиент! Потому что сервер может работать идеально, вы можете даже написать тесты на уровне API и они все будут зелененькие, и кажется, что все зашибись! А пользователь загрузит отчет и увидит ошибку. Ой.

Сервер работает, на клиенте ошибка. И плевать на сотни «зеленых» автотестов. У пользователя все равно ошибка. И наша задача — посмотреть с его точки зрения.

Однако, если у вас есть доступ к серверу приложения и его базе данных — стоит проверять и их тоже! Так мы можем увидеть «будущий баг». Например:
- Сохранили карточку товара — система ее отрисовывает и говорит, что все хорошо. На клиенте все отлично!
- Проверили по базе — а там часть полей осталась пустая, разработчик неправильно указал название поля в БД. И информация потерялась.



То, что сейчас пользователь видит в клиенте — это просто кеш, «что ввел, то и отображаю». Если не проверить по базе, такая проблема может даже вскрыться не сразу. Пользователь открывает карточку товара — часть полей не заполнена:
— Ну, наверное, их и не заполняли.
А их заполняли! Просто сохранение криво сработало. Поэтому, если у нас только черный ящик, то нужно проверять, «а реально ли сохранились данные?». Сохранили? Откройте карточку в новом окне или вызовете информацию через API-метод.

Если доступ к базе есть — просто проверьте по ней, что все хорошо. Если есть доступ к серверным логам — проверьте их на наличие ошибок.



Тестировщик изучает уязвимости и потом рассказывает команде:
— Ребята, вот я проверил, у нас есть такие-то и такие-то потенциальные дыры. Давайте подумаем, надо нам их как-то закрывать или нет.

То есть не факт, что исправлять проблему будут. Может, у вас некритичное приложение — данные не утекут, деньги вы не храните. Тогда и заморачиваться лишний раз никто не будет, потому что тестировать на защищенность — дорого, специалистов мало.

Но какие-то базовые проверки типа sql-иньекций или XSS-атак стоит изучить и проверить на своем приложении. Хотя бы чтобы понять их критичность. Ведь если атака сломает клиент — ну и пусть, сам себе буратино. А если атака положит сервер, это уже не очень хорошо. И надо хотя бы знать, от чего это бывает.



******************************************

неделя 3 - день 1 (01.09.2025) - 

виды тестирования -
https://testengineer.ru/vidy-tipy-testirovaniya/

картинки с типами тестирования - 
telegram - my_coding - 01.09.2025 

Функциональные тесты могут выполняться вручную, или могут вполне успешно автоматизироваться (https://testengineer.ru/chto-takoe-avtomatizirovannoe-testirovanie/)

Часто применяемые инструменты функционального тестирования, с которые тестировщик должен уметь работать (или хотя бы ознакомиться поверхностно): 

- UFT (ранее известный как QTP) -
https://www.microfocus.com/en-us/products/unified-functional-automated-testing/overview

- Selenium -
https://www.seleniumhq.org/

- JUnit -
https://junit.org/junit5/

- SoapUI -
https://www.soapui.org/

- Watir -
http://watir.com/



Selenium — инструмент тестировщика №1, овладеть им — кажется, решающий момент в трудоустройстве, по крайней мере сейчас. Стремящийся стать QA-джуном должен знать (как минимум), о чем спрашивают на собеседовании по Selenium -
https://testengineer.ru/sobesedovanie-selenium-o-chem-sprashivajut/

Нефункциональное тестирование - это не о том, работает ли софт или нет, это о том, КАК он работает и как он выглядит.

Автоматизация применяется, и очень широко, поскольку нефункциональные тесты весьма сложны и длительны. Чаще всего автоматизируется тестирование производительности.

Виды (типы) нефункционального тестирования:
- Тестирование производительности
- Нагрузочное
- Безопасности
- Тестирование на отказ
- Совместимости
- Юзабилити-тестирование
- Масштабируемости
- Объемное тестирование
- Стресс-тестирование
- Удобства сопровождения
- Совместимости
- Общей эффективности
- Надежности
- Выносливости
- Тестирование восстановления после катастрофического отказа
- Тестирование локализации и интернационализации



Типы тестирования: общий список:



1 - Юнит-тестирование -
Другое название, менее распространенное, но более интуитивное — «модульное тестирование». Также встречается название «компонентное тестирование».
Проверка по отдельности каждого модуля (юнита). Она требует знания языка программирования, на котором написан код приложения, а также хорошего знания его архитектуры, «внутренностей». По этой причине, в большинстве случаев юнит-тесты пишут разработчики — создатели приложения.

Подробнее по теме:

- Что такое юнит-тестирование? -
https://testengineer.ru/unit-testirovanie/

- Очень подробный гайд по юнит-тестированию -
https://testengineer.ru/unit-testirovanie-guide/



2 - Интеграционное тестирование -
После интеграции модулей наступает черед интеграционного тестирования. Это проверка, как интегрированные, то есть уже соединенные в целостное приложение модули «сработались вместе». Таких тестов уже меньше, чем модульных.

Подробнее о пирамиде тестирования — здесь -
https://testengineer.ru/levels-of-software-testing/#-faq-why-pyramid

Часто используемые инструменты юнит и интеграционного тестирования: 

- Jasmine -
https://jasmine.github.io/

- Mocha -
https://jasmine.github.io/



Подробнее по интеграционному тестированию:

- Интеграционное тестирование -
https://testengineer.ru/integracionnoe-testirovanie/

- Юнит-тесты vs интеграционные тесты -
https://testengineer.ru/unit-testy-vs-integracionnye-testy/



3 - Сквозное тестирование -
E2E-тестирование это подтип функционального, проверка всей системы «из конца в конец», end-to-end, поэтому такое название. Таких тестов еще меньше количественно, но они еще сложнее чем интеграционные и тем более модульные (и требуют больше опыта от тестировщика).  

Инструменты, которые нужно освоить, чтобы претендовать на позицию E2E-QA: 

- Cucumber -
https://cucumber.io/

- Protractor -
https://www.protractortest.org/

- Jasmine -
https://jasmine.github.io/

- Karma -
https://karma-runner.github.io/1.0/index.html

- SpecFlow -
https://specflow.org/community/talking-about-specflow/

- Сквозное (end-to-end-тестирование) — гайд -
https://testengineer.ru/e2e-testirovanie/



4 - Тестирование интерфейса -
Тестирование GUI — проверка, отвечает ли интерфейс требованиям, изложенным в спецификациях; а также специальным гайдам владельца платформы — например, для мобильных приложений существуют специальные гайды, злостное несоблюдение которых грозит недопуском в магазин приложений, или исключением, если приложение уже там. 

Инструменты GUI-тестирования: 

- Monkey test for Android -
https://developer.android.com/studio/test/monkey.html

- Saucelabs -
https://saucelabs.com/

- Protractor -
http://www.protractortest.org/#/

- Тестированию GUI посвящен отдельный большой материал -
https://testengineer.ru/testirovanie-gui-polnoe-rukovodstvo/



5 - Тестирование доступности -
Проверка доступности, или легкости пользования людьми с ограничениями — но не только ими. Например, водителям тоже важно удобство/скорость/интуитивность, или специфические настройки в приложении; и вообще это важно любым людям, управляющим сложными механизмами. 

Приложение должно быть проверено на удобство для слабослышащих и слабовидящих людей, и людей с цветовой слепотой, и при необходимости откорректировано. Например, должна быть создана специальная «контрастная» цветовая схема.

Более подробно о таком специфическом типе тестирования — отдельный материал -
https://testengineer.ru/chto-takoe-testirovanie-dostupnosti/



6 - Альфа-тестирование -
Поиск всех ошибок и проблем в приложении в целом. Проводится на последнем этапе разработки, и внутри компании (в этом отличие от бета-тестирования). Проводится перед запуском продукта (передачей его заказчику). Цель: удостовериться, что юзер/клиент получит продукт, не содержащий багов.

Альфа-тестирование проводят в девелоперском окружении (а не в реальном пользовательском). Для имитации пользовательского окружения создается виртуальное окружение.

Что такое альфа-тестирование? - 
https://testengineer.ru/chto-takoe-alpha-testirovanie/



7 - Бета-тестирование -
Бета-тестирование проводится после альфа-, и перед запуском продукта. Для бета-тестирования нужно реальное пользовательское окружение. Выбирается ограниченное количество реальных пользователей-«добровольцев» (клиентов), которые, не будучи специалистами в QA, тестируют продукт на свое усмотрение. Затем они дают фидбек, и конструктивную критику, после чего разработчики, при необходимости, вносят изменения в так называемую бета-версию продукта. Далее исправленный и доработанный продукт поступает на релиз, то есть становится доступен всем пользователям.

Что такое бета-тестирование? -
https://testengineer.ru/chto-takoe-beta-testirovanie/



8 - Ad-hoc-тестирование -
Еще называемое интуитивным, поскольку проводится в «интуитивной» манере, на усмотрение тестировщика, без тест-кейсов, планов и другой оформляемой документации. Несистематичность — отличающий признак ад-хок-тестирования. 

Хотя искать баги без тест-кейсов может быть сложно, опытный тестировщик легко находит баги таким «свободным поиском», и нередко быстрее, чем «формализованным» способом. 

Отдельный материал по ad-hoc -
https://testengineer.ru/chto-takoe-ad-hoc-testirovanie/



9 - Тестирование совместимости -
Направлено на проверку совместимости продукта с операционными системами, браузерами, сетевыми окружениями, аппаратными конфигурациями, и т.п. Приложение должно работать во всех предусмотренных в его документации окружениях.

Например, Windows-приложение должно быть совместимым со всеми распространенными версиями ОС Windows. Если это веб-приложение, оно должно без проблем открываться во всех распространенных браузерах. Android-приложение нужно протестировать во всех распространенных в данный момент версиях ОС Android.

Подбор устройств для тестирования совместимости -
https://testengineer.ru/compatibility-testing/



10 - Тестирование обратной совместимости -
Проверка того, что новая (обновленная) версия приложения совместима с предыдущими версиями окружения, например операционными системами, в которых работает (или браузерами, в которых открывается веб-приложение).

Часто приложения обновляют, чтобы соответствовать изменившимся стандартам нового окружения, или чтобы «осовременить» общий стиль и вид приложения. Теперь нужно провести тестирование обратной совместимости — ведь пользователи «старой» версии этого окружения, которых может быть очень много, не должны терять возможность пользоваться приложением.



11 - Кроссбраузерное тестирование -
Или тестирование совместимости браузеров. Проверка, может ли веб-приложение (сайт) без проблем открываться во всех распространенных версиях браузеров. 

Такое тестирование, ввиду его трудоемкости, автоматизируют, применяя такие инструменты:

- CrossBrowserTesting -
https://crossbrowsertesting.com/

- LambdaTest -
https://www.lambdatest.com/

- Browsershots -
http://browsershots.org/

- Experitest -
https://experitest.com/

- Turbo Browser Sandbox -
https://turbo.net/browsers

- Ranorex Studio -
https://www.ranorex.com/cross-browser-testing-tools/

- Browsera -
http://www.browsera.com/

Более подробно об этом типе тестирования и об инструментах -
https://testengineer.ru/chto-takoe-kross-brauzernoe-testirovanie/

Большой материал по автоматизации такого тестирования -
https://testengineer.ru/chto-takoe-ad-hoc-testirovanie/



12 - Тестирование производительности -
Оценка общей производительности (продуктивности) приложения, выполняемая как правило при помощи специализированных инструментов, выявляющих проблемы в этой сфере:

- WebLOAD -
https://www.radview.com/

- LoadView -
https://www.loadview-testing.com/

- NeoLoad -
https://www.neotys.com/

- LoadNinja -
https://loadninja.com/

- Appvance -
https://www.appvance.ai/

- LoadRunner -
https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview

- Apache JMeter -
https://jmeter.apache.org/

- Loadster -
https://loadster.app/

- LoadImpact -
https://loadimpact.com/

- Testing Anywhere -
https://testanywhere.co/

- SmartMeter.io -
https://www.smartmeter.io/

- Tricentis Flood -
https://www.tricentis.com/resources/getting-started-with-load-testing-flood-io/

- Rational Performance Tester -
https://www.ibm.com/developerworks/downloads/r/rpt/index.html

- LoadComplete -
https://support.smartbear.com/loadcomplete/docs/index.html


Этой теме посвящен отдельный раздел нашего (бесплатного) Учебника - 
https://testengineer.ru/bolshoj-uchebnik-po-testirovaniyu/#performance

О тестировании веб-сервисов -
http://testengineer.ru/testirovanie-proizvoditelnosti-veb-servisov/



13 - Нагрузочное тестирование -
На систему подается нагрузка в виде запросов/одновременных «пользователей», которая позволяет оценить, какое количество нагрузки система способна обработать до того как начнет ухудшать свою производительность.

Часто применяемые нагрузочные инструменты:

- LoadRunner -
https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview

- WebLoad -
https://www.radview.com/

- JMeter -
https://jmeter.apache.org/

Что такое нагрузочное тестирование -
https://testengineer.ru/nagruzocnoe-testirovanie/

Подробный обзор бесплатных инструментов нагрузочного тестирования -
https://testengineer.ru/besplatnye-instrumenty-dlya-nagruzochnogo-testirovaniya/



14 - Тестирование восстановления -
Проверка, может ли система восстанавливаться после сбоев, и как это происходит — как система возвращается к нормальному функционированию. Понятно, что от сбоев не застрахована ни одна програма — поэтому возможность сбоя должна быть предусмотрена, и проведена соответствующая подготовка. Программный продукт должен восстанавливаться быстро и «без потерь».



15 - Регрессионное тестирование -
Если система корректируется в процессе создания (что неизбежно), если в ее модули/функции вносятся изменения, то обязательно проверяют, не повлияли ли эти правки на функционирование системы.

Что такое регрессионное тестирование? -
http://testengineer.ru/regressionnoe-testirovanie/

Статья о проблемах с «регрессами» -
https://testengineer.ru/kak-uskorit-regress/



16 - Agile-тестирование -
Специфический тип QA-тестирования командой, работающей «по эджайлу», то есть с соблюдением так называемого манифеста Agile - (https://testengineer.ru/qa-junior-middle/#agile-in-simple:~:text=%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D1%85%20%D0%A6%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%D0%B7-,%D0%9C%D0%B0%D0%BD%D0%B8%D1%84%D0%B5%D1%81%D1%82%D0%B0%20Agile,-.), 
и с учетом точки зрения пользователей в первую очередь.

Инструменты Agile QA:

- JIRA -
https://www.atlassian.com/software/jira

- PractiTest -
https://www.practitest.com/

- JunoOne -
https://juno.one/

- VersionOne -
https://www.versionone.com/versionone-vs-atlassian-jira-agile/

- TestRail -
https://www.gurock.com/testrail

- SoapUI -
https://www.soapui.org/



17 - Тестирование API -
Как и юнит-тестирование, этот тип относится к так называемому «code level testing», то есть имеет дело непосредственно с исходным кодом приложения. Разница с юнит- в том, что юнит-тесты обычно делают разработчики, а API тестирует QA-команда.

Гайд по тестированию API -
https://testengineer.ru/testirovanie-api/



18 - Тестирование черного ящика -
Нельзя не упомянуть в общем списке и такой тип. «Тестирование по черному ящику» это проверка функциональности без глубокого ознакомления с техническими «внутренностями» приложения, то есть не зная его исходный код и архитектуру.



19 - Тестирование белого ящика -
Проверка приложения со знанием его исходного кода и архитектуры.

О черном и белом ящиках, которые ждут Junior QA -
https://testengineer.ru/testirovanie-belogo-chernogo-yashchika/



20 - Тестирование безопасности -
Как понятно из названия, такие тесты гарантируют безопасность приложения/сайта; выявляют и предотвращают «дыры» в его подсистеме безопасности. Тестировщики, специализирующиеся на таком тестировании, работают как вручную, так и инструментами:

- Arachni -
http://www.arachni-scanner.com/

- Iron Wasp -
https://ironwasp.org/

- Nogotofail -
https://security.googleblog.com/2014/11/introducing-nogotofaila-network-traffic.html

- SQLMap -
http://sqlmap.org/

- W3af -
http://w3af.org/

- Wapiti -
http://wapiti.sourceforge.net/

- Wfuzz -
http://www.edge-security.com/wfuzz.php

- Zed Attack Proxy -
https://www.zaproxy.org/



21 - Юзабилити-тестирование
Оценка (и последующая коррекция) общего удобства пользования приложением/сайтом. Насколько приложение юзабельно, то есть «дружественно к пользователю»? 

Разумеется, на это нужно смотреть в первую очередь с точки зрения пользователя, а не члена ИТ-команды, и именно массового, «среднего пользователя»; поэтому к тестированию часто привлекают обычных людей-пользователей, «добровольцев» или за оплату. 

Как это делается, и много дополнительной информации по юзабилити, например чеклисты — в нашем большом гайде - 
https://testengineer.ru/usability-testing/
(Artsiom Rusau одобряет - https://t.me/qachanell/1776)



22 - Инструменты проверки юзабилити:

- Optimizely -
https://www.optimizely.com/

- Qualaroo - 
https://qualaroo.com/

- Crazy Egg - 
https://www.crazyegg.com/

- Usabilla - 
https://usabilla.com/

- Clicktale -
https://www.clicktale.com/default.aspx

- Five Second Test -
http://fivesecondtest.com/

- Chalkmark -
https://www.optimalworkshop.com/chalkmark

- UXtweak - 
https://www.uxtweak.com/



23 - Тестирование масштабируемости -
Легко ли масштабировать приложение? То есть, легко ли, и быстро ли, расширяются его возможности в программном и аппаратном измерении? Что произойдет, если количество пользователей, объемы данных, количество транзакций — возрастут в разы? Или десятки, сотни раз.

Тестирование масштабируемости - 
https://testengineer.ru/testirovanie-scalability/



24 - Тестирование надежности -
Насколько приложение надёжное, «выносливое»? Сколько времени оно сумеет проработать «без единого отказа», и при каких условиях происходит отказ? Что провоцирует ошибки в приложении?

Например, нужно не допустить ситуации, когда важная личная информация пользователей хранится в базе данных под управлением нашего приложения, и затем, после нескольких месяцев работы, эта информация удаляется, внезапно и бесповоротно, из-за каких-то ошибок в коде приложения, вовремя не выявленных. Выявлять и устранять подобные ошибки — задача тестирования надежности (reliability testing).

Тестирование стабильности -
https://testengineer.ru/testirovanie-stabilnosti/



25 - Приемочное тестирование -
Компания-клиент, получая готовый программный продукт, проводит приемочное тестирование (User Acceptance Testing = UAT). Оценивает, можно ли принимать софт, исходя из пользовательских требований и предпочтений. Если они не удовлетворены, или если просто клиенту не нравится что-либо в приложении, команде, работавшей над софтом, будет подан запрос на изменения.

Приемочное тестирование -
https://testengineer.ru/uat-testirovanie/



Это не все виды и типы QA-тестирования. Более полно — в нашем Учебнике (там уже более 220 материалов по QA, и мы практически каждый день пополняем его). Как говорят, feel free, не стесняйтесь пользоваться, там удобнее все классифицировано по разделам - 
https://testengineer.ru/bolshoj-uchebnik-po-testirovaniyu/



Подробнее об основных инструментах автоматизации тестирования можно почитать здесь — а также оценить «портрет среднего тестировщика» -
https://testengineer.ru/test-automation-tools/



Подписка на телеграм-канал, посвященный только и исключительно автоматизации QA —
https://t.me/qa_automation_it



Официальный канал TestEngineer -
https://t.me/godoftesting



******************************************

неделя 3 - день 2 (02.09.2025) - 

принципы тестирования -
https://crashtest.by/7-principles-of-testing/


7 принципов тестирования - 



1 - исчерпывающее тестирование невозможно -
Невозможно, либо нецелесообразно тестировать все возможные варианты и комбинации значений. Поэтому в тестировании мы используем анализ рисков и приоритетов, для того чтобы проверить наиболее показательные варианты значений. Для этого существуют техники тестирования (Test techniques), либо их ещё называют техники тест-дизайна (Test design techniques).



2 - принцип скопления дефектов -
В наименьшем количестве мест, находится наибольшее количество дефектов. Это чем-то похоже на правило Парето 80/20, где 80% дефектов находятся в 20% функций.



3 - эффективность раннего тестирования -
Активности по тестированию должны начинаться как можно раньше в жизненном цикле нашего продукта. Ведь чем позже мы нашли проблему, тем дороже её будет исправить. Мы должны делать сильный упор на статическое тестирование и верификацию, чтобы найти проблемы на ранних этапах и исправить их как можно раньше. Такой подход называется “Shift-Left”.



4 - парадокс пестицида -
Если одни и те же тесты проходить снова и снова, то рано или поздно они перестанут находить дефекты. То есть, наш продукт со временем адаптируется к нашим тестам.

Для того, чтобы избежать таких ситуаций рекомендуется следующее:
- Использовать разные данные при тестировании
- Постоянно пересматривать и улучшать свои тесты
- Добавлять новые тесты
- Использовать разные техники тестирования
- Проводить ротацию кадров

Неформальные техники тестирования основанные на опыте (например, исследовательское (Exploratory testing) и свободное тестирование (Ad-hoc)) очень хорошо помогают бороться с парадоксом пестицида.



5 - заблуждение об отсутствии ошибок -
Сколько бы мы не находили ошибок, это не даст нам гарантию того, что мы нашли их все или что продукт будет качественным. Продуктов без багов (Bug free) не существует!

Поэтому задача тестирования состоит не в нахождении всех дефектов, а нахождении наиболее важных дефектов до того, как их найдут пользователи. Да, при этом ещё и не забывая про верификацию и валидацию - 
https://crashtest.by/verification-vs-validation/

Даже если наш продукт соответствует всем требованиям, он может быть неприменим конечными пользователями из-за того, что у нас есть проблемы в требованиях или дизайне. Именно поэтому мы много времени уделяем раннему тестированию, верификации и статическому тестированию - https://crashtest.by/verification-vs-validation/


К тому же, уверены ли вы, что в вашем продукте нет нефункциональных багов? Например, удобства использования, производительности, совместимости, безопасности и так далее.



6 - тестирование показывает наличие дефектов - 
Тестирование может показать, что в нашем продукте есть дефекты, но не может доказать, что ошибок нет. Ведь они есть всегда

Этот принцип как раз и говорит, что тестирование напрямую не улучшает качество, а лишь показывает, что в продукте есть дефекты. Это помогает сделать качество лучше тем, что мы знаем о проблемах и можем их исправить. А вот уже улучшением качества может заниматься Quality Assurance -
https://crashtest.by/quality-assurance-vs-quality-control-vs-testing/



7 - тестирование зависит от контекста -
Не существует единственного верного способа тестировать программное обеспечение. Вряд ли систему контроля жизнеобеспечения мы будем тестировать как интернет-магазин. Даже 2 очень похожих интернет-магазина могут тестироваться совсем по-разному. Ведь контекст может быть разный.


Что может входить в контекст тестирования:

- Тип продукта — веб, десктоп, мобайл, сервис и тд

- Цель продукта — продажа товаров, игра, обеспечение безопасности

- Проектная команда — количество человек, специализация, опыт и тд

- Сроки — как много времени у нас есть до релиза

- Ожидаемый уровень качества — чем выше показатель, тем тщательнее нужно тестировать

- Риски — существует огромное число рисков, которые нужно учитывать. Например, из-за того, что команда неопытная в разработке продукта с заявленными целями и типом, есть риск, что в продукте может быть много багов. Тем самым, достижение ожидаемого уровня качества может затянуться.

- Доступные инструменты — есть ли у нас возможность пользоваться какими-то инструментами для тестирования или необходимо изобретать самим.

- И другие моменты


Исходя из данных нашего контекста, мы и будем строить эффективный процесс тестирования.



******************************************

неделя 3 - день 3 (03.09.2025) - 

виды тестовой документации -
https://testengineer.ru/chto-takoe-testovaya-dokumentaciya-i-zachem-ona-nuzhna/ 

Тестовая документация — это набор документов, создаваемых перед началом процесса тестирования и непосредственно в процессе. Эти документы описывают покрытие тестами и процесс выполнения тестов, в них указываются необходимые для тестирования вещи, приводится основная терминология и т. д. 

В тестовой документации любой член команды может найти полную информацию обо всех действиях, связанных с тестированием (и об уже выполненных, и о запланированных).

Тестовая документация определяет, что для нас важно и почему, какие действия мы должны выполнить и сколько времени у нас есть. Наконец, в документации обозначено, чего должна достичь команда и что сигнализирует об окончании процесса.



Какую тестовую документацию используют QA-команды? -
Наиболее часто используемые документы — это планы тестирования, чеклисты, тест-кейсы, сценарии использования, баг-репорты и спецификации требований:

1 - План тестирования (test plan) -
План тестирования описывает все действия по тестированию в рамках одного проекта. Здесь вы можете найти информацию обо всем, что нужно сделать тестировщику или команде QA в ходе проекта. В каждом плане тестирования указывается объект тестирования, график работы, критерии начала и окончания тестирования, стратегия, риски и список выполненных работ.

2 - Чеклист (checklist) -
Чеклист — это документ, содержащий краткое описание функций, которые должен проверить тестировщик. Выглядит чеклист как список функций с указанием статуса — результата проверки. Чеклисты могут использоваться вместо тест-кейсов, поскольку их легче подготовить. Но если вам нужно более конкретное описание процедуры, без тест-кейсов не обойтись.

3 - Тест-кейс (test case) -
В тест-кейсе содержатся:
- подробное описание шагов и действий, которые тестировщик должен выполнить для тестирования какой-то одной части функционала,
- критерии  прохождения тестов. 
Компании могут использовать разные форматы тест-кейсов, но информация в них всегда очень подробная и конкретная.

4 - Сценарий использования (use case) -
Use case — это более простой и менее официальный документ. Он описывает сценарий взаимодействия с программным обеспечением. Каждый юзкейс основан на предположении о том, что пользователь программы будет делать и где он будет кликать. Это позволяет тестировщикам протестировать предполагаемые пути пользователя. При создании юзкейсов тестировщики учитывают требования и бизнес-цели.

5 - Баг-репорт -
Баг-репорт предоставляет полную информацию о баге (его описание, серьезность, приоритет и т. д.) и документирует шаги и условия для воспроизведения этого бага. Подробный и эффективный баг-репорт значительно увеличивает шансы быстро исправить баг.

6 - Требования (requirements specification) -
Спецификация требований или просто требования — это полное описание разрабатываемого программного обеспечения. В требованиях указываются свойства, качества и особенности разрабатываемой программы. Используя эту информацию, команды могут избежать недоразумений и разногласий.



Как все это работает? -
Документы бывают высоко- и низкоуровневые. Все тестировщики могут составлять чеклисты, тест-кейсы и баг-репорты. Это часть их повседневных обязанностей. А вот подготовка плана тестирования требует дополнительных навыков и опыта. Это задача для опытного специалиста или QA Lead. Чем крупнее проект, тем больше документации нужно. Если команда использует для сложного продукта только чеклисты, есть риск неправильного понимания приоритетов и проведения неэффективных тестов. Причина кроется в отсутствии деталей. Чеклист только называет функцию, и каждый тестировщик может интерпретировать объект тестирования и результаты по-своему. Тестовая документация динамична. Она эффективна только в том случае, если команда QA регулярно ее обновляет. 
Если документацию заводят только «чтобы было», никакого смысла в ней нет. В ходе тестирования могут меняться требования и приоритеты. Это влияет на покрытие тестами, необходимые ресурсы и т. д. Если команда не записывает изменения, в результате получаются неэффективные документы и непоследовательность в работе. Аналогично, со временем устаревают и теряют свою актуальность тест-кейсы и сценарии использования. Может появиться новый функционал, который тоже нужно покрыть тестами. И если вы не будете все тщательно записывать, вы рискуете получить бесполезную документацию.



Каждая компания сама определяет, стоит ли создавать тестовую документацию. QA-специалисты могут рекомендовать клиентам это сделать, но последнее слово остается за клиентами. Что касается преимуществ документирования рабочего процесса, то они вполне очевидны. Описанные нами документы помогают упорядочить имеющуюся информацию. Благодаря этому даже новичок в команде сможет легко разобраться, что к чему.



******************************************

неделя 3 - день 4 (04.09.2025) - 

пирамида тестирования -
https://habr.com/ru/articles/672484/

Пирамида тестирования, также часто говорят уровни тестирования, это группировка тестов по уровню детализации и их назначению. Эту абстракцию придумал Майк Кон и описал в книге «Scrum: гибкая разработка ПО» (Succeeding With Agile. Software Development Using Scrum).

Пирамиду разбивают на 4 уровня (снизу вверх), например, по ISTQB:
- модульное тестирование (юнит);
- интеграционное тестирование;
- системное тестирования;
- приемочное тестирование.

Но можно встретить варианты, где 3 уровня. В этой модели объединяют интеграционный и системный уровни:
- модульное тестирование (юнит);
- интеграционное тестирование (включает в себя системное);
- приемочное тестирование.

Важно отметить:
1 - Тест (ручной, на высоких уровнях, или автотест, на низких уровнях), должен быть на том же уровне, что и тестируемый объект. Например, модульный тест (проверяющий функции, классы, объекты и т.п.) должен быть на компонентном уровне. Это неправильно, если на приемочном уровне запускается тест, который проверят минимальную единицу кода.
2 - Тесты уровнем выше не проверяют логику тестов уровнем/уровнями ниже.
3 - Чем выше тесты уровнем, тем они:
- сложней в реализации, и соответственно, дороже в реализации;
- важнее для бизнеса и критичней для пользователей;
- замедляют скорость прохождения тестовых наборов, например, регресса.



Компонентный уровень - Чаще всего называют юнит тестированием. Реже называют модульным тестированием. На этом уровне тестируют атомарные части кода. Это могут быть классы, функции или методы классов.

Юнит тесты находят ошибки на фундаментальных уровнях, их легче разрабатывать и поддерживать. Важное преимущество модульных тестов в том, что они быстрые и при изменении кода позволяют быстро провести регресс (убедиться, что новый код не сломал старые части кода).

Тест на компонентном уровне:
- Всегда автоматизируют.
- Модульных тестов всегда больше, чем тестов с других уровней.
- Юнит тесты выполняются быстрее всех и требуют меньше ресурсов.
- Практически всегда компонентные тесты не зависят от других модулей (на то они и юнит тесты) и UI системы.

В 99% разработкой модульных тестов занимается разработчик, при нахождении ошибки на этом уровне не создается баг-репортов. Разработчик находит баг, правит, запускает и проверяет (абстрактно говоря это разработка через тестирование) и так по новой, пока тест не будет пройден успешно.

На модульном уровне разработчик (или автотестер) использует метод белого ящика. Он знает что принимает и отдает минимальная единица кода, и как она работает.



Интеграционный уровень - Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.

В случае с интеграционными тестами редко когда требуется наличие UI, чтобы его проверить. Компоненты ПО или системы взаимодействуют с тестируемым модулем с помощью интерфейсов. Тут начинается участие тестирования. Это проверки API, работы сервисов (проверка логов на сервере, записи в БД) и т.п.

В интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.

В интеграционном тестировании есть 3 основных способа тестирования (представь, что каждый модуль может состоять еще из более мелких частей):

- Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и протестируем взаимодействие загрузчика и публикатор.

- Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются.Например, проверяем работу загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы было обработано компрессором.

- Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.



Системный уровень - О системном уровне говорили в интеграционном. Тут отметить только то, что:
- Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
- Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.

Тест-кейсы на этом уровне подготавливаются:
- По требованиям.
- По возможным способам использования ПО.

На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.

На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить соответствие ПО прописанным требованиям).



Приемочное тестирование - Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).

Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных способах использования ПО.

Отмечу, что приемочные тесты проводят, когда -
1 - продукт достиг необходимо уровня качества и 
2 - заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).

Приемку проводит либо внутреннее тестирование (необязательно тестировщики) или внешнее тестирование (сам заказчик и необязательно тестировщик).

Важно помнить, что E2E тесты автоматизируются сложнее, дольше, стоят дороже, сложнее поддерживаются и трудно выполняются при регрессе. Значит таких тестов должно быть меньше.



******************************************

неделя 3 - день 5 (05.09.2025) - 

тест-дизайн -
https://www.youtube.com/playlist?list=PLQk3Rj0ZoUb56N8o1qDlYUaW65hYiqclw

1 - 
https://youtu.be/7HqVX66WMho?si=5bfExrwKdPC3ECFD
- классы эквивалентности 

складываем разные числа на калькуляторе (отрицательные числа - это уже другой класс эквивалентности)

разбивка на классы эквивалентности сильно сокращает количество проверок 

есть риск что какие то ошибки мы пропустим, но вероятность этого очень низкая 

исчерпывающее тестирование невозможно 

от 0 до 100 - True - тут классы эквивалентности - 
- числа от 0 до 100
- числа меньше нуля 
- числа больше 100 
- буквы и слова 
- спецсимволы, знаки препинания 
- ничего не ввели 

- тут достаточно проверить одно значение для каждого класса 



2 -
https://youtu.be/kQTwg8pCd1M?si=q6FtKvU0--EC48q2
- граничные значения 

техника граничных значений - используется вместе с техникой эквивалентности 

проверка возраста - до и после 14 лет (граничное значение здесь - 14)
- до 14 - паспорта нет 
- после 14 - паспорт есть 

на граничных значениях скапливается самое большое количество багов 

проверять нужно на 1 меньше от границы и на 1 больше от границы, и само граничное значение 

от 0 до 100 (пример выше) - два граничных значения, 0 и 100 - нужно проверять - -1, 0, 1, 99, 100, 101  



3 - 
https://www.youtube.com/watch?v=TDT38dKJzsU&list=PLQk3Rj0ZoUb56N8o1qDlYUaW65hYiqclw&index=3&pp=iAQB
- техника переходов состояний

техника переходов состояний - когда есть несколько состояний системы и нужно отследить каждое -
- сообщение отмечены непрочитанными 
- после клика пользователя сообщения отмечены прочитанными 
- пользователь может отметить прочитанное сообщение как непрочитанное 
- пользователь может удалить сообщение (как прочитанное, так и непрочитанное)
- после удаления вернуть сообщение нельзя 

выписать 3 состояния письма, и показать стрелочками из какого в какое состояние возможен переход - 
- непрочитанное 
- прочитанное 
- удаленное 

тестами проверить что где есть стрелочки переход возможен, а где стрелочек нет - переход невозможен 

таблица переходов - показана в видео - 4:30



4 - 
https://www.youtube.com/watch?v=C14v2hfRnNQ&list=PLQk3Rj0ZoUb56N8o1qDlYUaW65hYiqclw&index=4&pp=iAQB
- таблица принятия решений 

таблица - показана в видео - 0:30

таблица - 
--------------------------------------------
| условия  | варианты выполнения действий  |
--------------------------------------------
| действия | необходимость действий        |
--------------------------------------------

условия - в виде вопросов, на которые нужно ответить ДА или НЕТ -
- поле заполнено верно?
- размер файла до 10Гб?
- картинка формата .jpg?
- поле заполнено? 

условия (по логину и паролю) - 
- поле Логин заполнено?
- поле Логин заполненно корректно?
- поле Пароль заполнено?
- поле Пароль заполненно корректно?

действия -
- авторизация успешна 
- не заполнены обязательные поля 
- неверно введен логин или пароль

таблица - варианты выполнения условий - показана в видео - 02-45

итоговая таблица - показана в видео - 04-00



5 -
https://www.youtube.com/watch?v=aWLIPGpf62A&list=PLQk3Rj0ZoUb56N8o1qDlYUaW65hYiqclw&index=5&pp=iAQB0gcJCcYJAYcqIYzv
- попарное тестирование 

попарное тестирование используется когда нужно проверить много сценариев 

наиболее критичные баги находятся при сочетании 2-х параметров 

если у нас 10 параметров, нужно проверить их, не все со всеми, а попарно, разбить на 5 пар и проверить 

пример разбивки на пары - в видео - с 02-10



******************************************

неделя 3 - день 6 (06.09.2025) - 

работа с требованиями -
https://habr.com/ru/articles/543340/

Когда разрабатывается новая функциональность системы, аналитик пишет требования, а тестировщик их проверяет. До того, как начать реализацию. Потому что на этом этапе внести исправления дешевле всего.

Вот только на что обращать внимание при тестировании? Есть набор основных характеристик, которыми должна обладать хорошая документация:
1 - Полнота
2 - Однозначность
3 - Непротиворечивость
4 - Необходимость
5 - Осуществимость
6 - Тестируемость



1 - Полнота -
Все ли описано? Ничего не забыли? Вдруг у нас остался неописанный функционал или параметр API-метода?

Чтобы проверить этот пункт, просто напишите чек-лист проверок функционала. Вот как начали читать ТЗ, сразу записывайте тесты. Важно именно писать, а не просто прикидывать в уме. Иначе что-то обязательно забудете.

Написать тесты — это дольше, чем просто прочитать документацию. Но зато вы экономите время потом, ведь чек-лист уже готов, бери да проверяй!



2 - Однозначность -
Требования должны трактоваться всеми одинаково.
«Отчет должен загружаться быстро» → что значит «быстро»?
- пользователь будет уверен, что страница будет грузиться доли секунды, даже если это сложный отчет на многомиллионных данных;
- разработчик прикинет, что в таких объемах 5 секунд нормальное время отклика, даже быстрое.

Налицо конфликт интересов. И ведь каждый будет тыкать в ТЗ для отстаивания своей позиции. Лучше конкретизировать:
- Отчет за год должен загружаться не более секунды.
- Отчет за весь период времени должен загружаться не более 5 секунд.

Если в требованиях не указано, что у нового поля с суммой дохода должно быть значение по умолчанию:
- Аналитик будет думать, что там будет значение 0. Деньги же, цифра!
- Разработчик сделает пустое поле, не указано ведь ничего! А это что-то сломает...

Если в требованиях не указано, как обработать ошибочный сценарий, разработчик может:
- Не подумать о нем и никак не обработать — пользователь может огрести страшную ошибку.
- Подумать о нем и обработать так, как считает правильным — а тестировщик потом будет доказывать, что надо было делать по другому. Пойдут к аналитику, потратят и его время тоже, а потом еще код переделывать...

Все, что можно прочитать двояко, лучше исправить. Это не значит, что нужно описывать каждую мелочь, но всё зависит от читателей документа.

Если это внутренний документ, а у вас сильная команда — можно не расписывать подробно.

Если этот документ отправят заказчику, надо расписать вообще всё — потому что у заказчика свои тестировщики, и они обязательно зададут кучу «а что, если...?». Если они хорошие тестировщики, разумеется. Это вы знаете свою программу и представляете, как она реагирует на ошибки или что-то такое. Тестировщик заказчика этого не знает, он будет уточнять.



3 - Непротиворечивость -
Требования не должны противоречить сами себе. Такое обычно бывает, когда требований много. Аналитик просто забывает, что уже писал про параметр и снова придумывает его поведение. Иногда придумывает немного по другому.

Например, есть страница нефункциональных требований, где написано, что любая страница должна грузится не более 3 секунд. Аналитик пишет ТЗ на новый модуль отчетности, который использует много данных и сложные формулы. И он пишет, что отчет может грузиться вплоть до минуты. Явное противоречие!

Если заказчик найдет первый раздел документации, он будет требовать именно такую скорость. И будет прав, кто же хочет ждать?



4 - Необходимость -
Помните главный принцип: «Кратко, но емко»? Он действует и в документации тоже.

Круто, когда документация полная. Но это не значит, что простой функционал надо растечь на 10 листов А4. Когда документации много, сложно проверить полноту, сложно удержать в голове, о чем уже говорил, не повторяться и не противоречить самому себе.

Подумайте, так ли уж нужно описывать каждую кнопочку интерфейса? Это правда актуально? Пользователи правда не догадаются, что фильтры по строковым колонкам работают одинаково?

Пишите только то, что необходимо:
- В ТЗ — функционал, основной сценарий и альтернативы, типы ошибок.
- В пользовательской документации — то, как пользоваться системой. Но не доходя до крайностей и обучения включению компьютера.



5 - Осуществимость -
А можно ли реализовать то, что тут написано? Насколько это будет сложно и дорого?

Этот пункт обычно проверяют разработчики. Они остужают буйные фантазии из серии «загружать миллионы данных за 0,1 секунду» или что-то архитектурно сложное. Бывает такое, что на бумаге всё звучит просто, а вот сделать это займет человеко-месяц в лучшем случае.



6 -  Тестируемость -
Можно ли протестировать этот функционал?

Подумайте об этом заранее. А то бывает так, что разработчик уже всё сделал, и тут только тестировщик понимает, что  задачу никак нельзя проверить. Или можно проверить вручную, но нельзя написать автотесты, фреймворк под новый функционал не заточен.

Если в компании принято все покрывать автотестами, то это станет проблемой. Может, разработчик прочитает ТЗ и сам поймет, что ещё фреймворк тестов дорабатывать надо. А может, он не вспомнит об этом. И тогда ваша задача — вспомнить. Чтобы сразу заложить время на доработки.

У меня бывали ситуации, когда мы делали задачу в текущем релизе, а потом ставили новую «Доработать фреймворк автоматизации, чтобы поддержать изменения» в следующий. Иногда забывали про фреймворк, а потом времени в релизе уже не оставалось. А иногда сразу понимали, что всё сразу сделать не успеем.

Хотя лучше об этом помнить сразу, иначе велик шанс, что тестировать за вас придется разработчику. Или половину проверок переносить на следующую итерацию, что тоже не очень хорошо.

При этом бывает и так, что тестировать все равно придется разработчику. Скажем, когда делают рефакторинг, что может проверить тестировщик? Только регресс провести, посмотреть, что ничего не отломалось. А если есть автотесты, то это проверят они =)

Однако если тесты (авто или ручные) прошли успешно, это ещё не значит, что рефакторинг прошел хорошо. Сама суть рефакторинга — переписать код, чтобы он был более оптимален и читабелен. Чтобы его было легче поддерживать в дальнейшем и интегрировать с другими частями системы.

И именно это и надо проверить! А проверить это может только разработчик. Он и выполняет тестирование в данном случае.



******************************************

неделя 3 - день 7 (07.09.2025) - 

жизненный цикл тестирования -
https://testengineer.ru/zhiznennyj-cikl-testirovaniya-prilozhenij/

STLC, или жизненный цикл тестирования — это последовательность действий, проводимых в процессе тестирования, с помощью которых гарантируется качество программного обеспечения и его соответствие требованиям. STLC включает действия по верификации и валидации. Тестирование состоит из серии действий, выполняемых по методике, с целью гарантирования качества продукта.

Этапы STLC-цикла - Цикл состоит из шести основных этапов:
1 - Анализ требований
2 - Планирование тестирования
3 - Создание тест-кейсов
4 - Настройка тестового окружения
5 - Выполнение тестирования
6 - Завершение цикла тестирования



Какие критерии начала и завершения STLC-цикла? -
- Критерий начала: описывает условия, которые должны быть соблюдены перед тем как начнется тестирование.
- Критерий завершения: описывает условия, которые должны быть соблюдены перед тем как тестирование завершится.

Есть критерии начала и завершения для всех этапов STLC.

В идеальном мире следующий этап не может начаться, пока не выполнены критерии по предыдущему этапу. На практике такое иногда не всегда возможно. 



1 - Анализ (оценка) требований
Этап оценки требований (анализа требований). На этом этапе QA-команда оценивает требования с точки зрения тестирования. Для этого QA-команда может обращаться к представителям заказчика. Требования могут быть «функциональными» или «нефункциональными», то есть касаться или не касаться функциональной составляющей софта. Также на этом этапе проводится оценка возможности применения автоматизированного тестирования (https://testengineer.ru/chto-takoe-avtomatizirovannoe-testirovanie/).

Действия на этапе оценки требований -
- Определение типов тестирования
- Сбор информации о приоритетах в тестировании
- Подготовка матрицы отслеживания требований (RTM — Requirement Traceability Matrix)
- Определение тестового окружения
- Анализ возможности автоматизации тестирования (если нужно)

Результаты этапа оценки требований
- Матрица отслеживания требований (RTM)
- Отчет о возможности автоматизации (если нужно)



2 - Планирование тестирования
На этапе планирования руководитель команды QA определяет стратегию тестирования и оценивает трудозатраты. Также оцениваются ресурсы, тестовое окружение, возможные ограничения и график тестирования. На этом же этапе готовится и финализируется план тестирования.

Действия на этапе планирования -
- Подготовка стратегии (или плана тестирования)
- Выбор инструментов тестирования
- Оценка трудозатрат
- Планирование ресурсов, определение ролей и ответственности
- Дополнительное обучение команды (если нужно)

Результаты -
- Документ со стратегией тестирования
- Документ с оценкой ресурсов



3 - Этап создания тест-кейсов
На этом этапе происходит подготовка тестовых данных и создаются тест-кейсы.

Действия -
- Создание тест-кейсов (и автотестов, если будет применяться автоматизация)
- Подготовка исходных данных для тестирования

Результаты -
- Тест-кейсы и/или скрипты
- Тестовые данные



4 - Настройка тестового окружения
Это настройка харда и софта, в которых будет осуществляться процесс тестирования. Это один из критически важных аспектов процесса, он может проходить параллельно этапу создания тест-кейсов. QA-команда может и не включаться в этот процесс, если тестовое окружение ей обеспечит команда разработки. QA-команда должна будет проверить работоспособность окружения (хотя бы smoke-тестом).

Действия -
- Понять нужную архитектуру, настройки окружения и подготовить список требований к харду и софту
- Настроить тестовое окружение и тестовые данные
- Провести smoke-тест окружения

Результаты -
- Настроенное окружение для проведения тестирования
- Результаты smoke-тестирования окружения



5 - Этап выполнения тестов
На этапе выполнения тестов QA проводит тестирование, выполняя подготовленные тест-кейсы. Процесс состоит из выполнения тестовых скриптов (при необходимости эти скрипты могут корректироваться). Далее идет создание баг-репортов. Если найдены баги, информация о них передается команде разработки для исправления и повторного тестирования QA-командой.

Действия -
- Выполнение тестирования в соответствии с планом
- Получение результаты тестирования
- Обновление RTM-матрицы (тест-кейсы из RTM-матрицы связываются с найденными багами)
- Повторное тестирование исправленных багов

Результаты -
- Завершенная RTM-матрица
- Обновленные тест-кейсы
- Найденные и описанные баги



6 - Завершение тестирования
На этапе завершения тестирования создается отчет о результатах тестирования. QA-команда обсуждает и анализирует баги, делает выводы из возникших проблем, чтобы избежать подобных проблем в будущем.

Действия -
- Оценка критериев завершения цикла (основывается на времени, трудозатратах, покрытии тестами)
- Подготовка документа с выводами, сделанными во время тестирования
- Подготовка отчета о завершении тестирования
- Подготовка отчета для клиента с количественными и качественными характеристиками тестируемой системы
- Анализ результатов тестирования

Результаты -
- Отчет о завершении тестирования



ТАБЛИЦА - 



1 этап -
Анализ требований

Критерии входа -
— Есть документ о требованиях (как функциональных, так и нефункциональных).
— Описаны критерии приемлемости.
— Есть документ, описывающий архитектуру приложения.

Действия -
— Анализ планируемой функциональности приложения.
— Определение ролей пользователей.
— Сбор требований о пользовательских интерфейсах, аутентификации, локализации и других особенностях.
— Определение типов тестирования, которые будут проводиться.
— Сбор информации о приоритетах тестирования.
— Создание RTM-матрицы (матрицы отслеживания требований).
— Определение тестового окружения, в котором будет проводиться тестирование.
— Анализ возможности автоматизации (если нужно).
	
Критерии выхода -
— Заполнена RTM-матрица.
— Подготовлен и согласован отчет о возможности автоматизации.

Результаты -
— RTM-матрица.
— Отчет о возможности автоматизации (если нужно).



2 этап -
Планирование

Критерии входа -
— Есть документы с требованиями.
— Есть RTM-матрица.
— Есть документ о возможности автоматизации тестирования.

Действия -
— Анализ возможности различных методов тестирования.
— Финализация наиболее подходящего метода тестирования.
— Подготовка документа со стратегией/планом тестирования
— Подбор инструментов тестирования.
— Оценка трудозатрат.
— Планирование ресурсов и определение ролей и ответственности.
	
Критерии выхода -
— Готов и согласован документа со стратегией тестирования.
— Одобрен документ по оценке трудозатрат.

Результаты -
— Документ со стратегией тестирования.
— Документ с оценкой трудозатрат.



3 этап -
Создание тест-кейсов

Критерии входа -
— Есть документы с требованиями.
— Есть RTM-матрица и план тестирования.
— Есть отчет о возможности автоматизации.

Действия -
— Создание тест-кейсов, автоматизированных тестов (если нужно).
— Обновление тест-кейсов и автоматизированных тестов.
— Создание тестовых данных.
	
Критерии выхода -
— Готовы тест-кейсы и скрипты.
— Готовы тестовые данные.

Результаты -
— Тест-кейсы и скрипты.
— Тестовые данные.



4 этап -
Настройка тестового окружения

Критерии входа -
— Готовы документы по дизайну системы и ее архитектуре.
— Есть план по настройке окружения.

Действия -
— Оценка архитектуры.
— Настройка окружения.
— Создание списка требований к аппаратной и программной части окружения.
— Финализация требований к качеству.
— Подготовка задач по настройке окружения.
— Настройка тестового окружения.
— Подготовка и проведение smoke-тестов билда приложения.
	
Критерии выхода -
— Окружение работает согласно списка требований.
— Завершена подготовка тестовых данных.

Результаты -
— Готовое окружение



5 этап -
Выполнение тестирования

Критерии входа -
— Есть базовая RTM-матрица, план тестирования, тест-кейсы и/или автоматизированные скрипты.
— Готово тестовое окружение.
— Завершена настройка тестовых данных.

Действия -
— Выполнение тестов.
— Документирование результатов тестирования.
— Создание баг-репортов.
— Обновление тест-плана и тест-кейсов (если нужно).
— Обновление RTM-матрицы.
— Повторное тестирование проблемных мест.
— Регрессионное тестирование приложения.
— Отслеживание проблемных мест, до закрытия тестирования.
	
Критерии выхода -
— Все запланированные тесты проведены.
— Созданы баг-репорты.

Результаты -
— Полностью заполненная RTM-матрица.
— Обновленные по результатам тестирования тест-кейсы.
— Баг-репорты



6 этап -
Завершение тестирования

Критерии входа -
— Тестирование завершено.
— Есть результаты тестирования.
— Есть баг-репорты.

Действия -
— Оценка цикла на основе времени, покрытии тестами, трудозатрат.
— Подготовка метрик тестов.
— Подготовка документа с итогами проекта.
— Подготовка отчета о завершении тестирования.
— Подготовка отчета о качестве продукта.
— Анализ результатов тестирования.
	
Критерии выхода -
— Отчет о завершении тестирования утвержден клиентом.

Результаты -
— Отчет о завершении тестирования.
— Метрики тестов.



******************************************

неделя 4 - день 1 (08.09.2025) - 

багрепорт - 
https://habr.com/ru/articles/156099/

Правила оформления записей в баг-трекере в каждой компании свои — это зависит как от политики компании, технологии разработки, используемного баг-трекера, типа проекта и много чего еще. Но в любом случае хороший баг-репорт обладает определенными характеристиками.

Если кратко, то хороший баг-репорт позволяет:
1. воспроизвести проблему (это не всегда возможно, но надо стремиться).
2. понять, в чем проблема и какова ее важность.

Как написать хороший баг-репорт?
Для начала надо подготовиться. Если вы обнаружили баг, не стоит моментально бежать в баг-трекер и писать «ничего не работает!». Воспроизведите ошибку. Воспроизвелась? Отлично. Не воспроизвелась? Значит, что-то вы не учли. Вспоминайте, что делали.

Снова воспроизвелась? Ура! А теперь минимизируйте количество шагов для воспроизведения, удостоверьтесь, что нет ничего лишнего.

Если используются какие-то входные данные, удостоверьтесь, что и они не содержат лишнего (действительно ли весь этот здоровенный кусок текста роняет редактор, а не один символ из него?).

Когда вы поняли, какие именно данные и какие ваши действия приводят к проблеме, кратко сформулируйте ее суть — придумайте заголовок баг-репорта. Опишите проблему настолько подробно и конкретно, насколько позволяет заголовок, при этом не увлекаясь его длиной

Пример плохого заголовка: 
«Все виснет, когда я вставляю текст из буфера обмена»

Пример «более хорошего» заголовка: 
«Редактор зависает при вставке текста, содержащего символ N, из буфера обмена по Ctrl+V»

Можно еще упомянуть принцип «Что? Где? Когда?». В большинстве случаев это помогает написать удачный заголовок/подробное описание, Например - 
- Что: неправильный расчет данных
- Где: на странице NNN
- Когда: после ввода а поле Y отрицательного значения.

Старайтесь не писать фразы типа «я кликаю на ссылку», «я нажимаю кнопку» и им подобные. И заголовок, и описания шагов — это руководство к действию для тех, кто будет исправлять проблему, поэтому лучше формулировать как «кликнуть на ссылку», «нажать на кнопку».

Теперь откройте баг-трекер, начните заполнять форму баг-репорта.
Запишите заголовок.

В каких-то баг-трекерах поля «Подробное описание» и «Шаги для воспроизведения» различаются, в каких-то — нет.

Если поле «Подробное описание» есть, опишите в нем проблему более подробно — уточните те детали, которые пришлось опустить в заголовке. Если вы понимаете, в чем причина проблемы (используется устаревшая формула для расчетов, не учитывается какое-то значение и т.д.) — тоже пишите все здесь. Если не знаете — лучше не гадайте.

Если в форме записи об ошибке нет отдельного поля Affect version (версия продукта, в котором проявляется проблема), то укажите версию здесь.

«Шаги для воспроизведения» — основное поле для заполнения в баг-репорте.
Запишите шаги, которые вы определили. Как уже было сказано, шагов должно быть необходимо и достаточно для воспроизведения проблемы. Лишние не пишите. Необходимых тоже не пропускайте

После описания шагов обязательно напишите результат — что получилось.
Далее здесь же опишите ожидаемый результат, если это необходимо. Конечно, не стоит писать «Редактор не падает», но если, например, результаты расчетов не соответствуют ожидаемым, то это надо указывать.

Таким образом, описание шагов для воспроизведения должно выглядеть как-то так:
Шаги для воспроизведения:
1. Открыть…
2. Кликнуть…
3. Ввести в поле… значение N1
4. Ввести в поле… значение N2
4. Кликнуть кнопку Calculate

Результат:
В поле Result отображается V1.

Ожидаемый результат:
В поле Result отображается V2.



Если требуются исходные файлы, данные, дампы и пр. — сразу приаттачьте. Само собой, файлы должны содержать только информацию, необходимую для воспроизведения ошибки. Подчистите все лишнее.

Если проблема с визуальным отображением, то скриншот обязателен — можно будет понять ошибку и без воспроизведения шагов. На скриншотах лучше указывать место с ошибкой. Стрелочкой или просто полосой контрастного цвета. Здорово ускоряет «чтение» скриншота.

Но вставлять скриншоты в каждый баг-репорт совершенно не обязательно: пожалуйста, не плодите лишних сущностей. Если он ничем не поможет в воспроизведении проблемы — не тратьте время на его изготовление.

Кстати, про видео воспроизведения ошибки: оно может помочь разве что для подтверждения, что проблема действительно есть, просто воспроизвести ее сложно. Но часто ли вы делаете запись экрана заранее?



По остальным полям -



- Severity, Priority.
Наличие этих полей и значения в этих полях отличаются от багтрекера к багтрекеру.

Severity — это критичность бага с точки зрения тестировщика: фича, опечатка в тексте, мелкая проблема, значительная проблема, падение продукта, блокирующая проблема и пр.

Priority — приоритет, с которым проблема должна быть исправлена.
Если есть оба поля, то тестировщик, как правило, выставляет только Severity, а Priority — старший тестировщик/старший программист/менеджер или любой другой ответственный за это дело человек.

Если есть только одно поле, то выставляем его.

«Какой приоритет ставить багу?» На этот вопрос нет однозначного ответа, все зависит от каждого конкретного случая. Но старайтесь не увлекаться и не ставить всем багам подряд высокий или критичный приоритет, реально оценивайте их критичность для проекта.



Environment — есть во всех баг-трекерах. Это программно-аппаратное окружение, в котором проявляется проблема.

Укажите версию операционной системы, наличие сервис-паков, разрядность.
Если ваш проект зависит от каких-то компонентов — их наличие и версии обязательно! .NET, JRE/JDK и прочие SDK.

Интерпретируемый язык? Версию интерпретатора — обязательно!

Для веб-проектов — браузер, установленные плагины, если это влияет на работу проекта. Если что-то не работает в одном браузере, то проверьте, работает ли в остальных.

В какой версии исправить, на кого назначить — зависит от политики внутри компании. Не знаете, что поставить? Спросите коллегу.



Я разделил пункт на «affect version» и «environment» -
- affect version — версия тестируемой программы
- environment — версия окружения, железа.



Систем, которые выполняют подобные функции и стоят копейки или даже бесплатно — кучи — JIRA, BaseCamp, HollyTask. Вот даже тут почитать: www.hollytask.com/ru_bugreport



******************************************

неделя 4 - день 2 (09.09.2025) - 

тренировка написания багрепортов - 
https://vc.ru/dev/2020341-kak-pravilno-sostavit-bag-report-dlya-razrabotchikov

Почему хороший баг - репорт это важно?
- Ясность: Разработчик сразу понимает проблему без лишних вопросов.
- Воспроизводимость: Шаги воспроизведения позволяют точно повторить ошибку.
- Эффективность: Приоритет и статус помогают управлять задачами.
- Документация: Баг-репорт становится историей для будущих проверок.



1. Заголовок (Title)
Пример: "Ошибка авторизации при вводе корректных данных" Что писать:
- Краткое и точное описание проблемы.
- Избегайте эмоциональных формулировок (например, "ужасная ошибка").
- Укажите ключевые элементы: что сломалось, где и при каких условиях.



2. Приоритет (Priority)
Варианты:
- Critical (Критический): Приложение не работает, данные утрачиваются, крашится.
- High (Высокий): Основная функциональность нарушена, пользователь не может выполнить задачу.
- Medium (Средний): Незначительные ошибки, не блокирующие работу, но влияющие на UX.
- Low (Низкий): Косметические недочёты (например, орфография, небольшие отступы).

Что учитывать:
- Важность проблемы для пользователя.
- Влияние на бизнес-процессы.



3. Статус (Status)
Варианты:
- New (Новый): Баг только создан.
- In Progress (В работе): Разработчик исправляет.
- Fixed (Исправлено): Исправление готово, но не проверено.
- Verified (Проверено): QA подтвердил исправление.
- Closed (Закрыто): Баг закрыт.
- Reopened (Переоткрыт): Ошибка повторилась.



4. Описание проблемы (Description)
Пример: "При попытке авторизации с валидными данными (логин: testuser, пароль: Test1234) появляется сообщение «Неверный пароль», но пользователь не может войти." 

Что писать:
- Контекст: где и при каких условиях возникает ошибка.
- Описание симптомов (например, сообщения об ошибках, краши).
- Упомянуть, если проблема воспроизводится всегда или случайно.



5. Шаги воспроизведения (Steps to Reproduce)
Пример:
1 - Откройте приложение.
2 - Перейдите на страницу авторизации.
3 - Введите логин: testuser, пароль: Test1234.
4 - Нажмите «Войти».
5 - Ошибка: «Неверный пароль».

Правила:
- Нумерованный список.
- Каждый шаг — отдельное действие.
- Указывать все детали (например, устройства, браузеры, версии ПО).



6. Ожидаемый результат (Expected Result)
Пример: "После ввода корректных данных пользователь должен успешно авторизоваться и попасть в личный кабинет."



7. Фактический результат (Actual Result)
Пример: "После нажатия «Войти» появляется сообщение «Неверный пароль», доступ в личный кабинет не предоставлен."



8. Дополнительные детали (Additional Details)
Что указать:
- Версия ПО: Например, "v2.1.5".
- Устройство/браузер: "iPhone 13 (iOS 16.4), Chrome 115".
- Среда: "Разработка (Dev), Тестирование (Test)".
- Логи/ошибки в консоли: Если есть, приложите скриншоты или текст.
- Связанные баги: Если проблема связана с другими задачами.



9. Приложения (Attachments)
Что приложить:
- Скриншоты/видео ошибки.
- Логи (например, из консоли разработчика).
- Скриншоты стэктрейсов (если есть).
- Ссылки на документацию или требования.



Пример заполненного баг-репорта - 

Заголовок: "Ошибка авторизации при вводе корректных данных" 
Приоритет: High 
Статус: New 
Описание проблемы: При попытке авторизации с валидными данными (логин: testuser, пароль: Test1234) появляется сообщение «Неверный пароль», но пользователь не может войти.

Шаги воспроизведения:
1 - Откройте приложение.
2 - Перейдите на страницу авторизации.
3 - Введите логин: testuser, пароль: Test1234.
4 - Нажмите «Войти».
5 - Ошибка: «Неверный пароль».

Ожидаемый результат: Пользователь авторизуется и попадает в личный кабинет.

Фактический результат: Появляется сообщение об ошибке, доступ не предоставлен.

Дополнительные детали:
- Версия ПО: v2.1.5
- Устройство: MacBook Pro (macOS Ventura 13.4)
- Браузер: Safari 16.4

Приложение:
- Скриншот ошибки: [link_to_screenshot]
- Логи консоли: [link_to_logs]



Этот шаблон подходит для веб-приложений, мобильных и десктопных проектов. Адаптируйте его под нужды вашей команды!



******************************************

неделя 4 - день 3 (10.09.2025) - 

чек-лист - 
https://www.youtube.com/watch?v=qK3du-6EJk8



документы (артефакты) тестирования для определения проводимых проверок (тест-план, чеклисты, тест-кейсы и т.п.): 

- чеклисты - список проверок без указания шагов ->
чеклист - идея проверки 

- тестовый набор (test suite)- это перечень тест-кейсов ->
тест-кейс - проверка, состоящая из шагов, условий и ожидаемого результата 



атрибуты чеклиста - 
- номер 
- описание проверки (идея для проверки)
- статус 
    - passed - пройден
    - failed - сломался
    - skipped - этот тест пропустили
    - no run - не запускался (должен стоять по умолчанию)
    - blocked - выполнение теста заблокированно другим тестом 
- комментарий 



обычно говорят чеклист про несколько чеклистов, то есть про один документ, хотя чеклист - это одна идея для проверки

есть идея что каждый тест должен быть атомарным, то есть не должен зависить от другого теста - но бывает что нужно проверить авторизацию, а сайт не запускается 

таблица - в видео - 08-30 

в чеклисте описываем что будем проверять (идеи), но не описываем как будем это проверять (но каждый тестировщик может это проверять по своему, это как плюс, так и минус)

чаще всего используется только 2 статуса - 
- passed - пройден
- failed - сломался



основные программы для работы - 
- Excel 
- Trello 
- Jira + плагины 



частые вопросы на собеседовании - 
- в чем отличие тест-кейса от чеклиста?
- когда нужно выбирать чеклист, а когда тест-кейс? 



плюсы чеклистов - 
- гибкость 
- простота создания и поддержки 
- простота визуализации 
- расширение тестового покрытия 
- каждый выполняет по своему 

минусы чеклистов - 
- каждый выполняет по своему 
- неопределенность тестовых данных 
- неэффективен для джунов 
- высокая вероятность разночтения 



******************************************

неделя 4 - день 4 (11.09.2025) - 

тренировка написания чек-листов - 
https://www.software-testing.ru/images/stories/library/complete-web-application-testing-checklis.pdf



Во время тестирования веб-приложения нужно обращать внимание на нижеперечисленные пункты. Этот чеклист применим практически к любому типу веб-приложений в зависимости от бизнес-требований.

Чек-лист для тестирования веб-приложений состоит из:

1 - Тестирования удобства использования
2 - Функционального тестирования
3 - Тестирования совместимости
4 - Тестирования баз данных
5 - Тестирования безопасности
6 - Тестирования производительности



Теперь давайте рассмотрим каждый пункт по отдельности - 



1 - Тестирование удобства использования - Что это такое? -
- Это не что иное, как тестирование дружелюбности приложения для пользователя.
- При тестировании удобства использования проверяется, легко ли новому пользователю разобраться в приложении.
- В целом при тестировании удобства использования тестируется системная навигация.

Какова цель этого тестирования? -
Тест удобства использования удостоверяется в простоте и эффективности использования продукта при использовании стандартных практик тестирования удобства использования.

Сценарии тестирования удобства использования:
- Содержание веб-страницы верное, без грамматических и орфографических ошибок.
- Все шрифты соответствуют требованиям.
- Все тексты правильно выровнены.
- Все сообщения об ошибках верные, без орфографических и грамматических ошибок, и соответствуют заголовку окна.
- Подсказки существуют для всех полей.
- Все поля правильно выровнены.
- Между полями, колонками, рядами и сообщениями об ошибках оставлено достаточно свободного места.
- Все кнопки должны иметь стандартный формат и размер.
- Ссылка на домашнюю страницу должна быть на каждой странице сайта.
- Неактивные поля должны быть серыми.
- Проверьте, что на сайте нет битых ссылок и изображений.
- Подтверждающие сообщения должны отображаться для всех операций обновления и удаления.
- Проверьте сайт при разных разрешениях экрана (640 x 480, 600x800 и т. д.)
- Проверьте, что пользователь может пользоваться системой без раздражения.
- Проверьте, что TAB правильно работает.
- Панель скролла должна появляться только тогда, когда она требуется.
- Если при отправке формы есть сообщения об ошибке, в нем должна содержаться
информация, переданная пользователем.
- Заголовок должен отображаться на каждой странице.
- Все поля (текстовые, выпадающие меню, радио-кнопки и т. д.) и кнопки должны быть доступны с клавиатуры, и пользователь должен быть в состоянии пользоваться сайтом, используя только клавиатуру.
- Убедитесь, что данные в выпадающих списках не обрезаются из-за размеров поля, и проверьте, зашиты ли данные в код или управляются администратором.



2 - Функциональное тестирование - Что это? - 
- Тестирование функциональностей и операционного поведения продукта с целью
убедиться, что они соответствуют спецификациям.
- Тестирование, игнорирующее внутренние механизмы системы или компонента. Оно концентрируется исключительно на выходных данных, полученных в ответ на
пользовательский ввод и условия исполнения сценариев.

Какова цель функционального тестирования? - Цель функционального тестирования – убедиться, что ваш продукт соответствует нужной
функциональной спецификации, упомянутой в вашей документации по разработке.

Сценарии функционального тестирования:
- Протестируйте валидацию всех обязательных полей
- Убедитесь, что знак звездочки отображается у всех обязательных полей
- Убедитесь, что система не отображает окно ошибки при незаполненных необязательных полях.
- Убедитесь, что високосные коды корректно валидируются и не вызывают ошибок в расчетах.
- Протестируйте числовые поля: они не должны принимать буквы, в этом случае должно отображаться соответствующее сообщение об ошибке.
- Протестируйте отрицательные значения в числовых полях, если они разрешены.
- Протестируйте, что деление на ноль верно обсчитывается.
- Протестируйте максимальную длину каждого поля, чтобы убедиться, что данные не обрезаются.
- Протестируйте всплывающее сообщение ("Это поле ограничено 500 знаками"), которое должно отобразиться, если введенные данные превышают разрешенный размер поля.
- Убедитесь, что подтверждающее сообщение отображается для операций обновления и удаления.
- Убедитесь, что значения стоимости отображаются в нужной валюте.
- Протестируйте все поля ввода на спецсимволы.
- Протестируйте функциональность тайм-аута.
- Протестируйте функциональность сортировки.
- Протестируйте функциональность доступных кнопок.
- Протестируйте условия использования и часто задаваемые вопросы: они должны быть внятными и доступными пользователю.
- Протестируйте, что при отказе функциональности пользователь перенаправляется на специальную страницу ошибки.
- Протестируйте, что все загруженные документы правильно открываются.
- Протестируйте, что пользователь может скачать загруженные файлы.
- Протестируйте почтовую функциональность системы.
- Протестируйте, что Java Script верно работает в разных браузерах (IE, Firefox, Chrome, Safari, Opera).
- Посмотрите, что будет, если пользователь удалит куки, находясь на сайте.
- Посмотрите, что будет, если пользователь удалит куки после посещения сайта.
- Протестируйте все данные в выпадающих списках: они должны быть расположены в хронологическом порядке.



3 - Тестирование совместимости - Что это? -
Тестирование совместимости используется, чтобы убедиться, что ваше приложение совместимо с другими элементами системы, в которой оно работает – например, браузерами, операционными системами или железом.

Какова цель тестирования совместимости? -
Цель тестирования совместимости – оценка того, насколько хорошо ПО работает в определенном браузере, под определенной ОС, с другим ПО или железом.

Сценарии тестирования совместимости:
- Протестируйте сайт в различных браузерах (IE, Firefox, Chrome, Safari, Opera) и убедитесь, что сайт правильно отображается.
- Убедитесь, что используемая версия HTML совместима с соответствующими версиями браузеров.
- Убедитесь, что картинки корректно отображаются в разных браузерах.
- Убедитесь, что шрифты верно отображаются в разных браузерах.
- Убедитесь, что Java Script код работает в разных браузерах.
- Проверьте анимированные GIF в разных браузерах.

Инструмент для тестирования совместимости
Spoon.net: Spoon.net предоставляет доступ к тысячам приложений (браузеров), не требующих установки. Этот инструмент помогает вам тестировать приложение в разных браузерах на одной и той же машине.



4 - Тестирование баз данных - Что это? -
При тестировании баз данных проверяются бэкэнд-записи, введенные через веб или десктоп-приложение. Данные, которые отображаются в приложении, должны совпадать с данными, хранящимися в базе данных.

Чтобы тестировать базы данных, тестировщик должен знать следующее:
- Тестировщик должен понимать функциональные требования, бизнес-логику, основной сценарий приложения и дизайн базы данных.
- Тестировщик должен разбираться в таблицах, триггерах, процедурах хранения, способах отображения и указателях, используемых для приложения.
- Тестировщик должен понимать логику триггеров, процедур хранения, способов
отображения и указателей.
- Тестировщик должен понимать, какие таблицы затрагиваются, когда операции вставки, обновления и удаления выполняются в приложении.

Понимая вышеперечисленные пункты, тестировщик может легко написать сценарии для тестирования баз данных.

Сценарии тестирования баз данных:
- Проверьте название базы данных: оно должно совпадать со спецификацией.
- Проверьте таблицы, колонки, типы колонок и значения по умолчанию: все это должно совпадать со спецификацией.
- Проверьте, позволяет ли колонка значение null.
- Проверьте первичный и внешний ключ каждой таблицы.
- Проверьте процедуры хранения.
- Протестируйте, установлена ли процедура хранения.
- Проверьте название процедуры хранения.
- Проверьте названия параметров, их типы и количество.
- Проверьте, обязательны параметры или нет.
- Проверьте процедуру хранения, удалив некоторые параметры.
- Проверьте базу данных, если на выходе ноль – записи с нулем должны быть
задействованы.
- Проверьте процедуру хранения, задав простые SQL-запросы.
- Убедитесь, что процедура возвращает значения.
- Проверьте процедуру вводом тестовых данных.
- Проверьте поведение каждого флага в таблице.
- Убедитесь, что данные правильно сохраняются в базе данных после каждого ввода.
- Проверьте данные при каждой операции обновления, удаления и вставки.
- Проверьте длину каждого поля. Длина на бэкэнде и фронтэнде должны совпадать.
- Проверьте названия баз данных QA, UAT и прода. Имена должны быть уникальными.
- Проверьте зашифрованные данные в базе.
- Проверьте размер базы и время отклика на каждый запрос.
- Проверьте данные, отображающиеся на фронтэнде, и убедитесь, что они совпадают с бэкэндом.
- Проверьте целостность данных, вводя невалидные значения в базу.
- Проверьте триггеры.



5 - Что такое тестирование безопасности? -
Тестирование безопасности нацелено на поиск недостатков и пробелов с точки зрения безопасности приложения.

Сценарии тестирования безопасности:
1. Убедитесь, что страницы, содержащие важные данные (пароль, номер кредитной карты, ответы на секретные вопросы и т. п.) открываются через HTTPS (SSL).
2. Убедитесь, что важная информация (пароль, номер кредитной карты) отображается в зашифрованном виде.
3. Убедитесь, что правила создания паролей внедрены на всех страницах авторизации (регистрация, страница "забыли пароль", смена пароля).
4. Убедитесь, что если пароль изменен, пользователь не может зайти под старым.
5. Убедитесь, что сообщения об ошибках не содержат никакой секретной информации.
6. Убедитесь, что если пользователь вышел из системы или сессия завершена, он не может пользоваться сайтом.
7. Проверьте доступ к закрытым и открытым страницам сайта напрямую без авторизации.
8. Убедитесь, что опция "Просмотр исходного кода" отключена и не видна пользователю.
9. Убедитесь, что учетная запись пользователя блокируется, если он несколько раз ввел пароль неверно.
10. Убедитесь, что пароль не хранится в куки.
11. Убедитесь, что если какая-либо функциональность не работает, система не отображает информацию о приложении, сервере или базе данных. Вместо этого отображается соответствующее сообщение об ошибке.
12. Проверьте сайт на SQL-инъекции.
13. Проверьте права пользователей и их роли. К примеру, кандидат не должен быть способен получить доступ к странице администратора.
14. Убедитесь, что важные операции пишутся в логи, и информацию можно отследить.
15. Убедитесь, что значения сессий отображаются в адресной строке в зашифрованном виде.
16. Убедитесь, что куки хранятся в зашифрованном виде.
17. Проверьте приложение на устойчивость к брутфорс-атакам.



6 - Что такое тестирование производительности? -
Тестирование производительности проводится для оценки соответствия системы или компонента специфичным требованиям к производительности.

Общие тестовые сценарии:
- Определение производительности, стабильности и масштабируемости приложения под разной нагрузкой.
- Определение, может ли актуальная архитектура поддерживать приложение при пиковых нагрузках.
- Определение, какая конфигурация приводит к наилучшим показателям
производительности.
- Определение бутылочного горла приложения и инфраструктуры.
- Определение, не изменилось ли время отклика у новой версии приложения.
- Оценка продукта и/или железа с целью удостовериться, что они выдержат
прогнозируемые объемы нагрузки.

Как проводится тестирование производительности? Вручную или автоматически?
В целом невозможно проводить тестирование производительности вручную по ряду причин:
- Понадобится большое количество ресурсов.
- Невозможно одновременно осуществлять ряд действий.
- Отсутствует подходящий способ отслеживания поведения системы.
- Сложность выполнения повторяющихся задач.

Чтобы справиться с вышеперечисленными проблемами, используются специальные инструменты тестирования производительности. Ниже перечислены некоторые из них:.
- Apache JMeter
- Load Runner
- Borland Silk Performer.
- Rational Performance Tester
- WAPT
- NEO LOAD



******************************************

неделя 4 - день 5 (12.09.2025) - 

тесткейс - 
https://testengineer.ru/kak-pisat-test-kejsy-polnoe-rukovodstvo/



Тест-кейс — это четкое описание действий, которые нужно выполнить для проверки отдельной функции вашего приложения.

Тестировщик создает тест-кейс, чтобы проверить, работает ли определенная фича должным образом, и чтобы подтвердить, что функционал, UI/UX и другие параметры системы удовлетворяют всем соответствующим стандартам, руководствам и требованиям клиентов.



Чем отличаются тест-кейс и чеклист -

Тест-кейсы используются для сложных проектов. Например, когда от поведения системы зависит человеческая жизнь. Это могут быть проекты, связанные с пожарной безопасностью, здравоохранением, финансами и т. д. В таких случаях все нужно тестировать очень тщательно.

Чеклист QA — это список того, что нужно протестировать. Благодаря ему процесс тестирования проходит более четко и аккуратно.

Обычно при работе с простыми системами — сайтами, мобильными приложениями и т. д. — нет необходимости в тест-кейсах. Часто в команде бывает только один-два тестировщика, которые хорошо знают свой продукт. В таком случае время, потраченное на создание и поддержку тест-кейсов, никогда не окупится. Лучше создать чеклист со списком функций, которые нужно проверить — это будет более рационально.



Позитивные, негативные и деструктивные тест-кейсы - 

1 - В позитивных тест-кейсах используются корректные входные данные и сценарии ожидаемой работы системы. Цель здесь — убедиться, что программный продукт выполняет то, что должен делать, и что система не выдаст ошибку, если это не предусмотрено. 

Например, если поле пароля принимает десять символов, пользователь должен иметь возможность создать такой пароль.


2 - Негативные тест-кейсы используют некорректные входные данные и проверяют, не делает ли программа того, чего не должна делать. Негативное тестирование призвано гарантировать, что при получении некорректных входных данных система не будет работать по нормальному сценарию (например, выбросит ошибку). 

Если вернуться к нашему примеру, пользователь не должен иметь возможность создать пароль, состоящий из 11 символов.


3 - Деструктивные тест-кейсы создаются, чтобы узнать предел прочности системы. Нагрузочное тестирование — распространенный вариант деструктивного тестирования. 

Для деструктивного тестирования QA-специалисты могут применять следующие методы:
- создание большой нагрузки на систему, чтобы это привело к ее отказу;
- злонамеренное внедрение JavaScript в веб-форму;
- фаст-кликинг в попытках взломать веб-страницу и т. д.



Атрибуты тест-кейса для ручного тестирования -
Как и все тестировочные документы, тест-кейс имеет определенный формат. Он содержит следующие атрибуты:

1 - ID — уникальное сочетание букв и цифр.

2 - Заголовок — основная идея тест-кейса, краткое описание его сути. Например, заголовок тест-кейса для ручного тестирования страницы входа может выглядеть следующим образом: «Проверить вход пользователя с корректными данными».

3 - Предусловия — список действий, которые необходимо выполнить перед выполнением тест-кейса. При необходимости здесь могут указываться учетные данные.

4 - Шаги — описание действий, необходимых для проверки.

5 - Постусловия — список действий, возвращающих систему в исходное состояние (указывается при необходимости).

6 - Ожидаемый результат — то, что мы ожидаем получить после успешного выполнения тест-кейса.

7 - Фактический результат — то, что мы получаем после выполнения тест-кейса (указывается при необходимости).

8 - Статус — Success (успех), Failed (провал), Blocked (блокировка) (указывается при необходимости).


Кроме того, для некоторых тест-кейсов могут потребоваться дополнительные атрибуты:
- Требования к среде — специальное оборудование, программное обеспечение и т. п. вещи, необходимые для выполнения тест-кейса и не перечисленные в соответствующей спецификации проекта тестирования.
- Специальные процедурные требования — особые процедуры настройки, выполнения или очистки, уникальные для этого тест-кейса.
- Межкейсовые зависимости — тест-кейсы, которые нужно выполнить перед этим тест-кейсом.



Характеристики хорошего тест-кейса -
Прежде всего, тест-кейс не должен быть зависимым или связанным с другими тест-кейсами. Он должен быть полным и самодостаточным. Следует избегать расплывчатых описаний шагов или ожидаемых результатов. Любые ограничения, отсутствие необходимой информации или чрезмерное количество деталей делают тест-кейсы менее эффективными.

Короче говоря, хороший тест-кейс:
- понятен любому члену команды;
- аккуратно и точно написан;
- соответствует требованиям;
- воспроизводим;
- пригоден для многократного использования.



Best practices в написании тест-кейсов -

Под  best practices мы подразумеваем правила, которые помогают создавать простые, понятные и полезные тест-кейсы:

- Перед созданием нового тест-кейса убедитесь, что он не дублирует ни один из уже существующих в системе.

- Убедитесь, что тест-кейс покрывает 100% требований, которые вы должны проверить.

- Помните о теории методов тестирования, таких как анализ граничных значений, разделение эквивалентности, техника перехода состояния, угадывание ошибок.

- Помимо требований к системе, всегда помните о конечном пользователе, который будет взаимодействовать с системой.

- Не забудьте указать учетные данные, если они необходимы для выполнения теста.

- Позаботьтесь о тестировщиках, которые будут работать с этим тест-кейсом в будущем. В частности, убедитесь, что все ссылки верны и кликабельны. 

- Пожалуйста, не используйте ссылки на продакшен.

- Используйте повелительное наклонение, например: «Перейдите на главную страницу», «Введите данные», «Кликните» и т. д. Такая формулировка упрощает понимание этапов тестирования и ускоряет их выполнение.



Формирование тест-кейсов -
Обычно при написании тест-кейсов тестировщики пользуются таблицами Excel. Но вы также можете использовать инструменты управления тестированием, такие как TestRail.



Примеры тест-кейсов для ручного тестирования - 


1 - Позитивный тест-кейс -
Давайте попробуем создать наш собственный тест-кейс для ручного тестирования функции поиска на e-commerce сайте компании FootWear. Начнем с позитивного теста.

ID: FWSF-1. (Лучше использовать числа в возрастающем порядке. FWSF = FootWear Search Functionality. Попробуйте придумать комбинацию букв, имеющую отношение к проекту или функции, которую вы собираетесь тестировать).

Заголовок: Проверить результаты поиска с корректными входными данными. (Узнать, какие значения допустимы, мы можем в требованиях).

Предусловия: Нужно иметь предварительно настроенные продукты из разных категорий, отображаемые на сайте. (Для проверки функциональности нам необходимо иметь элементы, доступные для поиска. Вы можете настроить это в панели администратора или в базе данных).

Шаги:
- Откройте домашнюю страницу. (Ссылка не обязательна, ее наличие может затруднить поддержку тест-кейса в будущем).
- Введите в поле поиска ключевое слово, связанное с названием доступного продукта.
- Выполните поиск, кликнув значок поиска или нажав Enter.
- Проверьте результаты.

Ожидаемый результат: На странице результатов поиска отображаются все релевантные результаты.


2 - Негативный тест-кейс -

ID: FWSF-3.

Заголовок: Проверить ввод на недопустимые значения.

Предусловия: Выпишите недопустимые значения для поля ввода поиска из системных требований.

Шаги:
- Откройте домашнюю страницу.
- Введите комбинацию недопустимых значений в поле поиска.
- Выполните поиск, кликнув значок поиска или нажав Enter.
- Проверьте, отображается ли предупреждающее сообщение «Пожалуйста, используйте только допустимые символы».

Ожидаемый результат: Отображается предупреждающее сообщение «Пожалуйста, используйте только допустимые символы». Поиск можно продолжить.


3 - Деструктивный тест-кейс -
Еще один пример — деструктивный тест-кейс.

ID: FWSF-2.

Заголовок: Проверить устойчивость поиска к SQL-инъекциям.

Предусловия: Подготовьте SQL-запрос, который вы собираетесь вставить в поиск.

Шаги:
- Откройте домашнюю страницу.
- Введите SQL-запрос в поле поиска.
- Выполните поиск, кликнув значок поиска или нажав Enter.
- Проверьте, правильно ли отображаются результаты, нет ли сообщений об ошибках на странице результатов поиска.

Ожидаемый результат: Для защиты от SQL-инъекций отображение предупреждающих сообщений должно быть отключено.



Контрольные вопросы и часто задаваемые вопросы по тест-кейсам:

Что такое тест-кейс? -
Одна из форм проверки, которую проводит QA-инженер. По сути алгоритм действий при проверке и результаты в четкой строгой форме. 

Что такое тест-кейс простыми словами? -
Совсем простыми словами: Выписанные в столбик действия, которые проверяют программу, и что получилось.

Пример тест-кейса? -
1. Название или номер
2. Предусловие
3. Действие
4. Ожидаемый результат

Что должно быть в тест-кейсе? -
Стандартные составляющие тест-кейса:
- Уникальный номер, по которому на него будут ссылаться другие тестовые артефакты
- Краткое описание, из которого понятно предназначение
- Входные данные
- Пошаговые действия
- Ожидаемый результат
- Полученный результат
- Статус

Что такое хороший тест-кейс? -
Полный, точный и понятный. Четко описаны все шаги и результаты. Легко воспроизводимый другим тестировщиком.

Когда писать тест-кейсы? -
Зависит от проекта и от задач. Тест-кейсы пишут в процессе разработки, до старта тестирования, иногда во время и даже после этапа тестирования.

Как должен выглядеть тест-кейс? -
Имеется в виду оформление. Тест-кейс должен быть с четкими формулировками, содержать детальную, но не избыточную информацию. 

Как описать тест-кейс? -
То есть что должно быть в его секции заголовка: краткое, но ёмкое описание конкретной цели тест-кейса — что он будет проверять.

Как правильно называть тест-кейсы? -
То есть, каким должно быть идеальное название тест-кейса. Помимо того что название («тема») должно быть кратким, ёмким и понятным не только вам, название может зависеть от того, высокоуровневым (дымовым, интеграционным или системным) или низкоуровневым является этот тест-кейс. Высокоуровневый, без конкретных входных данных и ожидаемых результатов, походящий на тестовый сценарий, может быть назван более широко и удобочитаемо. А в целом, название должно как можно чётче обозначать предназначение.

В чем разница между тест-кейсом и чек-листом?  -
Самая важная разница: в чек-листе не будет детализации. Чеклист не описывает подробно все шаги, а просто их перечисляет.

Кто пишет тест-кейсы? -
Тестировщик. В зависимости от сложности задачи, джуниору и даже стажёру могут доверить написание простых тест-кейсов.

Сколько шагов должно быть в тест-кейсе? -
В общем и целом, в стандартном тест-кейсе лучше не делать больше 3-4 шагов. 
Если же речь идет о например комплексных/сквозных/системных тест-кейсах, то там может быть их больше.

Чего не должно быть в тест-кейсе? -
- (в идеале) Зависимости от других
- Нечетких формулировок шагов
- Нечетких формулировок ожидаемых результатов
- Излишней детализации

Какие виды тест-кейсов бывают? -
Например позитивные (проверяющие ситуации «когда всё ОК») и негативные («когда что-то пользователь делает не ОК»).
По предназначению можно разделить на функциональные, приемочного тестирования, нагрузочного и стрессового, дымового и санитарного — много видов со своими особенностями.

В чем разница между баг-репортом и тест-кейсом? -
Тест-кейс описывает конкретный тест для выполнения, а баг-репорт представляет собой структурированное сообщение («доклад») о найденном баге.

Где создать тест-кейс? -
Чаще всего в обычной таблице в Экселе. Но давно существуют удобные инструменты для создания тест-кейсов, а также их упорядочивания, запуска, контроля, и генерации и хранения отчетов по результатам. Например, есть инструменты TestLink и TestRail.

Что проверяет тест-кейс? -
Чаще всего («статистически») предметом проверки тест-кейсов являются кнопки, поля ввода и т.п.

Где применяются тест-кейсы? -
Видимо спрашивают, в каких проектах/сферах необходимо применение именно тест-кейсов (а не других тестовых артефактов подобного предназначения). Это, в первую очередь, медицинские системы, навигационные системы, системы управления АЭС, заводское ПО и подобные важные сферы. Такому ПО нужно очень тщательное тестирование «до последней точки», и для этого нужны тестовые артефакты именно этого типа.

А почему в тест-кейсах нужны четкие шаги? Нельзя как-то более плавно и human-friendly? -
Само предназначение тест-кейса приводит к необходимости его четкой структуризации. Шаги (этапы) нужны, чтобы получить предусловия, выполнить действия, привести тестировщика к фактическому результату и четко видеть результат.

Как писать шаги в тест-кейсе? -
По возможности кратко. Не стОит описывать этапы (шаги) уж слишком подробно. Например, лучше писать «Введите свой мейл», а не «Введите свой адрес электронной почты не забыв о @»

Как определить приоритет в тест-кейсе? -
Приоритет, показывающий важность тест-кейса, в разных инструментах может выражаться обозначениями A-B-C-D-E в порядке уменьшения приоритета, или цифрами 1…5, или словесно (от «крайне высокого» до «низкого»). 
При присвоении приоритета тест-кейсу следует учитывать: важность требования/пользовательского сценария/ функции, с которыми связан этот тест-кейс; потенциальную важность дефекта, на поиск которого ориентирован тест-кейс; степень риска.

Когда нужно выбирать тест-кейс, а когда чек-лист? -
Чек-лист лучше подходит, когда система не очень сложная, а тестирование проводят люди, хорошо знакомые с продуктом.
Тест-кейсы лучше, когда система сложная, комплексная, многокомпонентная или очень важная, а тестировать будут обычные тестировщики из QA-отдела, менее вовлечённые в продукт чем его создатели.

Каким может быть исход тест-кейса? -
Результатом может быть или его (успешное) прохождение/выполнение (pass), или неуспешное/»провал»/fail.

Сколько времени нужно на написание тест-кейса? -
Зависит от проекта и от опыта, простой несколько минут, сложный 10-20 минут и более.

А когда не нужно писать тест-кейсы? -
Когда тестируется простая система. Например, веб-сайт «одностраничник», или очень простое мобильное приложение. Или в проекте, в котором всего один или два тестировщика, хорошо знакомые с продуктом, им проще чеклисты.

На каком этапе составляют тест-кейсы? -
«Классический» ответ: на этапе тест-дизайна. То есть на этапе, когда тест-кейсы проектируются и создаются. 

Есть ли разница между тест-кейсом и тестовым случаем? -
Вообще нет, не должно, это просто разные названия одного и того же тестового артефакта. В некоторых русскоязычных источниках, впрочем, «случаем» называют низкоуровневый тест-кейс.

Готовые тест-кейсы — есть где-то? Например примеры и шаблоны тест-кейсов для интернет-магазина, или тест-кейсы для сайта, или для формы регистрации/авторизации? -
Да, все это есть в интернете. Ищите «шаблоны тест-кейсов».



******************************************

неделя 4 - день 6 (13.09.2025) - 

тренировка написания кейсов - 
https://youtu.be/Y_LKTlo9Apc?si=KgqNOBUURkfkP3WB



кейс - расписанный по шагам сценарий использования 



если попросили написать тест-кейс - 

спросить, есть ли документация, если нет, то сформулировать требования совместно с менеджером и разработчиком 

уточнить сроки 

после получения требований написать чек-лист всего, что есть в требованиях 

потом чек-лист можно использовать как основу для тест-кейсов 

техники тест-дизайна помогают покрыть проверками требования 

раскидаем функционал на классы эквивалентности, то есть на такие блоки, где одна проверка будет их все проверять, и эту проверку мы и будем рассписывать подробно по шагам, название должно содержать ответы на вопросы:
- что?
- где?
- как? 


- название - не просто "проверить вход в приложение", а на какой странице и с какими данными нужно это сделать (как образец - "проверить вход в приложение с корректными данными")


- предусловие - 
перед проверкой нужно сделать подготовку, указать - 
- окружение 
- сборка 
- страна использования
- ссылка на эксперимент 
- открыта главная страница


- шаги - писать понятно и последовательно (четкие шаги используя безличные глаголы - "открыть", "ввести", "нажать" и т.п.), лучше добавлять скриншоты 


- ожидаемый результат 


- фактический результат 


- статус 



отдать кейс на ревью 

кейсы должны быть актуальны 



в тг-канале по ссылке в описании - шаблон тест-кейса 



******************************************

неделя 4 - день 7 (14.09.2025) - 

тест-план - 
https://www.software-testing.ru/library/testing/test-analysis/2949-how-to-write-a-software-test-plan



- В какой форме тест-план должен быть?
- Какую информацию он должен включать?
- Для кого он предназначен?



Если вам кажется, что план вам нужен, то ниже – ряд вопросов, которые стоит задать, и несколько неплохих возможных ответов на них:

Вопрос: Кто запрашивает этот документ?
Ответ: заказчик, мы обязаны предоставить его по контракту.

Вопрос: Кто будет читать этот документ?
Ответ: Менеджер проекта, которому нужно убедиться, что я собираюсь протестировать продукт как минимум на удовлетворительном уровне.

Вопрос: Что читатель получит от этого документа?
Ответ: Вместе с прочей информацией – достаточную уверенность для релиза.

Вопрос: Что может улучшиться, если я прекращу писать тест-план?
Ответ: У меня будет больше времени для действительно ценной для проекта работы, потому что я не трачу время на то, что никто не будет читать.

Вопрос: Что может ухудшиться, если я прекращу писать тест-план?
Ответ: В проекте никто не будет иметь ни малейшего понятия, что именно я тестирую.

Вопрос: Кто заметит, если я прекращу писать тест-план?
Ответ: Владелец процесса, так как создание тест-плана – это часть нашего контролируемого процесса.



Использование тест-плана как можно раньше в жизненном цикле проекта для поиска ответов на эти вопросы – это разновидность тестирования. Вы можете, например, спросить, есть ли критерии производительности, которые можно оценить и использовать для тестирования? Будет ли продукт выходить в интернет? Какие сценарии восстановления/избегания проблем должен поддерживать продукт? Задавая эти вопросы, вы подводите заинтересованных лиц к размышлениям о производительности, безопасности и устойчивости, и они займутся этим раньше, чем могли бы, не спроси вы их об этом.

Возможно, вы обязаны предоставить тест-план по контракту. В этом случае работайте совместно с заказчиком, чтобы уточнить, что он хочет узнать, и посредством какого механизма он хочет получить эту информацию.

План начнет приносить ценность только тогда, когда вы будете его использовать.

Если детальный план необходим, убедитесь, что вы учитываете риски, что что-то может остаться непокрытым или непротестированным. Тест-планы можно использовать как для информирования о том, что вы собираетесь тестировать, так и для того, чтобы сообщить, что вы, возможно, протестировать не сможете, если времени на это не хватит.



Тест-планом также могут пользоваться те, кому полезна информация, полученная в ходе запланированного тестирования. Найдите их, спросите, какая информация им требуется, и планируйте соответственно. Ниже – примеры заинтересованных лиц:

- Тестировщики, которые хотят знать, что им предстоит тестировать в проекте. Тест-план может дать им подробную информацию об окружениях, версиях, или исходных данных. Тестировщики могут помочь вам улучшить план, основываясь на своем опыте, и добавить в него недостающую информацию и тест-подходы, о которых вы не подумали.

- Менеджеры проекта хотят знать, что вы собираетесь тестировать, дабы быть уверенными в решении о выходе в релиз.

- Техподдержка может рассказать об окружениях пользователей, о том, как они используют систему, и с какими проблемами сталкиваются. Эта информация может послужить основой для тестирования, покрывающего эти трудности.

- Продакт-оунеры расскажут, как планируется использовать продукт, и возможно о случаях, когда пользователи используют его иначе. Эта информация полезна для создания профилей пользователей, помогающих в тестировании.

- Продажники сообщат, какие продукты наиболее популярны, и как именно они применяются.


Если вы сомневаетесь, принадлежит ли человек к группе заинтересованных лиц, то всегда лучше включить его в процесс, нежели исключить.



Как написать хороший тест-план: форма, структура и содержание
Тест-планы могут принимать какую угодно форму, например:

- Word-документы – зачастую формат по умолчанию, так как Word доминирует на рынке, и люди хорошо с ним знакомы. Тест-планы варьируют от одностраничного документа, кратко описывающего основные области тестирования, до длинного, соответствующего IEEE829 / IEEE29119 стандартам мануала, подробно расписывающего каждую деталь.

- Ментальные карты – отличный способ изложить тест-информацию в структурированной графичной форме. Читателю легко отслеживать структуру плана и просмотреть его на необходимом уровне детализации. Погуглите "mindmap test plans", чтобы посмотреть на примеры.

- SharePoint / Wiki – отличные альтернативы Word, и обладают мощным инструментарием управления версиями и редактирования. Они позволяют гибко структурировать информацию, а также быстро обновлять и совместно редактировать ее.

- Web-инструменты планирования (например, Jira) можно использовать не только для планирования задач разработки. Интеграция с системами управления тестами (например, TestRail) даст команде полную картину запланированного и реального тестирования.

- Whiteboard / доски Kanban – еще один неплохой способ графически показать масштабы тестирования. Физические доски – очень прозрачный способ донести, что и как вы собираетесь тестировать.



Хороший способ начать тест-план – это одностраничный план. Он поможет вам создать краткий и информативный документ.

С точки зрения содержания тест-планы обычно создаются, чтобы зафиксировать базовые ответы на "пять почему и как" тестирования. Содержание ваших планов может меняться по ряду причин (к примеру, от релиза к релизу или от спринта к спринту). Обновляйте ваш тест-план на основании полученной от релиза к релизу (или от продукта к продукту) информации.



Когда ваш план готов, пересмотрите его. Оценка тест-плана может проводиться по-разному – лично я рекомендую личную встречу для его обсуждения. Такие встречи могут дать информацию о том, что еще необходимо добавить или покрыть. Они также делают тестирование продукта, приложения или релиза прозрачным для вас и вашей команды.

Пригласите на ревью заинтересованных лиц. Максимально сократите количество участников, но убедитесь, что все нужные роли присутствуют. Предположительный кворум может состоять из четырех человек или ролей – автор тест-плана (как правило, тестировщик), другой тестировщик, менеджер проекта, и представитель техподдержки. Однако для более крупных релизов можно подключать и других заинтересованных лиц – все зависит от вашей специфики.

Пройдитесь по каждому аспекту тест-плана и обсудите все его разделы. Выслушайте обратную связь, учтите информацию, которой делятся участники встречи.

Если план одобрен необходимым большинством, он не должен оставаться статичным. Когда тестирование начнется, используйте план для отслеживания усилий команды по достижению указанных в плане целей.



Все меняется, и ваш план должен быть открыт переменам. Подход к планированию тестирования должен позволять справляться с изменениями, разъяснять, что вы будете делать иначе, какая информация вам необходима, и какую новую информацию (и кому) вы должны предоставить.

Договоритесь о подходящей частоте пересмотра тест-плана, или же используйте для этого любой достаточно весомый повод. Пересмотры не должны быть глобальными – пусть они соответствуют масштабу перемен. Это необязательно личные встречи: попросите людей просмотреть изменения и отправить вам комментарии по почте. Пусть всем будет легко помогать вам в поддержании плана в актуальном и рабочем состоянии.



Тест-план может помочь вам обдумать, какая подготовительная работа вам нужна. Это особенно важно, если вы не контролируете то, что может вам понадобиться в процессе тестирования. 



******************************************

неделя 5 - день 1 (15.09.2025) - 

devtools - 
https://www.youtube.com/watch?v=a3vRm9neKhs

00:00 - Интро
01:03 - Что такое Chrome DevTools?
02:35 - Как запустить и настроить DevTools в браузере?
03:50 - Вкладка Elements
06:53 - Вкладка Console
09:38 - Вкладка Sources
10:15 - Вкладка Network
15:15 - Вкладка Perfomance
18:33 - Вкладка Security
21:15 - Расширенные возможности Chrome DevTools
24:26 - Аутро



в каждом браузере есть аналогичный инструмент (devtools - в google chrome)

документация devtools - 
https://developer.chrome.com/docs/devtools?hl=ru

возьмем сайт - 
onliner.by 

ПКМ - посмотреть код (или F12)

три точки вверху справа - можно менять расположение окна 

если навести курсор на элемент страницы и ПКМ - посмотреть код - то откроется на коде того элемента, на который был наведен курсор 
























