
telegram - избранное - 19.08.2025 

проходить - по 1 теме в день 



******************************************

ПОЛЕЗНЫЕ МАТЕРИАЛЫ - 

шпаргалка для тестировщиков - 
https://docs.google.com/spreadsheets/d/1YM8ey2VNZ63q-IQxQoitro7zNN_rcOfsUB-wCi_hMCY/edit?gid=38461779#gid=38461779

фундаментальная теория тестирования - 
https://habr.com/ru/articles/549054/

QA библия - 
https://vladislaveremeev.gitbook.io/qa_bible

бесплатный крутой курс по python -
https://stepik.org/course/67/promo

лучший курс по алгоритмам на python -
https://www.youtube.com/playlist?list=PLRDzFCPr95fK7tr47883DFUbm4GeOjjc0

роадмап тестировщика -
https://miro.com/app/board/uXjVOsbBpjE=/

roadmap по python -
https://habr.com/ru/articles/725930/



******************************************

неделя 1 - день 1 (18.08.2025) - 

виды компаний - 
https://www.youtube.com/watch?v=t6mQkEa4O90

виды IT компаний и специфика работы в них для тестировщика -

1 - продуктовые IT компании - сами разрабатывают  

2 - аутсорсинговые IT компании - предоставляют в аренду свой персонал 

3 - аутстаффинговые IT компании - в отличие от аутсорса, отвечает только за свой квалифицированный персонал, но не берет на себя обязательства по успешности проекта заказчика 

4 - стартапы - разрабатывают свой продукт 

Чем отличается работа тестировщика в разных IT компаниях?

- требования к тестировщику
- ценность роли тестировщика и процесса тестирования 
- наличие тестовой документации 
- экспертность команды по тестированию 
- возможность роста и уровень ЗП 



******************************************

неделя 1 - день 2 (19.08.2025) - 

команда разработки - 
https://habr.com/ru/articles/695944/

Стандартный список ролей -
- аккаунт менеджер 
- продакт менеджер 
- проджект менеджер
- менеджер по продажам (сейлз)
- архитектор ПО 
- бизнес аналитик
- системный аналитик 
- технический писатель 
- проектировщик (макеты интерфейса)
- дизайнер (внешний вид продукта)
- фронтенд разработчик (верстальщик)
- бекэнд разработчик (или фулстек)
- тестировщик 
- локализатор (переделывает приложение под другие языки, страны)
- тимлид 



******************************************

неделя 1 - день 3 (20.08.2025) - 

цикл разработки по -
https://testengineer.ru/sdlc/

SDLC (Software Development Life Cycle) - последовательность этапов разработки -
- идея 
- сбор требований и анализ 
- дизайн 
- разработка 
- тестирование 
- деплой 
- поддержка

В общем виде SDLC состоит из 6 этапов: 
- Планирование
- Анализ
- Дизайн
- Разработка и тестирование
- Имплементация (деплой)
- Поддержка (обслуживание)

модели SDLC -
- водопадная (каскадная)
- гибкие методологии 
- v-модель 
- интерактивная и инкрементальная 
- эволюционного прототипирования 
- спиральная 



******************************************

неделя 1 - день 4 (21.08.2025) - 

словарь itшника -
https://docs.google.com/document/d/192vMjZjdZX9IIXiHSN2UH8ZxKcKDCAWnBZIltK4Hdvw/edit?tab=t.0#heading=h.8i6o3gxucuuy

+++



******************************************

неделя 1 - день 5 (22.08.2025) - 

методологии разработки - 
https://habr.com/ru/companies/edison/articles/269789/

+++



******************************************

неделя 1 - день 6 (23.08.2025) - 

agile - 
https://habr.com/ru/companies/edison/articles/313410/

+++



******************************************

неделя 1 - день 7 (24.08.2025) - 

scrum -
https://www.youtube.com/watch?v=bv4L_32J-5A

scrum - это фреймворк agile для гибкого управления проектами 

итерационная модель - основополагающая в scrum 

в водопадной модели невозможно вернутся на предыдущий этап, приходится начинать всё с начала - в scrum это возможно, и можно изменять требования 

agile-манифест - 4 основопологающие ценности - 
- люди и взаимодействие важнее процессов и инструментов 
- рабочий продукт важнее исчерпывающей документации 
- сотрудничество с заказчиком важнее согласования условий контракта 
- готовность к изменениям важнее следования первоначальному плану 

scrum = фреймворк :
1 - scrum команда 
2 - события 
3 - артефакты 
4 - метрики 

scrum - не советует создавать команды численностью более 9 человек (разработчики, которые решают что будем делать на проекте)

разработчик тоже несет ответственность за баг в продукте (коллективная ответственность)

scrum master - обучение и понимание scrum членами команды 



спринт - отрезок 2-4 недели -

- планирование спринта - выбираем из бэклога продукта что мы возьмем для данного спринта 

- ежедневный дейлик (митинг) - примерно 15 минут - что делал вчера, что планируешь делать сегодня, какие есть трудности, проблемы (вчера я писал тест-кейс для такой-то юзерстори, сегодня я буду писать тест-кейс для такой-то юзерстори, мне не понятно как рабработчики будут реализовывать такую-то юзерстори, хочу сегодня связаться с разработчиком и это выяснить)

- подведение итогов спринта (ретроспектива) - 
    - что шло хорошо в спринте 
    - какие проблемы были в спринте 
    - как можно улучшить работу 
    - идеи по ходу ретроспективы 



пользовательская история - описание чего-то, что система должна делать для пользователя (как новый пользователь в системе я хочу купить телефон, чтобы порадовать себя)

стори-поинт - единица оценки юзер-стори (пользовательских историй) 



******************************************

неделя 2 - день 1 (25.08.2025) - 

rest - 
https://testengineer.ru/rest/ 

REST (Representational State Transfer) — это архитектурный стиль, используемый при разработке распределенных систем, веб-сервисов и API (Application Programming Interface). Он определяет набор принципов и ограничений для создания масштабируемых, гибких и легко поддерживаемых систем.



Основные принципы REST:

1 - Клиент-серверная архитектура: В REST-архитектуре существует четкое разделение между клиентом (который инициирует запросы) и сервером (который предоставляет ресурсы и обрабатывает запросы). Это позволяет независимо изменять и развивать обе стороны без влияния на другую

2 - Без состояния (Stateless): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для обработки этого запроса. Сервер не хранит информацию о состоянии клиента между запросами. Это позволяет легко масштабировать серверную часть, так как каждый запрос обрабатывается независимо

3 - Кэширование: REST поддерживает механизм кэширования, позволяющий клиентам сохранять локальные копии ответов сервера. Это улучшает производительность, снижает нагрузку на сервер и улучшает пользовательский опыт

4 - Единообразие интерфейса: REST определяет универсальный интерфейс, состоящий из четырех основных методов HTTP: GET (получение ресурса), POST (создание нового ресурса), PUT (обновление ресурса) и DELETE (удаление ресурса). Эти методы позволяют управлять ресурсами на сервере

5 - Слои: REST позволяет использовать промежуточные слои (например, прокси-серверы или кэши), которые могут улучшать безопасность, масштабируемость и производительность системы



RESTful API (RESTful Application Programming Interface) — это API, разработанное с использованием принципов REST. Оно предоставляет доступ к ресурсам и операциям через стандартные методы HTTP. RESTful API широко используется в веб-разработке для создания взаимодействия между клиентскими приложениями и серверами, обмена данными и выполнения операций над ресурсами



Различия между REST и SOAP - 
Во-первых SOAP — это протокол, а REST — архитектурный стиль.

Лучше сравнивать реализации:
- SOAP: XML поверх SOAP через HTTP
- RESTful: JSON через HTTP



******************************************

неделя 2 - день 2 (26.08.2025) - 

soap - 
https://testengineer.ru/soap/

SOAP (Simple Object Access Protocol) — это протокол обмена структурированными сообщениями в формате XML (eXtensible Markup Language) между клиентом и сервером. SOAP используется для создания веб-служб (web services), которые обеспечивают взаимодействие между различными приложениями и платформами.

SOAP был широко использован в прошлом для интеграции различных систем и веб-служб. Однако, в последние годы, многие разработчики перешли на использование более легковесных и простых в использовании протоколов, таких как REST.

Основные характеристики SOAP:

1 - XML-основа: SOAP использует XML для кодирования структурированных данных в сообщениях. XML обеспечивает гибкость и расширяемость для передачи различных типов данных.

2 - Протокол независимый: SOAP не привязан к конкретному протоколу передачи данных и может использовать различные протоколы для отправки сообщений, такие как HTTP, SMTP и другие.

3 - Структурированные сообщения: SOAP сообщения состоят из заголовков (headers) и тела (body). Заголовки могут содержать информацию о безопасности, маршрутизации, версии протокола и другие метаданные. Тело содержит фактические данные, передаваемые между клиентом и сервером.

4 - Операции и методы: SOAP определяет операции, которые можно вызвать на удаленном сервере, и методы, которые могут быть выполнены над ресурсами. Он использует специальный язык описания веб-службы (WSDL — Web Services Description Language) для описания доступных операций и формата сообщений.

5 - Протокол с высоким уровнем абстракции: SOAP обеспечивает высокий уровень абстракции, что позволяет разработчикам скрыть детали взаимодействия и реализации от клиентов, фокусируясь на логике бизнес-операций.



******************************************

неделя 2 - день 3 (27.08.2025) - 

монолит - 
https://www.youtube.com/watch?v=wypO96zubGc

монолиты и микросервисы - это про API, про тестирование бекенда, HTTP методов 

у каждого микросервиса, как и у монолита, свои API

микросервисы могут быть расположенны на разных серверах 



******************************************

неделя 2 - день 4 (28.08.2025) - 

микросервисы - 
https://www.youtube.com/watch?v=XtOJZ1T3qw4&t=1492s



проблема монолитов - 

- жесткое связывание
 
- ответственность за разные компоненты монолита
 
- при изменениях тратится много времени на перепроверку логики работы всех компонентов монолита 

- проблемы при деплое и развертывании монолита 



на стартапе лучше выбирать монолит 

на большом проекте лучше выбирать микросервисы 

в своем пет-проекте лучше выбрать микросервисы 



микросервисы сложнее разрабатывать, чем монолит 

по канонам - у каждого микросервиса должна быть своя база данных 



сообщество где шпаргалка по микросервисам и другие материалы -
https://www.faang.school/community

бесплатный курс по Java Core - 
https://www.faang.school/java-magics 



******************************************

неделя 2 - день 5 (29.08.2025) - 

HTTPS - 
https://selectel.ru/blog/http-request/

Данные между клиентом и сервером в рамках работы протокола передаются с помощью HTTP-сообщений. Они бывают двух видов:

- Запросы (HTTP Requests) — сообщения, которые отправляются клиентом на сервер, чтобы вызвать выполнение некоторых действий. Зачастую для получения доступа к определенному ресурсу. Основой запроса является HTTP-заголовок.

- Ответы (HTTP Responses) — сообщения, которые сервер отправляет в ответ на клиентский запрос.



Само по себе сообщение представляет собой информацию в текстовом виде, записанную в несколько строчек.

В целом, как запросы HTTP, так и ответы имеют следующую структуру:

1 - Стартовая строка (start line) — используется для описания версии используемого протокола и другой информации — вроде запрашиваемого ресурса или кода ответа. Как можно понять из названия, ее содержимое занимает ровно одну строчку.

2 - HTTP-заголовки (HTTP Headers) — несколько строчек текста в определенном формате, которые либо уточняют запрос, либо описывают содержимое тела сообщения.

3 - Пустая строка, которая сообщает, что все метаданные для конкретного запроса или ответа были отправлены.

4 - Опциональное тело сообщения, которое содержит данные, связанные с запросом, либо документ (например HTML-страницу), передаваемый в  ответе.



Рассмотрим атрибуты HTTP-запроса подробнее - 



1. Стартовая строка
Стартовая строка HTTP-запроса состоит из трех элементов:

- Метод HTTP-запроса (method, реже используется термин verb). Обычно это короткое слово на английском, которое указывает, что конкретно нужно сделать с запрашиваемым ресурсом. Например, метод GET сообщает серверу, что пользователь хочет получить некоторые данные, а POST — что некоторые данные должны быть помещены на сервер.

- Цель запроса. Представлена указателем ресурса URL, который состоит из протокола, доменного имени (или IP-адреса), пути к конкретному ресурсу на сервере. Дополнительно может содержать указание порта, несколько параметров HTTP-запроса и еще ряд опциональных элементов.

- Версия используемого протокола (либо HTTP/1.1, либо HTTP/2), которая определяет структуру следующих за стартовой строкой данных.
В примере ниже стартовая строка указывает, что в качестве метода используется GET, обращение будет произведено к ресурсу /index.html, по версии протокола HTTP/1.1:
--
GET /index.html HTTP/1.1
----



Методы -
Методы позволяют указать конкретное действие, которое мы хотим, чтобы сервер выполнил, получив наш запрос. Так, некоторые методы позволяют браузеру (который в большинстве случаев является источником запросов от клиента) отправлять дополнительную информацию в теле запроса — например, заполненную форму или документ.



Метод - описание - 

GET - Позволяет запросить некоторый конкретный ресурс. Дополнительные данные могут быть переданы через строку запроса (Query String) в составе URL (например ?param=value).О составляющих URL мы поговорим чуть позже.

POST - Позволяет отправить данные на сервер. Поддерживает отправку различных типов файлов, среди которых текст, PDF-документы и другие типы данных в двоичном виде. Обычно метод POST используется при отправке информации (например, заполненной формы логина) и загрузке данных на веб-сайт, таких как изображения и документы.

HEAD - Здесь придется забежать немного вперед и сказать, что обычно сервер в ответ на запрос возвращает заголовок и тело, в котором содержится запрашиваемый ресурс. Данный метод при использовании его в запросе позволит получить только заголовки, которые сервер бы вернул при получении GET-запроса к тому же ресурсу. Запрос с использованием данного метода обычно производится для того, чтобы узнать размер запрашиваемого ресурса перед его загрузкой.

PUT - Используется для создания (размещения) новых ресурсов на сервере. Если на сервере данный метод разрешен без надлежащего контроля, то это может привести к серьезным проблемам безопасности.

DELETE - Позволяет удалить существующие ресурсы на сервере. Если использование данного метода настроено некорректно, то это может привести к атаке типа «Отказ в обслуживании» (Denial of Service, DoS) из-за удаления критически важных файлов сервера.

OPTIONS - Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов.

PATCH - Позволяет внести частичные изменения в указанный ресурс по указанному расположению.



URL

Получение доступа к ресурсам по HTTP-протоколу осуществляется с помощью указателя URL (Uniform Resource Locator). URL представляет собой строку, которая позволяет указать запрашиваемый ресурс и еще ряд параметров.

Использование URL неразрывно связано с другими элементами протокола, поэтому далее мы рассмотрим его основные компоненты и строение:

Поле Scheme используется для указания используемого протокола, всегда сопровождается двоеточием и двумя косыми чертами (://).

Host указывает местоположение ресурса, в нем может быть как доменное имя, так и IP-адрес.

Port, как можно догадаться, позволяет указать номер порта, по которому следует обратиться к серверу. Оно начинается с двоеточия (:), за которым следует номер порта. При отсутствии данного элемента номер порта будет выбран по умолчанию в соответствии с указанным значением Scheme (например, для http:// это будет порт 80).

Далее следует поле Path. Оно указывает на ресурс, к которому производится обращение. Если данное поле не указано, то сервер в большинстве случаев вернет указатель по умолчанию (например index.html).

Поле Query String начинается со знака вопроса (?), за которым следует пара «параметр-значение», между которыми расположен символ равно (=). В поле Query String могут быть переданы несколько параметров с помощью символа амперсанд (&) в качестве разделителя.

Не все компоненты необходимы для доступа к ресурсу. Обязательно следует указать только поля Scheme и Host.



Версии HTTP

Раз уж мы упомянули версию протокола как элемента стартовой строки, то стоит сказать об основных отличиях версий HTTP/1.X от HTTP/2.X.

Последняя стабильная, наиболее стандартизированная версия протокола первого поколения (версия HTTP/1.1) вышла в далеком 1997 году. Годы шли, веб-страницы становились сложнее, некоторые из них даже стали приложениями в том виде, в котором мы понимаем их сейчас. Кроме того, объем медиафайлов и скриптов, которые добавляли интерактивность страницам, рос. Это, в свою очередь, создавало перегрузки в работе протокола версии HTTP/1.1.

Стало очевидно, что у HTTP/1.1 есть ряд значительных недостатков:

- Заголовки, в отличие от тела сообщения, передавались в несжатом виде.

- Часто большая часть заголовков в сообщениях совпадала, но они продолжали передаваться по сети.

- Отсутствовала возможность так называемого мультиплексирования — механизма, позволяющего объединить несколько соединений в один поток данных. Приходилось открывать несколько соединений на сервере для обработки входящих запросов.

С выходом HTTP/2 было предложено следующее решение: HTTP/1.X-сообщения разбивались на так называемые фреймы, которые встраивались в поток данных.

Фреймы данных (тела сообщения) отделялись от фреймов заголовка, что позволило применять сжатие. Вместе с появлением потоков появился и ранее описанный механизм мультиплексирования — теперь можно было обойтись одним соединением для нескольких потоков.

Единственное о чем стоит сказать в завершение темы: HTTP/2 перестал быть текстовым протоколом, а стал работать с «сырой» двоичной формой данных. Это ограничивает чтение и создание HTTP-сообщений «вручную». Однако такова цена за возможность реализации более совершенной оптимизации и повышения производительности.



Заголовки

HTTP-заголовок представляет собой строку формата «Имя-Заголовок:Значение», с двоеточием(:) в качестве разделителя. Название заголовка не учитывает регистр, то есть между Host и host, с точки зрения HTTP, нет никакой разницы. Однако в названиях заголовков принято начинать каждое новое слово с заглавной буквы. Структура значения зависит от конкретного заголовка. Несмотря на то, что заголовок вместе со значениями может быть достаточно длинным, занимает он всего одну строчку.

В запросах может передаваться большое число различных заголовков, но все их можно разделить на три категории:

1 - Общего назначения, которые применяются ко всему сообщению целиком.

2 - Заголовки запроса уточняют некоторую информацию о запросе, сообщая дополнительный контекст или ограничивая его некоторыми логическими условиями.

3 - Заголовки представления, которые описывают формат данных сообщения и используемую кодировку. Добавляются к запросу только в тех случаях, когда с ним передается некоторое тело.



Самые частые заголовки запроса

Заголовок - описание -

Host - Используется для указания того, с какого конкретно хоста запрашивается ресурс. В качестве возможных значений могут использоваться как доменные имена, так и IP-адреса. На одном HTTP-сервере может быть размещено несколько различных веб-сайтов. Для обращения к какому-то конкретному требуется данный заголовок.

User-Agent - Заголовок используется для описания клиента, который запрашивает ресурс. Он содержит достаточно много информации о пользовательском окружении. Например, может указать, какой браузер используется в качестве клиента, его версию, а также операционную систему, на которой этот клиент работает.

Refer - Используется для указания того, откуда поступил текущий запрос. Например, если вы решите перейти по какой-нибудь ссылке в этой статье, то вероятнее всего к запросу будет добавлен заголовок Refer: https://selectel.ru

Accept - Позволяет указать, какой тип медиафайлов принимает клиент. В данном заголовке могут быть указаны несколько типов, перечисленные через запятую (‘ , ‘). А для указания того, что клиент принимает любые типы, используется следующая последовательность — */*.

Cookie - Данный заголовок может содержать в себе одну или несколько пар «Куки-Значение» в формате cookie=value. Куки представляют собой небольшие фрагменты данных, которые хранятся как на стороне клиента, так и на сервере, и выступают в качестве идентификатора. Куки передаются вместе с запросом для поддержания доступа клиента к ресурсу. Помимо этого, куки могут использоваться и для других целей, таких как хранение пользовательских предпочтений на сайте и отслеживание клиентской сессии. Несколько кук в одном заголовке могут быть перечислены с помощью символа точка с запятой (‘ ; ‘), который  используется как разделитель.

Authorization - Используется в качестве еще одного метода идентификации клиента на сервере. После успешной идентификации сервер возвращает токен, уникальный для каждого конкретного клиента. В отличие от куки, данный токен хранится исключительно на стороне клиента и отправляется клиентом только по запросу сервера. Существует несколько типов аутентификации, конкретный метод определяется тем веб-сервером или веб-приложением, к которому клиент обращается за ресурсом.



Тело запроса

Завершающая часть HTTP-запроса — это его тело. Не у каждого HTTP-метода предполагается наличие тела. Так, например, методам вроде GET, HEAD, DELETE, OPTIONS обычно не требуется тело. Некоторые виды запросов  могут отправлять данные на сервер в теле запроса: самый распространенный из таких методов — POST.



Ответы HTTP

HTTP-ответ является сообщением, которое сервер отправляет клиенту в ответ на его запрос. Его структура равна структуре HTTP-запроса: стартовая строка, заголовки и тело.



Строка статуса (Status line)

Стартовая строка HTTP-ответа называется строкой статуса (status line). На ней располагаются следующие элементы:

1 - Уже известная нам по стартовой строке запроса версия протокола (HTTP/2 или HTTP/1.1).

2 - Код состояния, который указывает, насколько успешно завершилась обработка запроса.

3 - Пояснение — короткое текстовое описание к коду состояния. Используется исключительно для того, чтобы упростить понимание и восприятие человека при просмотре ответа.
--
HTTP/1.1 200 OK 
----



Коды состояния и текст статуса

Коды состояния HTTP используются для того, чтобы сообщить клиенту статус их запроса. HTTP-сервер может вернуть код, принадлежащий одной из пяти категорий кодов состояния:

Категория - описание - 

1xx - Коды из данной категории носят исключительно информативный характер и никак не влияют на обработку запроса.

2xx - Коды состояния из этой категории возвращаются в случае успешной обработки клиентского запроса.

3xx - Эта категория содержит коды, которые возвращаются, если серверу нужно перенаправить клиента.

4xx - Коды данной категории означают, что на стороне клиента был отправлен некорректный запрос. Например, клиент в запросе указал не поддерживаемый метод или обратился к ресурсу, к которому у него нет доступа.

5xx - Ответ с кодами из этой категории приходит, если на стороне сервера возникла ошибка.



Полный список кодов состояния доступен в спецификации к протоколу, ниже приведены только самые распространенные коды ответов:

Категория - описание - 

200 OK - Возвращается в случае успешной обработки запроса, при этом тело ответа обычно содержит запрошенный ресурс.

302 Found - Перенаправляет клиента на другой URL. Например, данный код может прийти, если клиент успешно прошел процедуру аутентификации и теперь может перейти на страницу своей учетной записи.

400 Bad Request - Данный код можно увидеть, если запрос был сформирован с ошибками. Например, в нем отсутствовали символы завершения строки.

403 Forbidden - Означает, что клиент не обладает достаточными правами доступа к запрошенному ресурсу. Также данный код можно встретить, если сервер обнаружил вредоносные данные, отправленные клиентом в запросе.

500 Internal Error - Данный код возвращается сервером, когда он не может по определенным причинам обработать запрос.



Помимо основных кодов состояния, описанных в стандарте, существуют и коды состояния, которые объявляются крупными сетевыми провайдерами и серверными платформами.



Заголовки ответа

Response Headers, или заголовки ответа, используются для того, чтобы уточнить ответ, и никак не влияют на содержимое тела. Они существуют в том же формате, что и остальные заголовки, а именно  «Имя-Значение» с двоеточием (:) в качестве разделителя.

Ниже приведены наиболее часто встречаемые в ответах заголовки:

Категория - Пример - Описание - 

Server - Server: ngnix - Содержит информацию о сервере, который обработал запрос. 

Set-Cookie - Set-Cookie:PHPSSID=bf42938f - Содержит куки, требуемые для идентификации клиента. Браузер парсит куки и сохраняет их в своем хранилище для дальнейших запросов.

WWW-Authenticate - WWW-Authenticate: BASIC realm=»localhost» - Уведомляет клиента о типе аутентификации, который необходим для доступа к запрашиваемому ресурсу.



Тело ответа

Последней частью ответа является его тело. Несмотря на то, что у большинства ответов тело присутствует, оно не является обязательным. Например, у кодов «201 Created» или «204 No Content» тело отсутствует, так как достаточную информацию для ответа на запрос они передают в заголовке.



Безопасность HTTP-запросов, или что такое HTTPs

HTTP является расширяемым протоколом, который предоставляет огромное количество возможностей, а также поддерживает передачу всевозможных типов файлов. Однако, вне зависимости от версии, у него есть один существенный недостаток, который можно заметить если перехватить отправленный HTTP-запрос -  данные передаются в открытом виде. HTTP сам по себе не предоставляет никаких средств шифрования.

HTTPs (HyperText Transfer Protocol, secure) является расширением HTTP-протокола, который позволяет шифровать отправляемые данные, перед тем как они попадут на транспортный уровень. Данный протокол по умолчанию использует порт 443.

Если мы перехватим не HTTP , а HTTPs-запрос, то не увидим здесь ничего интересного.

Данные передаются в едином зашифрованном потоке, что делает невозможным получение учетных данных пользователей и прочей критической информации средствами обычного перехвата.

Если хотите подробнее узнать о деталях работы протокола, читайте статью в нашем блоге - 
https://selectel.ru/blog/http-https/



Как отправить HTTP-запрос и прочитать его ответ 

Теория это, конечно, отлично, но ничего так хорошо не закрепляет материал, как практика

Мы рассмотрим несколько способов, как написать HTTP-запрос в браузер, послать HTTP-запрос на сервер и получить ответ:
1 - Инструменты разработчика в браузере. 
2 - Утилита cURL.



Инструменты разработчика

Основной программой на наших устройствах, которая работает с HTTP-протоколом, в большинстве случаев является браузер. Помимо обычных пользователей, с браузерами часто работают и разработчики веб-приложений. Именно их инструментами мы воспользуемся для работы с запросами и ответами.

По нажатию комбинации клавиш [Ctrl+Shift+I] или просто [F12] в подавляющем большинстве современных браузеров у нас откроется окно инструментов разработчика, которая представляет собой панель с несколькими вкладками. Нужная нам вкладка обычно называется Network. Перейдем в нее, а в адресной строке введем URL того сайта, на который хотим попасть. В качестве примера воспользуемся сайтом блога Selectel — https://selectel.ru/blog/.

После нажатия Enter сайт начнет загружаться, а открытая вкладка Network — заполняться различными элементами, начиная все больше напоминать приборную панель самолета.

Не спешите пугаться. Это всего лишь список ресурсов, которые нужны для правильного отображения и работы сайта.

Нажав на любой из них, мы можем увидеть детали обработки отправленного запроса

В данном запросе, например:
- URL, к которому было совершено обращение — https://selectel.ru/blog,
- Метод, который был использован в запросе — GET,
- И в качестве кода возврата сервер вернул нам страницу с кодом статуса — 200 OK 



После запуска утилита выполняет: 
- подключение к серверу, 
- самостоятельно разрешает все вопросы, необходимые для отправки запроса по HTTPs, 
- отправляет запрос, содержимое которого мы можем видеть благодаря флагу -v,
- принимая ответ от сервера, отображает его в командной строке «как-есть».  

Помимо этого, у данной утилиты есть огромное количество опций, которые предоставляют возможности по детальной настройке отправляемых запросов. Все эти возможности и делают ее такой популярной у веб-разработчиков и других специалистов, которым приходится работать с протоколом HTTP.

HTTP представляет собой расширяемый протокол прикладного уровня, на котором работает весь веб-сегмент интернета.



******************************************

неделя 2 - день 6 (30.08.2025) - 

API - 
https://habr.com/ru/articles/464261/

видео про API - 
https://www.youtube.com/watch?v=QYg5z6EGOk4

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это». Если переводить на русский, это было бы слово «договор». Договор между двумя сторонами, как договор на покупку машины:
- мои обязанности — внести такую то сумму,
- обязанность продавца — дать машину.

API отвечает на вопрос “Как ко мне, к моей системе можно обратиться?”, и включает в себя:
- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

API — это набор функций. Это может быть одна функция, а может быть много.

можно группировать API по функционалу. То есть:
- отдельно API для входа в систему, где будет регистрация и авторизация;
- отдельно API для отчетности — отчет 1, отчет 2, отчет 3… отчет N. Для разных отчетов у нас разные формулы = разные функции. И все мы их собираем в один набор, api для отчетности.
- отдельно API платежек — для работы с каждым банком своя функция.
- ...

Можно не группировать вообще, а делать одно общее API.

Можно сделать одно общее API, а остальные «под заказ». Если у вас коробочный продукт, то в него обычно входит набор стандартных функций. А любые хотелки заказчиков выносятся отдельно.

в нашей системе есть несколько разных API, на каждое из которых у нас написан контракт. В каждом контракте четко прописано, какие операции можно выполнять, какие функции там будут

И конечно, функции можно переиспользовать. То есть одну и ту же функцию можно включать в разные наборы, в разные апи. Никто этого не запрещает.

разработчик придумывает, какое у него будет API. Либо делает общее, либо распределяет по функционалу или каким-то своим критериям, и в каждое апи добавляет тот набор функций, который ему необходим.

API — это Application programming interface. Почему ты тогда говоришь о контракте, хотя там слово интерфейс? Да потому, что в программировании контракт — это и есть интерфейс. В классическом описании ООП (объектно-ориентированного программирования) есть 3 кита:
- Инкапсуляция
- Наследование
- Полиморфизм

Инкапсуляция — это когда мы скрываем реализацию. Для пользователя все легко и понятно. Нажал на кнопочку — получил отчет. А как это работает изнутри — ему все равно. Какая база данных скрыта под капотом? Oracle? MySQL? На каком языке программирования написана программа? Как именно организован код? Не суть. Программа предоставляет интерфейс, им он и пользуется.

Не всегда программа предоставляет именно графический интерфейс. Это может быть SOAP, REST интерфейс, или другое API. Чтобы использовать этот интерфейс, вы должны понимать:
- что подать на вход;
- что получается на выходе;
- какие исключения нужно обработать.

Пользователи работают с GUI — graphical user interface. Программы работают с API — Application programming interface. Им не нужна графика, только контракт.

Как вызывается API - Вызвать апи можно как напрямую, так и косвенно.

Напрямую:
- Система вызывает функции внутри себя
- Система вызывает метод другой системы
- Человек вызывает метод
- Автотесты дергают методы

Косвенно:
- Пользователь работает с GUI



Вызов API напрямую -



1. Система вызывает функции внутри себя

Разные части программы как-то общаются между собой. Они делают это на программном уровне, то есть на уровне API! Это самый «простой» в использовании способ, потому что автор API, которое вызывается — разработчик. И он же его потребитель, но проблемы с документацией есть всегда. Просто в этом случае в качестве документации будут комментарии в коде. А они, увы, тоже бывают неактуальны. Или разработчики разные, или один, но уже забыл, как делал исходное api и как оно должно работать…



2. Система вызывает метод другой системы

А вот это типичный кейс, которые тестируют тестировщики в интеграторах. Или тестировщики, которые проверяют интеграцию своей системы с чужой. Одна система дергает через api какой-то метод другой системы. Она может попытаться получить данные из другой системы. Или наоборот, отправить данные в эту систему. Допустим, я решила подключить подсказки из Дадаты к своему интернет-магазинчику, чтобы пользователь легко ввел адрес доставки. 
Я подключаю подсказки по API. И теперь, когда пользователь начинает вводить адрес на моем сайте, он видит подсказки из Дадаты. Как это получается:
- Он вводит букву на моем сайте
- Мой сайт отправляет запрос в подсказки Дадаты по API
- Дадата возвращает ответ
- Мой сайт его обрабатывает и отображает результат пользователю

Вон сколько шагов получилось! И так на каждый введенный символ. Пользователь не видит этого взаимодействия, но оно есть. И, конечно, не забываем про кейс, когда мы разрабатываем именно API-метод. Который только через SOAP и можно вызвать, в интерфейсе его нигде нет.

Пример можно посмотреть в Users. Метод MagicSearch создан на основе реальных событий - 
https://testbase.atlassian.net/wiki/spaces/USERS/pages/1249378773/MagicSearch

в самой системе в пользовательском интерфейсе есть только обычный поиск, просто строка ввода. Ну, может, парочка фильтров. А вот для интеграции нужна была целая куча доп возможностей, что и было сделано через SOAP-метод.

Функционал супер-поиска доступен только по API, пользователь в интерфейсе его никак не пощупает.

В этом случае у вас обычно есть ТЗ, согласно которому работает API-метод. Ваша задача — проверить его. Типичная задача тестировщика, просто добавьте к стандартным тестам на тест-дизайн особенности тестирования API, и дело в шляпе!



3. Человек вызывает метод

Причины разные:
- Для ускорения работы
- Для локализации бага (проблема где? На сервере или клиенте?)
- Для проверки логики без докруток фронта

Если система предоставляет API, обычно проще дернуть его, чем делать то же самое через графический интерфейс. Тем более что вызов API можно сохранить в инструменте. Один раз сохранил — на любой базе применяешь, пусть даже она по 10 раз в день чистится.

Для примера снова идем в Users (https://okiseleva.blogspot.com/2017/04/users-soap-rest.html). Если мы хотим создать пользователя, надо заполнить уйму полей!

Конечно, это можно сделать с помощью специальных плагинов типа Form Filler (https://okiseleva.blogspot.com/2019/04/form-filler.html). Но что, если вам нужны адекватные тестовые данные под вашу систему? И на русском языке?

Заполнение полей вручную — грустно и уныло! А уж если это надо повторять каждую неделю или день на чистой тестовой базе — вообще кошмар. Это сразу первый приоритет на автоматизацию рутинных действий.

И в данном случае роль автоматизатора выполняет… Postman. Пользователя можно создать через REST-запрос CreateUser (https://testbase.atlassian.net/wiki/spaces/USERS/pages/871924071/CreateUser). Один раз прописали нормальные “как настоящие” данные, каждый раз пользуемся. Профит!

Вместо ручного заполнения формы (1 минута бездумного заполнения полей значениями «лпрулпк») получаем 1 секунду нажатия на кнопку «Send». При этом значения будут намного адекватнее.

А еще в постмане можно сделать отдельную папку подготовки тестовой базы, напихать туда десяток запросов. И вот уже на любой базе за пару секунд вы получаете столько данных, сколько вручную вбивали бы часами!

Если вы нашли баг и не понимаете, на кого его вешать — разработчика front-end или back-end, уберите все лишнее. Вызовите метод без графического интерфейса. А еще вы можете тестировать логику программы, пока интерфейс не готов или сломан.



4. Автотесты дергают методы

Есть типичная пирамида автоматизации:
- GUI-тесты — честный тест, «как это делал бы пользователь».
- API-тесты — опускаемся на уровень ниже, выкидывая лишнее.
- Unit-тесты — тесты на отдельную функцию

Слово API как бы намекает на то, что будет использовано в тестах

Допустим, у нас есть:
- операция: загрузка отчета;
- на входе: данные из ручных или автоматических корректировок или из каких-то других мест;
- на выходе: отчет, построенный по неким правилам

Правила построения отчета:
Ячейка 1: Х — Y
Ячейка 2: Z * 6
...

Пирамида автоматизации - 
- UI - открыть браузер, кликнуть кнопочку
- API - загрузить отчет 
- Unit - забрать данные из А

GUI-тесты — честный тест, робот делает все, что делал бы пользователь. Открывает браузер, тыкает на кнопочки… Но если что-то упадет, будете долго разбираться, где именно.

API-тесты — все то же самое, только без браузера. Мы просто подаем данные на вход и проверяем данные на выходе. Например, можно внести итоговый ответ в эксельку, и пусть робот выверяет ее, правильно ли заполняются данные? Локализовать проблему становится проще.

Unit-тесты — это когда мы проверяем каждую функцию отдельно. Отдельно смотрим расчет для ячейки 1, отдельно — для ячейки 2, и так далее. Такие тесты шустрее всего гоняются и баги по ним легко локализовать.



Косвенный вызов API

Когда пользователь работает с GUI, на самом деле он тоже работает с API. Просто не знает об этом, ему это просто не нужно. То есть когда пользователь открывает систему и пытается загрузить отчет, ему не важно, как работает система, какой там magic внутри. У него есть кнопочка «загрузить отчет», на которую он и нажимает. Пользователь работает через GUI (графический пользовательский интерфейс).

Но на самом деле под этим графическим пользовательским интерфейсом находится API. И когда пользователь нажимает на кнопочку, кнопочка вызывает функцию построения отчета.

А функция построения отчета уже может вызывать 10 разных других функций, если ей это необходимо.

И вот уже пользователь видит перед собой готовый отчет. Он вызвал сложное API, даже не подозревая об этом!



Что значит «Тестирование API»

В первую очередь, мы подразумеваем тестирование ЧЕРЕЗ API. «Тестирование API» — общеупотребимый термин, так действительно говорят, но технически термин некорректен. Мы не тестируем API, мы не тестируем GUI (графический интерфейс). Мы тестируем какую-то функциональность через графический или программный интерфейс.

Но это устоявшееся выражение. Можно использовать его и говорить “тестирование API”. И когда мы про это говорим, мы имеем в виду:
- автотесты на уровне API
- или интеграцию между двумя разными системами.

Интеграция — когда одна система общается с другой по какому-то протоколу передачи данных. Это называется Remote API, то есть общение по сети, по некоему протоколу (HTTP, JMS и т.д.). В противовес ему есть еще Local API (он же «Shared memory API») — это то API, по которому программа общается сама с собой или общается с другой программой внутри одной виртуальной памяти.

Когда мы говорим про тестирование API, чаще всего мы подразумеваем тестирование Remote API. Когда у нас есть две системы, находящихся на разных компьютерах, которые как-то между собой общаются. И если вы видите в вакансии «тестирование API», скорее всего это подразумевает умение вызвать SOAP или REST сервис и протестировать его.



Резюме

API (Application programming interface) — это контракт, который предоставляет программа. «Ко мне можно обращаться так и так, я обязуюсь делать то и это».

Контракт включает в себя:
- саму операцию, которую мы можем выполнить,
- данные, которые поступают на вход,
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке).

Вызвать API можно как напрямую, так и косвенно:
- Система вызывает функции внутри себя
- Система вызывает метод другой системы
- Человек вызывает метод
- Автотесты дергают методы
- Пользователь работает с GUI

Когда говорят про API с тестировщиком, обсуждают два варианта:
- автотесты на уровне API (умение автоматизировать)
- интеграцию между двумя разными системами (обычно SOAP или REST, то есть работу в SOAP Ui или Postman).

Если вы хотите отработать второй вариант и поучиться отправлять запросики — используйте бесплатную систему Users (https://okiseleva.blogspot.com/2017/04/users-soap-rest.html)! И мои обучающие видосики, например, «Как отправить REST-запрос за 5 минут» - 
https://www.youtube.com/watch?v=U7-8ZmCBiPI&lc=z23qdpgwsv3wxzbsqacdp431jrsmac0ukr1vpbosgz1w03c010c



******************************************

неделя 2 - день 7 (31.08.2025) - 

ньюансы тестирования КСА (клиент-серверной архитектуры) - 
https://habr.com/ru/articles/495698/


Клиент — та программа, с которой работает пользователь. Он знать не знает, это у него на компьютере программа целиком, или где-то за ней прячутся сервер с базой, а то и целый RAID. Он работает в браузере или с desktop-приложением. И всё, что ему нужно знать — это «куда тут тыкать».

Клиенту не нужно много памяти, места на диске и других ресурсов. Поэтому рабочие места относительно дешево стоят. А это именно то, что нам нужно, особенно если нужно закупить оборудование для тысяч операционисток банка.

Сервер — компьютер, на котором хранится само приложение. Весь код, вся логика, все дополнительные материалы и справочники. Например, справочник адресов ФИАС или справочник юр лиц ЕГРЮЛ — они тоже занимают место, как сами по себе, так и в памяти приложения.

Иногда говорят «сервер приложения» и «сервер БД». Это нормально, ведь фактически сервер — это просто машина, компьютер. А базу и сервер приложения обычно хранят на разных машинах, ради безопасности. В таком случае, если говорят «сервер приложения» — речь о втором звене нашей схемы.

Приложения бывают самые разные. Есть ресурсоемкие, им нужно много памяти и места на диске. Есть «легкие», которые можно развернуть даже на домашнем компьютере.

БД (база данных) — хранилище данных. Тут вы можете легко поискать информацию + уверены в том, что она сохранится, даже если в приложении что-то сломается. Подробнее о ней — в статье «Что такое База Данных (БД)» - 
https://habr.com/ru/post/555760/

Сколько места нужно под базу, зависит от количества данных. Есть огромные базы в банках, где и 1тб будет мало. А есть совсем небольшие, которые вы можете установить на своей машине. Например, XAMPP можно поставить. И врядли вы напихаете туда столько данных, что у вас не останется под них место.

Отдельной базы может не быть, тогда структура станет двузвенной: клиент-сервер. И все!

Схема условная, в реальной жизни у нас как минимум будет больше клиентов. А если приложение высоконагруженное, то будет несколько серверов и несколько баз данных



Перед серверами ставят балансировщик, и клиент шлет запрос туда. Сколько бы серверов не поставили в кластер, клиенту это не интересно. У него есть один URL — адрес балансировщика.

Такая схема используется для высоконагруженного приложения — когда запросов поступает так много, что один сервер с ними просто не справляется.

Facebook, amazon, google — туда заходят миллионы пользователей. Один сервер с ними не справится. Поэтому ставят кластер, а балансировщик делит между ними нагрузку. И в таком случае в кластере может быть не 2 сервера, а 10, 15, сколько нужно, столько и ставим.

При этом мы можем точно также балансировать базу данных. У нас может быть несколько копий баз данных на самых разных машинах, и балансировщик отправляет запросы то к одной, то ко второй.

Такая схема называется горячий резерв — когда у нас есть несколько серверов, работающих в параллель, и балансировщик распределяет нагрузку между ними.

При этом может быть и схема холодного резерва — когда у нас второй сервер является резервной копией «на всякий случай». Все запросы идут на первый сервер, второй отдыхает.

Но если с первым сервером что-то случится и он помрет, балансировщик перенаправит нагрузку на второй сервер

В это время у администраторов будет время разобраться с проблемой на сервере 1.

Схема холодного резерва используется тогда, когда один сервер способен выдержать нагрузку и выдавать хорошую скорость работы. Но приложение при этом бизнес-критичное и простой неприемлем.

Простой может быть не только потому, что случилось что-то плохое. Есть еще штатное обновление приложения. Обе схемы резервирования позволяют обновляться безболезненно.



Сервера стоят дорого. Туда нельзя поставить обычный SSD как для домашнего компьютера. Почему? Потому что к железу для серверов совсем другие требования по надежности + есть поддержка специфичных функций -

— у HDD это специальная микропрограмма контроллера, которая оптимизирована для работы диска в RAID, дома это не нужно.

— у SSD это наличие группы конденсаторов, которые хранят энергию на случай отключения питания, чтобы хватило времени скинуть из DDR кэша данные в энергонезависимую память и данные не побились.

SSD — быстро работающий диск, HDD — обычный. RAID — когда мы N дисков вместе соединили, а DDR кэш — это оперативная память

По цене отличаются в 2 раза. Например, SSD:
- для дома гигабайт стоит 16,53р
- для сервера энтерпрайз гиг стоит 32 рубля



Чтобы понимать, что тестировать, надо понимать, с чем имеет дело человек.

Пользователь работает с клиентом. Это может быть web или desktop приложение, не суть. Операционистке Кате дали рабочее место, показали какую программу запускать и как с ней работать. Она знать не знает о наличии серверов и БД, она работает только с клиентом.

Поэтому тестировщик в первую очередь проверяет клиент! Потому что сервер может работать идеально, вы можете даже написать тесты на уровне API и они все будут зелененькие, и кажется, что все зашибись! А пользователь загрузит отчет и увидит ошибку. Ой.

Сервер работает, на клиенте ошибка. И плевать на сотни «зеленых» автотестов. У пользователя все равно ошибка. И наша задача — посмотреть с его точки зрения.

Однако, если у вас есть доступ к серверу приложения и его базе данных — стоит проверять и их тоже! Так мы можем увидеть «будущий баг». Например:
- Сохранили карточку товара — система ее отрисовывает и говорит, что все хорошо. На клиенте все отлично!
- Проверили по базе — а там часть полей осталась пустая, разработчик неправильно указал название поля в БД. И информация потерялась.



То, что сейчас пользователь видит в клиенте — это просто кеш, «что ввел, то и отображаю». Если не проверить по базе, такая проблема может даже вскрыться не сразу. Пользователь открывает карточку товара — часть полей не заполнена:
— Ну, наверное, их и не заполняли.
А их заполняли! Просто сохранение криво сработало. Поэтому, если у нас только черный ящик, то нужно проверять, «а реально ли сохранились данные?». Сохранили? Откройте карточку в новом окне или вызовете информацию через API-метод.

Если доступ к базе есть — просто проверьте по ней, что все хорошо. Если есть доступ к серверным логам — проверьте их на наличие ошибок.



Тестировщик изучает уязвимости и потом рассказывает команде:
— Ребята, вот я проверил, у нас есть такие-то и такие-то потенциальные дыры. Давайте подумаем, надо нам их как-то закрывать или нет.

То есть не факт, что исправлять проблему будут. Может, у вас некритичное приложение — данные не утекут, деньги вы не храните. Тогда и заморачиваться лишний раз никто не будет, потому что тестировать на защищенность — дорого, специалистов мало.

Но какие-то базовые проверки типа sql-иньекций или XSS-атак стоит изучить и проверить на своем приложении. Хотя бы чтобы понять их критичность. Ведь если атака сломает клиент — ну и пусть, сам себе буратино. А если атака положит сервер, это уже не очень хорошо. И надо хотя бы знать, от чего это бывает.



******************************************

неделя 3 - день 1 (01.09.2025) - 

виды тестирования -
https://testengineer.ru/vidy-tipy-testirovaniya/

картинки с типами тестирования - 
telegram - my_coding - 01.09.2025 

Функциональные тесты могут выполняться вручную, или могут вполне успешно автоматизироваться (https://testengineer.ru/chto-takoe-avtomatizirovannoe-testirovanie/)

Часто применяемые инструменты функционального тестирования, с которые тестировщик должен уметь работать (или хотя бы ознакомиться поверхностно): 

- UFT (ранее известный как QTP) -
https://www.microfocus.com/en-us/products/unified-functional-automated-testing/overview

- Selenium -
https://www.seleniumhq.org/

- JUnit -
https://junit.org/junit5/

- SoapUI -
https://www.soapui.org/

- Watir -
http://watir.com/



Selenium — инструмент тестировщика №1, овладеть им — кажется, решающий момент в трудоустройстве, по крайней мере сейчас. Стремящийся стать QA-джуном должен знать (как минимум), о чем спрашивают на собеседовании по Selenium -
https://testengineer.ru/sobesedovanie-selenium-o-chem-sprashivajut/

Нефункциональное тестирование - это не о том, работает ли софт или нет, это о том, КАК он работает и как он выглядит.

Автоматизация применяется, и очень широко, поскольку нефункциональные тесты весьма сложны и длительны. Чаще всего автоматизируется тестирование производительности.

Виды (типы) нефункционального тестирования:
- Тестирование производительности
- Нагрузочное
- Безопасности
- Тестирование на отказ
- Совместимости
- Юзабилити-тестирование
- Масштабируемости
- Объемное тестирование
- Стресс-тестирование
- Удобства сопровождения
- Совместимости
- Общей эффективности
- Надежности
- Выносливости
- Тестирование восстановления после катастрофического отказа
- Тестирование локализации и интернационализации



Типы тестирования: общий список:



1 - Юнит-тестирование -
Другое название, менее распространенное, но более интуитивное — «модульное тестирование». Также встречается название «компонентное тестирование».
Проверка по отдельности каждого модуля (юнита). Она требует знания языка программирования, на котором написан код приложения, а также хорошего знания его архитектуры, «внутренностей». По этой причине, в большинстве случаев юнит-тесты пишут разработчики — создатели приложения.

Подробнее по теме:

- Что такое юнит-тестирование? -
https://testengineer.ru/unit-testirovanie/

- Очень подробный гайд по юнит-тестированию -
https://testengineer.ru/unit-testirovanie-guide/



2 - Интеграционное тестирование -
После интеграции модулей наступает черед интеграционного тестирования. Это проверка, как интегрированные, то есть уже соединенные в целостное приложение модули «сработались вместе». Таких тестов уже меньше, чем модульных.

Подробнее о пирамиде тестирования — здесь -
https://testengineer.ru/levels-of-software-testing/#-faq-why-pyramid

Часто используемые инструменты юнит и интеграционного тестирования: 

- Jasmine -
https://jasmine.github.io/

- Mocha -
https://jasmine.github.io/



Подробнее по интеграционному тестированию:

- Интеграционное тестирование -
https://testengineer.ru/integracionnoe-testirovanie/

- Юнит-тесты vs интеграционные тесты -
https://testengineer.ru/unit-testy-vs-integracionnye-testy/



3 - Сквозное тестирование -
E2E-тестирование это подтип функционального, проверка всей системы «из конца в конец», end-to-end, поэтому такое название. Таких тестов еще меньше количественно, но они еще сложнее чем интеграционные и тем более модульные (и требуют больше опыта от тестировщика).  

Инструменты, которые нужно освоить, чтобы претендовать на позицию E2E-QA: 

- Cucumber -
https://cucumber.io/

- Protractor -
https://www.protractortest.org/

- Jasmine -
https://jasmine.github.io/

- Karma -
https://karma-runner.github.io/1.0/index.html

- SpecFlow -
https://specflow.org/community/talking-about-specflow/

- Сквозное (end-to-end-тестирование) — гайд -
https://testengineer.ru/e2e-testirovanie/



4 - Тестирование интерфейса -
Тестирование GUI — проверка, отвечает ли интерфейс требованиям, изложенным в спецификациях; а также специальным гайдам владельца платформы — например, для мобильных приложений существуют специальные гайды, злостное несоблюдение которых грозит недопуском в магазин приложений, или исключением, если приложение уже там. 

Инструменты GUI-тестирования: 

- Monkey test for Android -
https://developer.android.com/studio/test/monkey.html

- Saucelabs -
https://saucelabs.com/

- Protractor -
http://www.protractortest.org/#/

- Тестированию GUI посвящен отдельный большой материал -
https://testengineer.ru/testirovanie-gui-polnoe-rukovodstvo/



5 - Тестирование доступности -
Проверка доступности, или легкости пользования людьми с ограничениями — но не только ими. Например, водителям тоже важно удобство/скорость/интуитивность, или специфические настройки в приложении; и вообще это важно любым людям, управляющим сложными механизмами. 

Приложение должно быть проверено на удобство для слабослышащих и слабовидящих людей, и людей с цветовой слепотой, и при необходимости откорректировано. Например, должна быть создана специальная «контрастная» цветовая схема.

Более подробно о таком специфическом типе тестирования — отдельный материал -
https://testengineer.ru/chto-takoe-testirovanie-dostupnosti/



6 - Альфа-тестирование -
Поиск всех ошибок и проблем в приложении в целом. Проводится на последнем этапе разработки, и внутри компании (в этом отличие от бета-тестирования). Проводится перед запуском продукта (передачей его заказчику). Цель: удостовериться, что юзер/клиент получит продукт, не содержащий багов.

Альфа-тестирование проводят в девелоперском окружении (а не в реальном пользовательском). Для имитации пользовательского окружения создается виртуальное окружение.

Что такое альфа-тестирование? - 
https://testengineer.ru/chto-takoe-alpha-testirovanie/



7 - Бета-тестирование -
Бета-тестирование проводится после альфа-, и перед запуском продукта. Для бета-тестирования нужно реальное пользовательское окружение. Выбирается ограниченное количество реальных пользователей-«добровольцев» (клиентов), которые, не будучи специалистами в QA, тестируют продукт на свое усмотрение. Затем они дают фидбек, и конструктивную критику, после чего разработчики, при необходимости, вносят изменения в так называемую бета-версию продукта. Далее исправленный и доработанный продукт поступает на релиз, то есть становится доступен всем пользователям.

Что такое бета-тестирование? -
https://testengineer.ru/chto-takoe-beta-testirovanie/



8 - Ad-hoc-тестирование -
Еще называемое интуитивным, поскольку проводится в «интуитивной» манере, на усмотрение тестировщика, без тест-кейсов, планов и другой оформляемой документации. Несистематичность — отличающий признак ад-хок-тестирования. 

Хотя искать баги без тест-кейсов может быть сложно, опытный тестировщик легко находит баги таким «свободным поиском», и нередко быстрее, чем «формализованным» способом. 

Отдельный материал по ad-hoc -
https://testengineer.ru/chto-takoe-ad-hoc-testirovanie/



9 - Тестирование совместимости -
Направлено на проверку совместимости продукта с операционными системами, браузерами, сетевыми окружениями, аппаратными конфигурациями, и т.п. Приложение должно работать во всех предусмотренных в его документации окружениях.

Например, Windows-приложение должно быть совместимым со всеми распространенными версиями ОС Windows. Если это веб-приложение, оно должно без проблем открываться во всех распространенных браузерах. Android-приложение нужно протестировать во всех распространенных в данный момент версиях ОС Android.

Подбор устройств для тестирования совместимости -
https://testengineer.ru/compatibility-testing/



10 - Тестирование обратной совместимости -
Проверка того, что новая (обновленная) версия приложения совместима с предыдущими версиями окружения, например операционными системами, в которых работает (или браузерами, в которых открывается веб-приложение).

Часто приложения обновляют, чтобы соответствовать изменившимся стандартам нового окружения, или чтобы «осовременить» общий стиль и вид приложения. Теперь нужно провести тестирование обратной совместимости — ведь пользователи «старой» версии этого окружения, которых может быть очень много, не должны терять возможность пользоваться приложением.



11 - Кроссбраузерное тестирование -
Или тестирование совместимости браузеров. Проверка, может ли веб-приложение (сайт) без проблем открываться во всех распространенных версиях браузеров. 

Такое тестирование, ввиду его трудоемкости, автоматизируют, применяя такие инструменты:

- CrossBrowserTesting -
https://crossbrowsertesting.com/

- LambdaTest -
https://www.lambdatest.com/

- Browsershots -
http://browsershots.org/

- Experitest -
https://experitest.com/

- Turbo Browser Sandbox -
https://turbo.net/browsers

- Ranorex Studio -
https://www.ranorex.com/cross-browser-testing-tools/

- Browsera -
http://www.browsera.com/

Более подробно об этом типе тестирования и об инструментах -
https://testengineer.ru/chto-takoe-kross-brauzernoe-testirovanie/

Большой материал по автоматизации такого тестирования -
https://testengineer.ru/chto-takoe-ad-hoc-testirovanie/



12 - Тестирование производительности -
Оценка общей производительности (продуктивности) приложения, выполняемая как правило при помощи специализированных инструментов, выявляющих проблемы в этой сфере:

- WebLOAD -
https://www.radview.com/

- LoadView -
https://www.loadview-testing.com/

- NeoLoad -
https://www.neotys.com/

- LoadNinja -
https://loadninja.com/

- Appvance -
https://www.appvance.ai/

- LoadRunner -
https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview

- Apache JMeter -
https://jmeter.apache.org/

- Loadster -
https://loadster.app/

- LoadImpact -
https://loadimpact.com/

- Testing Anywhere -
https://testanywhere.co/

- SmartMeter.io -
https://www.smartmeter.io/

- Tricentis Flood -
https://www.tricentis.com/resources/getting-started-with-load-testing-flood-io/

- Rational Performance Tester -
https://www.ibm.com/developerworks/downloads/r/rpt/index.html

- LoadComplete -
https://support.smartbear.com/loadcomplete/docs/index.html


Этой теме посвящен отдельный раздел нашего (бесплатного) Учебника - 
https://testengineer.ru/bolshoj-uchebnik-po-testirovaniyu/#performance

О тестировании веб-сервисов -
http://testengineer.ru/testirovanie-proizvoditelnosti-veb-servisov/



13 - Нагрузочное тестирование -
На систему подается нагрузка в виде запросов/одновременных «пользователей», которая позволяет оценить, какое количество нагрузки система способна обработать до того как начнет ухудшать свою производительность.

Часто применяемые нагрузочные инструменты:

- LoadRunner -
https://www.microfocus.com/en-us/products/loadrunner-load-testing/overview

- WebLoad -
https://www.radview.com/

- JMeter -
https://jmeter.apache.org/

Что такое нагрузочное тестирование -
https://testengineer.ru/nagruzocnoe-testirovanie/

Подробный обзор бесплатных инструментов нагрузочного тестирования -
https://testengineer.ru/besplatnye-instrumenty-dlya-nagruzochnogo-testirovaniya/



14 - Тестирование восстановления -
Проверка, может ли система восстанавливаться после сбоев, и как это происходит — как система возвращается к нормальному функционированию. Понятно, что от сбоев не застрахована ни одна програма — поэтому возможность сбоя должна быть предусмотрена, и проведена соответствующая подготовка. Программный продукт должен восстанавливаться быстро и «без потерь».



15 - Регрессионное тестирование -
Если система корректируется в процессе создания (что неизбежно), если в ее модули/функции вносятся изменения, то обязательно проверяют, не повлияли ли эти правки на функционирование системы.

Что такое регрессионное тестирование? -
http://testengineer.ru/regressionnoe-testirovanie/

Статья о проблемах с «регрессами» -
https://testengineer.ru/kak-uskorit-regress/



16 - Agile-тестирование -
Специфический тип QA-тестирования командой, работающей «по эджайлу», то есть с соблюдением так называемого манифеста Agile - (https://testengineer.ru/qa-junior-middle/#agile-in-simple:~:text=%D0%93%D0%BB%D0%B0%D0%B2%D0%BD%D1%8B%D1%85%20%D0%A6%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8%20%D0%B8%D0%B7-,%D0%9C%D0%B0%D0%BD%D0%B8%D1%84%D0%B5%D1%81%D1%82%D0%B0%20Agile,-.), 
и с учетом точки зрения пользователей в первую очередь.

Инструменты Agile QA:

- JIRA -
https://www.atlassian.com/software/jira

- PractiTest -
https://www.practitest.com/

- JunoOne -
https://juno.one/

- VersionOne -
https://www.versionone.com/versionone-vs-atlassian-jira-agile/

- TestRail -
https://www.gurock.com/testrail

- SoapUI -
https://www.soapui.org/



17 - Тестирование API -
Как и юнит-тестирование, этот тип относится к так называемому «code level testing», то есть имеет дело непосредственно с исходным кодом приложения. Разница с юнит- в том, что юнит-тесты обычно делают разработчики, а API тестирует QA-команда.

Гайд по тестированию API -
https://testengineer.ru/testirovanie-api/



18 - Тестирование черного ящика -
Нельзя не упомянуть в общем списке и такой тип. «Тестирование по черному ящику» это проверка функциональности без глубокого ознакомления с техническими «внутренностями» приложения, то есть не зная его исходный код и архитектуру.



19 - Тестирование белого ящика -
Проверка приложения со знанием его исходного кода и архитектуры.

О черном и белом ящиках, которые ждут Junior QA -
https://testengineer.ru/testirovanie-belogo-chernogo-yashchika/



20 - Тестирование безопасности -
Как понятно из названия, такие тесты гарантируют безопасность приложения/сайта; выявляют и предотвращают «дыры» в его подсистеме безопасности. Тестировщики, специализирующиеся на таком тестировании, работают как вручную, так и инструментами:

- Arachni -
http://www.arachni-scanner.com/

- Iron Wasp -
https://ironwasp.org/

- Nogotofail -
https://security.googleblog.com/2014/11/introducing-nogotofaila-network-traffic.html

- SQLMap -
http://sqlmap.org/

- W3af -
http://w3af.org/

- Wapiti -
http://wapiti.sourceforge.net/

- Wfuzz -
http://www.edge-security.com/wfuzz.php

- Zed Attack Proxy -
https://www.zaproxy.org/



21 - Юзабилити-тестирование
Оценка (и последующая коррекция) общего удобства пользования приложением/сайтом. Насколько приложение юзабельно, то есть «дружественно к пользователю»? 

Разумеется, на это нужно смотреть в первую очередь с точки зрения пользователя, а не члена ИТ-команды, и именно массового, «среднего пользователя»; поэтому к тестированию часто привлекают обычных людей-пользователей, «добровольцев» или за оплату. 

Как это делается, и много дополнительной информации по юзабилити, например чеклисты — в нашем большом гайде - 
https://testengineer.ru/usability-testing/
(Artsiom Rusau одобряет - https://t.me/qachanell/1776)



22 - Инструменты проверки юзабилити:

- Optimizely -
https://www.optimizely.com/

- Qualaroo - 
https://qualaroo.com/

- Crazy Egg - 
https://www.crazyegg.com/

- Usabilla - 
https://usabilla.com/

- Clicktale -
https://www.clicktale.com/default.aspx

- Five Second Test -
http://fivesecondtest.com/

- Chalkmark -
https://www.optimalworkshop.com/chalkmark

- UXtweak - 
https://www.uxtweak.com/



23 - Тестирование масштабируемости -
Легко ли масштабировать приложение? То есть, легко ли, и быстро ли, расширяются его возможности в программном и аппаратном измерении? Что произойдет, если количество пользователей, объемы данных, количество транзакций — возрастут в разы? Или десятки, сотни раз.

Тестирование масштабируемости - 
https://testengineer.ru/testirovanie-scalability/



24 - Тестирование надежности -
Насколько приложение надёжное, «выносливое»? Сколько времени оно сумеет проработать «без единого отказа», и при каких условиях происходит отказ? Что провоцирует ошибки в приложении?

Например, нужно не допустить ситуации, когда важная личная информация пользователей хранится в базе данных под управлением нашего приложения, и затем, после нескольких месяцев работы, эта информация удаляется, внезапно и бесповоротно, из-за каких-то ошибок в коде приложения, вовремя не выявленных. Выявлять и устранять подобные ошибки — задача тестирования надежности (reliability testing).

Тестирование стабильности -
https://testengineer.ru/testirovanie-stabilnosti/



25 - Приемочное тестирование -
Компания-клиент, получая готовый программный продукт, проводит приемочное тестирование (User Acceptance Testing = UAT). Оценивает, можно ли принимать софт, исходя из пользовательских требований и предпочтений. Если они не удовлетворены, или если просто клиенту не нравится что-либо в приложении, команде, работавшей над софтом, будет подан запрос на изменения.

Приемочное тестирование -
https://testengineer.ru/uat-testirovanie/



Это не все виды и типы QA-тестирования. Более полно — в нашем Учебнике (там уже более 220 материалов по QA, и мы практически каждый день пополняем его). Как говорят, feel free, не стесняйтесь пользоваться, там удобнее все классифицировано по разделам - 
https://testengineer.ru/bolshoj-uchebnik-po-testirovaniyu/



Подробнее об основных инструментах автоматизации тестирования можно почитать здесь — а также оценить «портрет среднего тестировщика» -
https://testengineer.ru/test-automation-tools/



Подписка на телеграм-канал, посвященный только и исключительно автоматизации QA —
https://t.me/qa_automation_it



Официальный канал TestEngineer -
https://t.me/godoftesting



******************************************

неделя 3 - день 2 (02.09.2025) - 

принципы тестирования -
https://crashtest.by/7-principles-of-testing/


7 принципов тестирования - 



1 - исчерпывающее тестирование невозможно -
Невозможно, либо нецелесообразно тестировать все возможные варианты и комбинации значений. Поэтому в тестировании мы используем анализ рисков и приоритетов, для того чтобы проверить наиболее показательные варианты значений. Для этого существуют техники тестирования (Test techniques), либо их ещё называют техники тест-дизайна (Test design techniques).



2 - принцип скопления дефектов -
В наименьшем количестве мест, находится наибольшее количество дефектов. Это чем-то похоже на правило Парето 80/20, где 80% дефектов находятся в 20% функций.



3 - эффективность раннего тестирования -
Активности по тестированию должны начинаться как можно раньше в жизненном цикле нашего продукта. Ведь чем позже мы нашли проблему, тем дороже её будет исправить. Мы должны делать сильный упор на статическое тестирование и верификацию, чтобы найти проблемы на ранних этапах и исправить их как можно раньше. Такой подход называется “Shift-Left”.



4 - парадокс пестицида -
Если одни и те же тесты проходить снова и снова, то рано или поздно они перестанут находить дефекты. То есть, наш продукт со временем адаптируется к нашим тестам.

Для того, чтобы избежать таких ситуаций рекомендуется следующее:
- Использовать разные данные при тестировании
- Постоянно пересматривать и улучшать свои тесты
- Добавлять новые тесты
- Использовать разные техники тестирования
- Проводить ротацию кадров

Неформальные техники тестирования основанные на опыте (например, исследовательское (Exploratory testing) и свободное тестирование (Ad-hoc)) очень хорошо помогают бороться с парадоксом пестицида.



5 - заблуждение об отсутствии ошибок -
Сколько бы мы не находили ошибок, это не даст нам гарантию того, что мы нашли их все или что продукт будет качественным. Продуктов без багов (Bug free) не существует!

Поэтому задача тестирования состоит не в нахождении всех дефектов, а нахождении наиболее важных дефектов до того, как их найдут пользователи. Да, при этом ещё и не забывая про верификацию и валидацию - 
https://crashtest.by/verification-vs-validation/

Даже если наш продукт соответствует всем требованиям, он может быть неприменим конечными пользователями из-за того, что у нас есть проблемы в требованиях или дизайне. Именно поэтому мы много времени уделяем раннему тестированию, верификации и статическому тестированию - https://crashtest.by/verification-vs-validation/


К тому же, уверены ли вы, что в вашем продукте нет нефункциональных багов? Например, удобства использования, производительности, совместимости, безопасности и так далее.



6 - тестирование показывает наличие дефектов - 
Тестирование может показать, что в нашем продукте есть дефекты, но не может доказать, что ошибок нет. Ведь они есть всегда

Этот принцип как раз и говорит, что тестирование напрямую не улучшает качество, а лишь показывает, что в продукте есть дефекты. Это помогает сделать качество лучше тем, что мы знаем о проблемах и можем их исправить. А вот уже улучшением качества может заниматься Quality Assurance -
https://crashtest.by/quality-assurance-vs-quality-control-vs-testing/



7 - тестирование зависит от контекста -
Не существует единственного верного способа тестировать программное обеспечение. Вряд ли систему контроля жизнеобеспечения мы будем тестировать как интернет-магазин. Даже 2 очень похожих интернет-магазина могут тестироваться совсем по-разному. Ведь контекст может быть разный.


Что может входить в контекст тестирования:

- Тип продукта — веб, десктоп, мобайл, сервис и тд

- Цель продукта — продажа товаров, игра, обеспечение безопасности

- Проектная команда — количество человек, специализация, опыт и тд

- Сроки — как много времени у нас есть до релиза

- Ожидаемый уровень качества — чем выше показатель, тем тщательнее нужно тестировать

- Риски — существует огромное число рисков, которые нужно учитывать. Например, из-за того, что команда неопытная в разработке продукта с заявленными целями и типом, есть риск, что в продукте может быть много багов. Тем самым, достижение ожидаемого уровня качества может затянуться.

- Доступные инструменты — есть ли у нас возможность пользоваться какими-то инструментами для тестирования или необходимо изобретать самим.

- И другие моменты


Исходя из данных нашего контекста, мы и будем строить эффективный процесс тестирования.



******************************************

неделя 3 - день 3 (03.09.2025) - 

виды тестовой документации -
https://testengineer.ru/chto-takoe-testovaya-dokumentaciya-i-zachem-ona-nuzhna/ 

Тестовая документация — это набор документов, создаваемых перед началом процесса тестирования и непосредственно в процессе. Эти документы описывают покрытие тестами и процесс выполнения тестов, в них указываются необходимые для тестирования вещи, приводится основная терминология и т. д. 

В тестовой документации любой член команды может найти полную информацию обо всех действиях, связанных с тестированием (и об уже выполненных, и о запланированных).

Тестовая документация определяет, что для нас важно и почему, какие действия мы должны выполнить и сколько времени у нас есть. Наконец, в документации обозначено, чего должна достичь команда и что сигнализирует об окончании процесса.



Какую тестовую документацию используют QA-команды? -
Наиболее часто используемые документы — это планы тестирования, чеклисты, тест-кейсы, сценарии использования, баг-репорты и спецификации требований:

1 - План тестирования (test plan) -
План тестирования описывает все действия по тестированию в рамках одного проекта. Здесь вы можете найти информацию обо всем, что нужно сделать тестировщику или команде QA в ходе проекта. В каждом плане тестирования указывается объект тестирования, график работы, критерии начала и окончания тестирования, стратегия, риски и список выполненных работ.

2 - Чеклист (checklist) -
Чеклист — это документ, содержащий краткое описание функций, которые должен проверить тестировщик. Выглядит чеклист как список функций с указанием статуса — результата проверки. Чеклисты могут использоваться вместо тест-кейсов, поскольку их легче подготовить. Но если вам нужно более конкретное описание процедуры, без тест-кейсов не обойтись.

3 - Тест-кейс (test case) -
В тест-кейсе содержатся:
- подробное описание шагов и действий, которые тестировщик должен выполнить для тестирования какой-то одной части функционала,
- критерии  прохождения тестов. 
Компании могут использовать разные форматы тест-кейсов, но информация в них всегда очень подробная и конкретная.

4 - Сценарий использования (use case) -
Use case — это более простой и менее официальный документ. Он описывает сценарий взаимодействия с программным обеспечением. Каждый юзкейс основан на предположении о том, что пользователь программы будет делать и где он будет кликать. Это позволяет тестировщикам протестировать предполагаемые пути пользователя. При создании юзкейсов тестировщики учитывают требования и бизнес-цели.

5 - Баг-репорт -
Баг-репорт предоставляет полную информацию о баге (его описание, серьезность, приоритет и т. д.) и документирует шаги и условия для воспроизведения этого бага. Подробный и эффективный баг-репорт значительно увеличивает шансы быстро исправить баг.

6 - Требования (requirements specification) -
Спецификация требований или просто требования — это полное описание разрабатываемого программного обеспечения. В требованиях указываются свойства, качества и особенности разрабатываемой программы. Используя эту информацию, команды могут избежать недоразумений и разногласий.



Как все это работает? -
Документы бывают высоко- и низкоуровневые. Все тестировщики могут составлять чеклисты, тест-кейсы и баг-репорты. Это часть их повседневных обязанностей. А вот подготовка плана тестирования требует дополнительных навыков и опыта. Это задача для опытного специалиста или QA Lead. Чем крупнее проект, тем больше документации нужно. Если команда использует для сложного продукта только чеклисты, есть риск неправильного понимания приоритетов и проведения неэффективных тестов. Причина кроется в отсутствии деталей. Чеклист только называет функцию, и каждый тестировщик может интерпретировать объект тестирования и результаты по-своему. Тестовая документация динамична. Она эффективна только в том случае, если команда QA регулярно ее обновляет. 
Если документацию заводят только «чтобы было», никакого смысла в ней нет. В ходе тестирования могут меняться требования и приоритеты. Это влияет на покрытие тестами, необходимые ресурсы и т. д. Если команда не записывает изменения, в результате получаются неэффективные документы и непоследовательность в работе. Аналогично, со временем устаревают и теряют свою актуальность тест-кейсы и сценарии использования. Может появиться новый функционал, который тоже нужно покрыть тестами. И если вы не будете все тщательно записывать, вы рискуете получить бесполезную документацию.



Каждая компания сама определяет, стоит ли создавать тестовую документацию. QA-специалисты могут рекомендовать клиентам это сделать, но последнее слово остается за клиентами. Что касается преимуществ документирования рабочего процесса, то они вполне очевидны. Описанные нами документы помогают упорядочить имеющуюся информацию. Благодаря этому даже новичок в команде сможет легко разобраться, что к чему.



******************************************

неделя 3 - день 4 (04.09.2025) - 

пирамида тестирования -
https://habr.com/ru/articles/672484/

Пирамида тестирования, также часто говорят уровни тестирования, это группировка тестов по уровню детализации и их назначению. Эту абстракцию придумал Майк Кон и описал в книге «Scrum: гибкая разработка ПО» (Succeeding With Agile. Software Development Using Scrum).

Пирамиду разбивают на 4 уровня (снизу вверх), например, по ISTQB:
- модульное тестирование (юнит);
- интеграционное тестирование;
- системное тестирования;
- приемочное тестирование.

Но можно встретить варианты, где 3 уровня. В этой модели объединяют интеграционный и системный уровни:
- модульное тестирование (юнит);
- интеграционное тестирование (включает в себя системное);
- приемочное тестирование.

Важно отметить:
1 - Тест (ручной, на высоких уровнях, или автотест, на низких уровнях), должен быть на том же уровне, что и тестируемый объект. Например, модульный тест (проверяющий функции, классы, объекты и т.п.) должен быть на компонентном уровне. Это неправильно, если на приемочном уровне запускается тест, который проверят минимальную единицу кода.
2 - Тесты уровнем выше не проверяют логику тестов уровнем/уровнями ниже.
3 - Чем выше тесты уровнем, тем они:
- сложней в реализации, и соответственно, дороже в реализации;
- важнее для бизнеса и критичней для пользователей;
- замедляют скорость прохождения тестовых наборов, например, регресса.



Компонентный уровень - Чаще всего называют юнит тестированием. Реже называют модульным тестированием. На этом уровне тестируют атомарные части кода. Это могут быть классы, функции или методы классов.

Юнит тесты находят ошибки на фундаментальных уровнях, их легче разрабатывать и поддерживать. Важное преимущество модульных тестов в том, что они быстрые и при изменении кода позволяют быстро провести регресс (убедиться, что новый код не сломал старые части кода).

Тест на компонентном уровне:
- Всегда автоматизируют.
- Модульных тестов всегда больше, чем тестов с других уровней.
- Юнит тесты выполняются быстрее всех и требуют меньше ресурсов.
- Практически всегда компонентные тесты не зависят от других модулей (на то они и юнит тесты) и UI системы.

В 99% разработкой модульных тестов занимается разработчик, при нахождении ошибки на этом уровне не создается баг-репортов. Разработчик находит баг, правит, запускает и проверяет (абстрактно говоря это разработка через тестирование) и так по новой, пока тест не будет пройден успешно.

На модульном уровне разработчик (или автотестер) использует метод белого ящика. Он знает что принимает и отдает минимальная единица кода, и как она работает.



Интеграционный уровень - Проверят взаимосвязь компоненты, которую проверяли на модульном уровне, с другой или другими компонентами, а также интеграцию компоненты с системой (проверка работы с ОС, сервисами и службами, базами данных, железом и т.д.). Часто в английских статьях называют service test или API test.

В случае с интеграционными тестами редко когда требуется наличие UI, чтобы его проверить. Компоненты ПО или системы взаимодействуют с тестируемым модулем с помощью интерфейсов. Тут начинается участие тестирования. Это проверки API, работы сервисов (проверка логов на сервере, записи в БД) и т.п.

В интеграционном тестировании, выполняются как функциональные (проверка по ТЗ), так и нефункциональные проверки (нагрузка на связку компонент). На этом уровне используется либо серый, либо черный ящик.

В интеграционном тестировании есть 3 основных способа тестирования (представь, что каждый модуль может состоять еще из более мелких частей):

- Снизу вверх (Bottom Up Integration): все мелкие части модуля собираются в один модуль и тестируются. Далее собираются следующие мелкие модули в один большой и тестируется с предыдущим и т.д. Например, функция публикации фото в соц. профиле состоит из 2 модулей: загрузчик и публикатор. Загрузчик, в свою очередь, состоит из модуля компрессии и отправки на сервер. Публикатор состоит из верификатора (проверяет подлинность) и управления доступом к фотографии. В интеграционном тестировании соберем модули загрузчика и проверим, потом соберем модули публикатора, проверим и протестируем взаимодействие загрузчика и публикатор.

- Сверху вниз (Top Down Integration): сначала проверяем работу крупных модулей, спускаясь ниже добавляем модули уровнем ниже. На этапе проверки уровней выше данные, необходимые от уровней ниже, симулируются.Например, проверяем работу загрузчика и публикатора. Руками (создаем функцию-заглушку) передаем от загрузчика публикатору фото, которое якобы было обработано компрессором.

- Большой взрыв ("Big Bang" Integration): собираем все реализованные модули всех уровней, интегрируем в систему и тестируем. Если что-то не работает или недоработали, то фиксим или дорабатываем.



Системный уровень - О системном уровне говорили в интеграционном. Тут отметить только то, что:
- Системный уровень проверят взаимодействие тестируемого ПО с системой по функциональным и нефункциональным требованиям.
- Важно тестировать на максимально приближенном окружении, которое будет у конечного пользователя.

Тест-кейсы на этом уровне подготавливаются:
- По требованиям.
- По возможным способам использования ПО.

На системном уровне выявляются такие дефекты, как неверное использование ресурсов системы, непредусмотренные комбинации данных пользовательского уровня, несовместимость с окружением, непредусмотренные сценарии использования, отсутствующая или неверная функциональность, неудобство использования и т.д.

На этом уровне используют черный ящик. Интеграционный уровень позволяет верифицировать требования (проверить соответствие ПО прописанным требованиям).



Приемочное тестирование - Также часто называют E2E тестами (End-2-End) или сквозными. На этом уровне происходит валидация требований (проверка работы ПО в целом, не только по прописанным требованиям, что проверили на системном уровне).

Проверка требований производится на наборе приемочных тестов. Они разрабатываются на основе требований и возможных способах использования ПО.

Отмечу, что приемочные тесты проводят, когда -
1 - продукт достиг необходимо уровня качества и 
2 - заказчик ПО ознакомлен с планом приемки (в нем описан набор сценариев и тестов, дата проведения и т.п.).

Приемку проводит либо внутреннее тестирование (необязательно тестировщики) или внешнее тестирование (сам заказчик и необязательно тестировщик).

Важно помнить, что E2E тесты автоматизируются сложнее, дольше, стоят дороже, сложнее поддерживаются и трудно выполняются при регрессе. Значит таких тестов должно быть меньше.



******************************************

неделя 3 - день 5 (05.09.2025) - 

тест-дизайн -
https://www.youtube.com/playlist?list=PLQk3Rj0ZoUb56N8o1qDlYUaW65hYiqclw

=




















