https://github.com/halltape/HalltapeRoadmapDE

************************************
************************************
************************************

1 - SQL с нуля до оконок - 
https://karpov.courses/simulator-sql

karpov.courses
>>>
Логин -
smnhkthre@emltmp.com
Пароль -
a........kar!
>>>

Redash - 
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

Все необходимые для прохождения курса инструменты мы развернули на нашем сервере. Они находятся во вкладке Инструменты в левом верхнем углу.

Основной инструмент для работы на курсе — Redash. Подробнее о том, как с ним работать, вы узнаете в уроке Базовые запросы SQL.  

Подключение к Redash
Переходите во вкладку Инструменты и выбирайте Redash. 
Выбираем LDAP/SSO login

Заполняем поля:  
Логин: ваш email
Пароль: пароль от личного кабинета в LMS



Схема базы данных
В этом шаге хранится документация, которая поможет вам разобраться в данных. На схеме ниже показаны связи между таблицами, а ещё ниже представлено подробное описание данных.
Рекомендуем сохранить ссылку на этот шаг. Он ещё не раз вам пригодится — особенно, когда мы начнём объединять таблицы друг с другом -
https://lab.karpov.courses/learning/152/module/1762/lesson/17923/51794/244290/

Типы данных
В таблицах могут храниться разные типы данных: целые и дробные числа, текст, даты, массивы из чисел. В наших данных вы встретитесь со следующими типами:

Тип данных	
Описание	
Пример

INT	
Целое число	
id пользователя: 132

NUMERIC / DECIMAL	
Вещественное число	
Стоимость товара: 120.55

VARCHAR	
Текст	
Действие с заказом: «create_order»

DATE	
Дата с точностью до дня	
Дата рождения пользователя: 25/03/91

TIMESTAMP	
Дата с точностью до секунды	
Время регистрации в приложении: 24/08/22 01:52:24

[]	
Массив	
Список id товаров в заказе: [1, 13, 22]



Работа в Redash
В этом уроке мы начнем работать с инструментом Redash для написания SQL запросов. 

Чтобы попасть в Redash, зайдите в раздел Инструменты, или сохранить у себя ссылку -
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

В предыдущем уроке мы подготовили инструкцию, как залогиниться в Redash - 
https://lab.karpov.courses/learning/152/module/1762/lesson/17931/51793/251405/

После успешного логина, чтобы начать писать запросы, нажмите на -
Create - New Query

Затем в списке доступных баз данных выберите -
Simulator SQL

запустить запрос - CTR + ENTER 

--
SELECT * 
FROM couriers 
LIMIT 20;
----

--
SELECT action, order_id, time 
FROM courier_actions 
LIMIT 20;
----

всегда ставить LIMIT (чтобы не зависла большая база)

чем более явный запрос - тем лучше (имена колонок, а не *)

ORDER BY name_colons DESK - сортировка -
--
SELECT action, order_id, time 
FROM courier_actions 
ORDER BY order_id DESC
LIMIT 20;

по возрастанию - 
ASC (или ничего не писать) - 
вверху маленькие внизу большие

по убыванию -
DESC - вверху большие внизу маленькие 

--
ASC   DESC
 A     V 
----
- ASC короче (3 буквы) и потом расширяется
- DESC длиннее (4 буквы) и потом сужается 

запросы к БД можно писать и напрямую из командной строки терминала -
--
simulator-sql-karpov-editor=> select * from users limit 1;
----

ключевые слова - писать заглавными буквами 

redash - это целая инфраструктура, позволяет делать дашборды, настраивать алерты и т.п. 

под окном для ввода кода запросов кнопки - 

- третья слева (с молнией) - включает подсказки для запросов 

- вторая слева - автоформатирование - расставляет отступы 

- внизу кнопка с тремя точками - выгрузить результаты 

- кнопка Save справа под окном для запросов - созранить запрос - ввести название и будет сформирована интернет-ссылка на запрос - потом созраненные запросы можно объединять в дашборды 

Redash в выводе не выводит полностью секунды, хотя в БД записи храняться с секундами 

Redash в выводе округляет числа до двух знаков после запятой, но в фактическом результате нет - использовать -
--
SELECT round(10.0 / 7, 2) as res;
----
- ручное округление

--
SELECT (10.0 / 7, 2)::text;
----
- выводит как текст

--так делают комментарий в коде SQL 

ответ на задание Карпова - 
--
SELECT *
FROM courier_actions 
ORDER BY courier_id DESC
LIMIT 100;
----

нужно и важно уметь самому переводить требования на язык SQL 

Общепринятый стиль написания SQL-запросов -
https://www.sqlstyle.guide/ru/

Отформатировать свой код можно с помощью этого сервиса - 
https://codebeautify.org/sqlformatter

Правильный порядок операторов в запросе выглядит так -
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

для начала напишем самый простой запрос и посмотрим, как выглядит таблица products.

Чтобы вывести все записи со значениями во всех колонках, необходимо либо перечислить все колонки в операторе SELECT, либо указать после оператора специальный символ «*»:
--
SELECT column_1, column_2, ...
FROM table


SELECT *
FROM table
----
Оператор FROM всегда указывается после оператора SELECT. В обратном порядке их записывать нельзя — база данных вернёт ошибку.

Для сортировки значений по какой-либо колонке в SQL используется оператор ORDER BY с ключевыми словами ASC (по возрастанию) или DESC (по убыванию).

При этом по умолчанию сортировка происходит по возрастанию, т.е. ASC указывать не обязательно. Для сортировки по убыванию после ORDER BY необходимо явно указать DESC:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1        -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 ASC    -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC   -- сортировка по убыванию
----
Оператор ORDER BY всегда указывается после операторов SELECT и FROM

Сортировать результат SQL-запроса можно сразу по нескольким колонкам, указывая их после ORDER BY через запятую вместе с направлением сортировки (ASC или DESC):
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2    
-- сначала сортировка по первой колонке (по убыванию), 
-- затем по второй (по возрастанию)
----

Для ограничения числа извлекаемых из таблицы записей применяется оператор LIMIT -
--
SELECT column
FROM table
LIMIT n 
----
На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо. Например, 100:
--
SELECT column
FROM table
LIMIT 100
----
Если n превысит количество записей в таблице, то в результат попадут все записи.

Важно помнить, что при работе с большими таблицами нужно по возможности ограничивать число извлекаемых записей, чтобы не создавать лишнюю нагрузку на базу данных.

Разумеется, операторы ORDER BY и LIMIT можно совмещать в одном запросе, при этом оператор LIMIT записывается и выполняется после оператора ORDER BY, ограничивая число записей в уже отсортированном результате:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2
LIMIT 100
----

Важно запомнить порядок записи всех известных нам ключевых слов:
SELECT
FROM
ORDER BY
LIMIT

Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:
1 - Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
2 - Затем SELECT — отбираются указанные столбцы.
3 - Потом ORDER BY — производится сортировка результирующей таблицы.
4 - И в самом конце LIMIT — ограничивается количество выводимых записей.

При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена (их ещё называют «алиасами»). Это можно делать с помощью оператора AS:
--
SELECT name AS new_name
FROM table
----

Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени и сил, то его можно опустить, указав новое имя колонки без него. Следующая запись тоже сработает:
--
SELECT name new_name
FROM table
----

В SQL-запросах к колонкам таблиц можно применять разные функции — так же, как, например, в Excel. В общем виде синтаксис функций выглядит примерно так -
--
SELECT function(a, b, c, ...)
FROM table
----
Вместо function указывается название функции, а в скобках — её аргументы. В качестве аргументов могут выступать как колонки со значениями, так и отдельные значения. В зависимости от функции количество необходимых для её работы аргументов может отличаться.

Если вы когда-нибудь работали в Excel, то вам наверняка знакомы разные функции вроде SUM, MIN, MAX и т.д., которые производят некоторые вычисления по столбцам. В SQL они называются агрегирующими функциями, и подробно о них мы будет говорить в последующих уроках.

Сейчас же в качестве примера рассмотрим функцию LENGTH. Она выполняет довольно простую задачу — подсчитывает количество символов в поданном ей на вход значении текстового типа (текстовый тип данных ещё часто называют строкой — от англ. «string»). Иными словами, функция LENGTH измеряет длину некоторой строки в символах -
--
SELECT LENGTH('karpov.courses')

Результат:
14
----

Функция LENGTH также может применяться ко всему столбцу. В таком случае длина в символах будет посчитана для каждого значения в столбце. Соответствующий запрос будет выглядеть так -
--
SELECT LENGTH(column) AS column_length
FROM table
----

В SQL, как и во многих других языках, функции можно применять к результату других функций, т.е. последовательно -
--
SELECT function_one(function_two(a, b), c)
----

В приведённой выше конструкции a, b, c — аргументы функций. При этом одним из аргументов функции function_one является результат выполнения функции function_two.
Таким образом, сначала будет выполнена функция function_two, а затем её результат будет подан на вход функции function_one в качестве одного из аргументов.
Рассмотрим такой случай на примере функций UPPER и LEFT. Функция UPPER приводит поданное ей на вход текстовое значение к верхнему регистру, а функция LEFT — возвращает первые n символов в строке -
--
SELECT UPPER('karpov.courses')

Результат:
KARPOV.COURSES


SELECT LEFT('karpov.courses', 6)

Результат:
karpov
----

Мы можем применить эти функции последовательно, и в результате получим первые шесть символов верхнего регистра -
--
SELECT UPPER(LEFT('karpov.courses', 6)) AS new_name

Результат:
KARPOV
----

Важно: обратите внимание, что в блоке SELECT нельзя выполнить эти две операции раздельно, т.е. мы не можем сначала создать расчётную колонку с первыми шестью символами, а потом сразу же обратиться к этой новой колонке, применив к ней функцию UPPER. Следующий запрос выполнен не будет, база данных вернёт ошибку -
--
SELECT LEFT('karpov.courses', 6) AS new_name, UPPER(new_name) AS another_new_name

Результат:
Error running query: column "new_name" does not exist
----

В рамках одного запроса колонки создаются не по очереди, а вместе, поэтому в рамках одного запроса колонки new_name не существует, пока блок SELECT не будет выполнен полностью. Крайне важно учитывать эту особенность языка.

Однако на практике к новым колонкам приходится обращаться довольно часто — именно для этого существуют подзапросы (запросы к другим запросам), которые мы будем рассматривать в соответствующем уроке. А пока нам достаточно понимать, что применять функции к расчётным колонкам в том же запросе нельзя.

В следующей задаче мы будем использовать ещё одну функцию для работы с данными строкового типа — SPLIT_PART. Функция SPLIT_PART разбивает поданную ей на вход строку на несколько частей в соответствии с указанным разделителем и возвращает одну из частей.

Помимо самой строки (или колонки со значениями строкового типа) функция принимает ещё два аргумента — разделитель и порядковый номер части, которую необходимо вернуть -
--
SELECT SPLIT_PART('karpov.courses', '.', 2)

Результат:
courses
----
В примере выше строка 'karpov.courses' была разбита на две части ('karpov' и 'courses') по разделителю, выраженному символом «точка». Функция вернула 'courses', поскольку третьим аргументом мы указали часть с порядковым номером 2.

Подробнее с другими функциями для работы со строками можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/

Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, не меняя при этом свойства исходной таблицы — например, преобразовать число в текст (тип данных VARCHAR). Для этого существует функция CAST.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения -
--
SELECT CAST(column AS VARCHAR)
FROM table
----

Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::») -
--
SELECT column::VARCHAR
FROM table
----

Можете самостоятельно запустить в Redash следующий запрос -
--
SELECT CAST('100' AS INTEGER)

Результат:
100
----

В примере выше вместо колонки мы использовали всего одно значение и перевели текст '100' в число 100.

Обратите внимание, что для успешной конвертации значения должны быть конвертируемыми в указываемый тип. Например, текст, который не выглядит как число, перевести в числовой тип данных не получится -
--
SELECT CAST('text' AS INTEGER)

Результат:
Error running query: invalid input syntax for type integer: "text"
----

Аналогичным образом можно, например, преобразовать текст в дату (если он выглядит как дата) -
--
SELECT '2022-12-31'::DATE

Результат:
31/12/22
----

В Redash тип данных в колонке указан справа от её названия.

Подробнее с функцией CAST и преобразованием типов данных можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cast/

Про сами типы данных можно почитать тут -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-data-types/

Ещё немного поработаем с текстовыми данными и рассмотрим функцию CONCAT, с помощью которой можно соединять в одну строку значения из нескольких столбцов. 

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами -
--
SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022
----
- При этом аргументы не обязательно должны быть выражены текстовыми значениями — главное, они должны быть конвертируемыми в текст. В примере выше число 2022 можно конвертировать в текст '2022', поэтому запрос работает без ошибок.

Ознакомиться с другими примерами использования функции CONCAT можно здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-concat-function/

При указании текстовых значений используйте одинарные кавычки.

Чтобы извлечь дату из значений в колонке, достаточно применить к ней функцию DATE или изменить её тип на DATE

в наших таблицах значения в некоторых колонках представлены в формате даты (DATE) и времени (TIMESTAMP). Давайте немного поработаем и с такими данными.

На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий -
--
SELECT DATE_PART(part, column)
----
- На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время. Можете самостоятельно запустить в Redash следующие запросы -
--
SELECT DATE_PART('year', DATE '2022-01-12')

Результат:
2022.00


SELECT DATE_PART('month', DATE '2022-01-12')

Результат:
1.00


SELECT DATE_PART('day', DATE '2022-01-12')

Результат:
12.00


SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05')

Результат:
20.00


SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')

Результат:
31.00
----
- Выше в качестве примера мы указали конкретную дату. На её месте могла быть, например, колонка с датами dates. Тогда запрос выглядел бы так -
--
SELECT DATE_PART('day', dates)
----

Ознакомиться с другими примерами использования функции DATE_PART можно здесь -
https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-date_part/

В прошлом задании для отдельных строк функция DATE_PART не вернула год рождения курьера — вместо них образовались пустые значения. Если не заметили, посмотрите внимательно на результат запроса из прошлого задания.

На самом деле это произошло потому, что в наших данных в колонке birth_date есть пропуски — так называемые NULL значения. Иными словами, для отдельных курьеров просто не указаны их дни рождения. Есть масса вариантов, почему так могло произойти, но у нас сейчас нет времени всё это выяснять — нам просто нужно научиться как-то обрабатывать такие случаи.

Давайте сделаем так, чтобы вместо пустых значений функция DATE_PART возвращала какое-нибудь другое значение. В этом нам поможет функция COALESCE, которая возвращает первое не NULL значение из списка поданных ей на вход аргументов.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры -
--
SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')

Результат:
I am not NULL


SELECT COALESCE(NULL, 25, 100, 150)

Результат:
25


SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')

Результат:
NULL
----

Одним из аргументов функции COALESCE может выступать результат выполнения другой функции -
--
SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null
----

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL -
--
SELECT COALESCE(column, 'filler value')
FROM table
----

Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.

При этом к колонке с пропусками можно также заранее применять разные другие функции -
--
SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table
----

С другими примерами использования функции COALESCE можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-coalesce/

Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы. Ниже в таблице указаны наиболее популярные -
--
+	Сложение	            2 + 3	5
-	Вычитание	            2 - 3	-1
*	Умножение	            2 * 3	6
/	Деление	                4 / 2	2
%	Остаток от деления	    5 % 4	1
^	Возведение в степень	2 ^ 3	8
----

Если бы мы захотели перевести 7500 рублей в доллары по курсу 1 доллар = 75 рублей, то операция выглядела бы следующим образом -
--
SELECT 7500 / 75

Результат:
100
----

Если бы нам потребовалось вычесть из каждого значения в одной из колонок нашей таблицы какое-то число (допустим, 100), то запрос выглядел бы так -
--
SELECT column - 100
FROM table
----

Кроме того, в арифметических операциях могут принимать участие сразу несколько колонок. Например, для каждой строчки таблицы можно вычислить среднее арифметическое двух чисел, которые содержатся в двух разных колонках -
--
SELECT (column_1 + column_2) / 2 AS average
FROM table
----

Ознакомиться со всеми арифметическими операторами можно здесь -
https://www.postgresql.org/docs/9.3/functions-math.html

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND -
--
SELECT ROUND(100.5454, 2)

Результат:
100.55


SELECT ROUND(100.551, 1)

Результат:
100.6


SELECT ROUND(100.5511)

Результат:
101.0
----
- Первым аргументом указывается само значение, которое хотим округлить. Вторым — число знаков после точки, до которого хотим округлить. Второй аргумент указывать не обязательно: если его не указать, произойдёт округление до целого числа (однако тип данных при этом не поменяется).

Также обратите внимание, что Redash накладывает дополнительное форматирование на выводимый результат, поэтому, например, результат второго запроса с настройками по умолчанию будет выглядеть так: 100.60

Настроить формат отображения и задать вручную число знаков после запятой можно с помощью кнопки Edit Visualization, расположенной в интерфейсе Redash сразу под результатом запроса.

Ознакомиться с другими математическими функциями можно здесь -
https://www.postgresqltutorial.com/postgresql-math-functions/

Если бы мы захотели повысить цену не на все товары, а, скажем, только на дорогие?

Для этого нам бы потребовалось создать некоторую функцию, которая проверяла бы каждое значение в колонке price и сравнивала бы его с каким-то пороговым значением. Если бы цена оказывалась выше этого порога, то функция повышала бы цену, а если нет — оставляла бы без изменений.

И такую функцию как раз можно задать с помощью условной конструкции CASE. Она имеет следующий синтаксис -
--
CASE  
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
...
ELSE expression_else
END AS case_example
----
- Эта конструкция может показаться громоздкой, но на самом деле в ней нет ничего сложного. Логика работы оператора CASE довольно простая:

1. На каждом этапе WHEN – THEN вычисляется некоторое логическое выражение logical_expression, стоящее после WHEN. Если оно оказывается истинным (TRUE), то в качестве результата оператор возвращает выражение expression, стоящее после THEN, и заканчивает свою работу.
2. Если выражение оказывается ложным (FALSE), то оператор продолжает работу и проверяет следующее условие.
3. Если ни одно из условий не проходит проверку на истинность, то возвращается выражение, указанное после ELSE. При этом ELSE указывать не обязательно — если его не указать, то вернётся пустое значение NULL (в случае, если все проверки после WHEN оказались ложными).
4. В конце обязательно указывается ключевое слово END, которое говорит об окончании конструкции CASE. Также после END новому расчётному полю с помощью AS можно присвоить некоторое имя, но это делать не обязательно. Обязательными являются только ключевые слова CASE,  WHEN,  THEN и END.

Пример:

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое» -
--
SELECT name,
       CASE 
       WHEN name='свинина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table
----

Теперь немного о логических выражениях: в SQL они могут включать операторы сравнения и логические операции.

К операторам сравнения относятся - 
= («равно»)
<> или != («не равно»)
< («меньше»)
> («больше»)
<= («меньше или равно»)
>= («больше или равно»)

Результатом работы операторов сравнения могут быть три состояния:
TRUE («истина»)
FALSE («ложь»)
NULL («неопределённое состояние» — когда одно из сравниваемых значений NULL)

С этими тремя состояниями можно проводить следующие логические операции:
AND («И»)
OR («ИЛИ»)
NOT («НЕ»)

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):
a	    b	    a AND b	   a OR b
TRUE	TRUE	TRUE	   TRUE
TRUE	FALSE	FALSE	   TRUE
TRUE	NULL	NULL	   TRUE
FALSE	FALSE	FALSE	   FALSE
FALSE	NULL	FALSE	   NULL
NULL	NULL	NULL	   NULL

a	    NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL

Таким образом, операторы сравнения и логические операции позволяют писать комплексные логические выражения.

Запоминать все эти таблицы и комбинации не обязательно. Вы разберётесь с ними по ходу курса — главное, всегда держите эту памятку под рукой. 

Существуют приоритеты выполнения операций:
1. умножение и деление (* и /)
2. сложение и вычитание (+ и -)
3. операторы сравнения (=, !=, >, <, >=, <=)
4. NOT
5. AND
6. OR

На порядок выполнения операторов также можно влиять с помощью скобок. Выражения, помещённые в скобки, будут иметь наивысший приоритет — всё как в математике.

===








