https://github.com/halltape/HalltapeRoadmapDE

************************************
************************************
************************************

1 - SQL с нуля до оконок - 
https://karpov.courses/simulator-sql

karpov.courses
>>>
Логин -
smnhkthre@emltmp.com
Пароль -
a........kar!
>>>

Redash - 
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

Все необходимые для прохождения курса инструменты мы развернули на нашем сервере. Они находятся во вкладке Инструменты в левом верхнем углу.

Основной инструмент для работы на курсе — Redash. Подробнее о том, как с ним работать, вы узнаете в уроке Базовые запросы SQL.  

Подключение к Redash
Переходите во вкладку Инструменты и выбирайте Redash. 
Выбираем LDAP/SSO login

Заполняем поля:  
Логин: ваш email
Пароль: пароль от личного кабинета в LMS



Схема базы данных
В этом шаге хранится документация, которая поможет вам разобраться в данных. На схеме ниже показаны связи между таблицами, а ещё ниже представлено подробное описание данных.
Рекомендуем сохранить ссылку на этот шаг. Он ещё не раз вам пригодится — особенно, когда мы начнём объединять таблицы друг с другом -
https://lab.karpov.courses/learning/152/module/1762/lesson/17923/51794/244290/

Типы данных
В таблицах могут храниться разные типы данных: целые и дробные числа, текст, даты, массивы из чисел. В наших данных вы встретитесь со следующими типами:

Тип данных	
Описание	
Пример

INT	
Целое число	
id пользователя: 132

NUMERIC / DECIMAL	
Вещественное число	
Стоимость товара: 120.55

VARCHAR	
Текст	
Действие с заказом: «create_order»

DATE	
Дата с точностью до дня	
Дата рождения пользователя: 25/03/91

TIMESTAMP	
Дата с точностью до секунды	
Время регистрации в приложении: 24/08/22 01:52:24

[]	
Массив	
Список id товаров в заказе: [1, 13, 22]



Работа в Redash
В этом уроке мы начнем работать с инструментом Redash для написания SQL запросов. 

Чтобы попасть в Redash, зайдите в раздел Инструменты, или сохранить у себя ссылку -
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

В предыдущем уроке мы подготовили инструкцию, как залогиниться в Redash - 
https://lab.karpov.courses/learning/152/module/1762/lesson/17931/51793/251405/

После успешного логина, чтобы начать писать запросы, нажмите на -
Create - New Query

Затем в списке доступных баз данных выберите -
Simulator SQL

запустить запрос - CTR + ENTER 

--
SELECT * 
FROM couriers 
LIMIT 20;
----

--
SELECT action, order_id, time 
FROM courier_actions 
LIMIT 20;
----

всегда ставить LIMIT (чтобы не зависла большая база)

чем более явный запрос - тем лучше (имена колонок, а не *)

ORDER BY name_colons DESK - сортировка -
--
SELECT action, order_id, time 
FROM courier_actions 
ORDER BY order_id DESC
LIMIT 20;

по возрастанию - 
ASC (или ничего не писать) - 
вверху маленькие внизу большие

по убыванию -
DESC - вверху большие внизу маленькие 

--
ASC   DESC
 A     V 
----
- ASC короче (3 буквы) и потом расширяется
- DESC длиннее (4 буквы) и потом сужается 

запросы к БД можно писать и напрямую из командной строки терминала -
--
simulator-sql-karpov-editor=> select * from users limit 1;
----

ключевые слова - писать заглавными буквами 

redash - это целая инфраструктура, позволяет делать дашборды, настраивать алерты и т.п. 

под окном для ввода кода запросов кнопки - 

- третья слева (с молнией) - включает подсказки для запросов 

- вторая слева - автоформатирование - расставляет отступы 

- внизу кнопка с тремя точками - выгрузить результаты 

- кнопка Save справа под окном для запросов - созранить запрос - ввести название и будет сформирована интернет-ссылка на запрос - потом созраненные запросы можно объединять в дашборды 

Redash в выводе не выводит полностью секунды, хотя в БД записи храняться с секундами 

Redash в выводе округляет числа до двух знаков после запятой, но в фактическом результате нет - использовать -
--
SELECT round(10.0 / 7, 2) as res;
----
- ручное округление

--
SELECT (10.0 / 7, 2)::text;
----
- выводит как текст

--так делают комментарий в коде SQL 

ответ на задание Карпова - 
--
SELECT *
FROM courier_actions 
ORDER BY courier_id DESC
LIMIT 100;
----

нужно и важно уметь самому переводить требования на язык SQL 

Общепринятый стиль написания SQL-запросов -
https://www.sqlstyle.guide/ru/

Отформатировать свой код можно с помощью этого сервиса - 
https://codebeautify.org/sqlformatter

Правильный порядок операторов в запросе выглядит так -
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

для начала напишем самый простой запрос и посмотрим, как выглядит таблица products.

Чтобы вывести все записи со значениями во всех колонках, необходимо либо перечислить все колонки в операторе SELECT, либо указать после оператора специальный символ «*»:
--
SELECT column_1, column_2, ...
FROM table


SELECT *
FROM table
----
Оператор FROM всегда указывается после оператора SELECT. В обратном порядке их записывать нельзя — база данных вернёт ошибку.

***

Задание:

Выведите все записи из таблицы products.
Поля в результирующей таблице: product_id, name, price
--
SELECT product_id,
       name,
       price
FROM   products;
----

Для сортировки значений по какой-либо колонке в SQL используется оператор ORDER BY с ключевыми словами ASC (по возрастанию) или DESC (по убыванию).

При этом по умолчанию сортировка происходит по возрастанию, т.е. ASC указывать не обязательно. Для сортировки по убыванию после ORDER BY необходимо явно указать DESC:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1        -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 ASC    -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC   -- сортировка по убыванию
----
Оператор ORDER BY всегда указывается после операторов SELECT и FROM

***

Задание:

Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию. Для сортировки используйте оператор ORDER BY.
Поля в результирующей таблице: product_id, name, price
Пояснение:
Сортировку можно делать не только по полям со значениями, выраженными числами, но и по полям, значения в которых представлены в виде текста, как в нашем случае.
--
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name asc;
----
+
--
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name
----

Сортировать результат SQL-запроса можно сразу по нескольким колонкам, указывая их после ORDER BY через запятую вместе с направлением сортировки (ASC или DESC):
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2    
-- сначала сортировка по первой колонке (по убыванию), 
-- затем по второй (по возрастанию)
----

Для ограничения числа извлекаемых из таблицы записей применяется оператор LIMIT -
--
SELECT column
FROM table
LIMIT n 
----
На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо. Например, 100:
--
SELECT column
FROM table
LIMIT 100
----
Если n превысит количество записей в таблице, то в результат попадут все записи.

Важно помнить, что при работе с большими таблицами нужно по возможности ограничивать число извлекаемых записей, чтобы не создавать лишнюю нагрузку на базу данных.

Разумеется, операторы ORDER BY и LIMIT можно совмещать в одном запросе, при этом оператор LIMIT записывается и выполняется после оператора ORDER BY, ограничивая число записей в уже отсортированном результате:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2
LIMIT 100
----

***

Задание:

Отсортируйте таблицу courier_actions сначала по колонке courier_id по возрастанию id курьера, потом по колонке action (снова по возрастанию), а затем по колонке time, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку order_id.
Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.
Поля в результирующей таблице: courier_id, order_id, action, time
Пояснение:
Как вы уже догадались, сортировать таблицы можно в том числе по полям с датами и временем
--
SELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time desc limit 1000;
----

Важно запомнить порядок записи всех известных нам ключевых слов:
SELECT
FROM
ORDER BY
LIMIT

Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:
1 - Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
2 - Затем SELECT — отбираются указанные столбцы.
3 - Потом ORDER BY — производится сортировка результирующей таблицы.
4 - И в самом конце LIMIT — ограничивается количество выводимых записей.

***

Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, определите 5 самых дорогих товаров в таблице products, которые доставляет наш сервис. Выведите их наименования и цену.
Поля в результирующей таблице: name, price
--
SELECT name,
       price
FROM   products
ORDER BY price desc limit 5;
----

При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена (их ещё называют «алиасами»). Это можно делать с помощью оператора AS:
--
SELECT name AS new_name
FROM table
----

Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени и сил, то его можно опустить, указав новое имя колонки без него. Следующая запись тоже сработает:
--
SELECT name new_name
FROM table
----

***

Задание:

Как в прошлом задании определите 5 самых дорогих товаров в таблице products. Но теперь колонки name и price переименуйте соответственно в product_name и product_price.
Поля в результирующей таблице: product_name, product_price
--
SELECT name as product_name,
       price as product_price
FROM   products
ORDER BY product_price desc limit 5;
----

В SQL-запросах к колонкам таблиц можно применять разные функции — так же, как, например, в Excel. В общем виде синтаксис функций выглядит примерно так -
--
SELECT function(a, b, c, ...)
FROM table
----
Вместо function указывается название функции, а в скобках — её аргументы. В качестве аргументов могут выступать как колонки со значениями, так и отдельные значения. В зависимости от функции количество необходимых для её работы аргументов может отличаться.

Если вы когда-нибудь работали в Excel, то вам наверняка знакомы разные функции вроде SUM, MIN, MAX и т.д., которые производят некоторые вычисления по столбцам. В SQL они называются агрегирующими функциями, и подробно о них мы будет говорить в последующих уроках.

Сейчас же в качестве примера рассмотрим функцию LENGTH. Она выполняет довольно простую задачу — подсчитывает количество символов в поданном ей на вход значении текстового типа (текстовый тип данных ещё часто называют строкой — от англ. «string»). Иными словами, функция LENGTH измеряет длину некоторой строки в символах -
--
SELECT LENGTH('karpov.courses')

Результат:
14
----

Функция LENGTH также может применяться ко всему столбцу. В таком случае длина в символах будет посчитана для каждого значения в столбце. Соответствующий запрос будет выглядеть так -
--
SELECT LENGTH(column) AS column_length
FROM table
----

***

Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, а также функцию LENGTH, определите товар с самым длинным названием в таблице products. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите name_length.
Поля в результирующей таблице: name, name_length, price
Пояснение:
Обратите внимание, что в этой задаче вам придётся сортировать результирующую таблицу по расчётной колонке name_length, которой изначально не было в таблице products.
Такая сортировка по новым колонкам возможна, поскольку это согласуется с порядком выполнения операторов в запросе: сначала выполняется выбор колонок и все преобразования над ними в операторе SELECT — и только потом производится сортировка по указанным в ORDER BY столбцам. То есть к моменту сортировки все расчётные поля уже существуют, а значит, их можно указывать в ORDER BY.
Также обратите внимание, что мы дважды указываем колонку name в операторе SELECT: в первый раз просто обращаемся к ней по имени, а во второй — используем её в качестве аргумента функции LENGTH. В этом случае тоже нет никаких противоречий — мы можем выбирать колонку столько раз, сколько необходимо, причём для этого даже необязательно присваивать этим колонкам разные алиасы (база данных сама переименует дубликат колонки).
--
SELECT name,
       length(name) as name_length,
       price
FROM   products
ORDER BY name_length desc limit 1;
----

В SQL, как и во многих других языках, функции можно применять к результату других функций, т.е. последовательно -
--
SELECT function_one(function_two(a, b), c)
----

В приведённой выше конструкции a, b, c — аргументы функций. При этом одним из аргументов функции function_one является результат выполнения функции function_two.
Таким образом, сначала будет выполнена функция function_two, а затем её результат будет подан на вход функции function_one в качестве одного из аргументов.
Рассмотрим такой случай на примере функций UPPER и LEFT. Функция UPPER приводит поданное ей на вход текстовое значение к верхнему регистру, а функция LEFT — возвращает первые n символов в строке -
--
SELECT UPPER('karpov.courses')

Результат:
KARPOV.COURSES


SELECT LEFT('karpov.courses', 6)

Результат:
karpov
----

Мы можем применить эти функции последовательно, и в результате получим первые шесть символов верхнего регистра -
--
SELECT UPPER(LEFT('karpov.courses', 6)) AS new_name

Результат:
KARPOV
----

Важно: обратите внимание, что в блоке SELECT нельзя выполнить эти две операции раздельно, т.е. мы не можем сначала создать расчётную колонку с первыми шестью символами, а потом сразу же обратиться к этой новой колонке, применив к ней функцию UPPER. Следующий запрос выполнен не будет, база данных вернёт ошибку -
--
SELECT LEFT('karpov.courses', 6) AS new_name, UPPER(new_name) AS another_new_name

Результат:
Error running query: column "new_name" does not exist
----

В рамках одного запроса колонки создаются не по очереди, а вместе, поэтому в рамках одного запроса колонки new_name не существует, пока блок SELECT не будет выполнен полностью. Крайне важно учитывать эту особенность языка.

Однако на практике к новым колонкам приходится обращаться довольно часто — именно для этого существуют подзапросы (запросы к другим запросам), которые мы будем рассматривать в соответствующем уроке. А пока нам достаточно понимать, что применять функции к расчётным колонкам в том же запросе нельзя.

В следующей задаче мы будем использовать ещё одну функцию для работы с данными строкового типа — SPLIT_PART. Функция SPLIT_PART разбивает поданную ей на вход строку на несколько частей в соответствии с указанным разделителем и возвращает одну из частей.

Помимо самой строки (или колонки со значениями строкового типа) функция принимает ещё два аргумента — разделитель и порядковый номер части, которую необходимо вернуть -
--
SELECT SPLIT_PART('karpov.courses', '.', 2)

Результат:
courses
----
В примере выше строка 'karpov.courses' была разбита на две части ('karpov' и 'courses') по разделителю, выраженному символом «точка». Функция вернула 'courses', поскольку третьим аргументом мы указали часть с порядковым номером 2.

Подробнее с другими функциями для работы со строками можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/

***

Задание:

Примените последовательно функции UPPER и SPLIT_PART к колонке name и преобразуйте наименования товаров в таблице products так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите first_word.
В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке name.
Поля в результирующей таблице: name, first_word, price
--
SELECT name,
       upper(split_part(name, ' ', 1)) as first_word,
       price
FROM   products
ORDER BY name asc;
----

Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, не меняя при этом свойства исходной таблицы — например, преобразовать число в текст (тип данных VARCHAR). Для этого существует функция CAST.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения -
--
SELECT CAST(column AS VARCHAR)
FROM table
----

Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::») -
--
SELECT column::VARCHAR
FROM table
----

Можете самостоятельно запустить в Redash следующий запрос -
--
SELECT CAST('100' AS INTEGER)

Результат:
100
----

В примере выше вместо колонки мы использовали всего одно значение и перевели текст '100' в число 100.

Обратите внимание, что для успешной конвертации значения должны быть конвертируемыми в указываемый тип. Например, текст, который не выглядит как число, перевести в числовой тип данных не получится -
--
SELECT CAST('text' AS INTEGER)

Результат:
Error running query: invalid input syntax for type integer: "text"
----

Аналогичным образом можно, например, преобразовать текст в дату (если он выглядит как дата) -
--
SELECT '2022-12-31'::DATE

Результат:
31/12/22
----

В Redash тип данных в колонке указан справа от её названия.

Подробнее с функцией CAST и преобразованием типов данных можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cast/

Про сами типы данных можно почитать тут -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-data-types/

***

Задание:

Измените тип колонки price из таблицы products на VARCHAR. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате VARCHAR. Новую колонку с ценой в новом формате назовите price_char.
Результат отсортируйте по возрастанию исходного наименования товара в колонке name. Количество выводимых записей не ограничивайте.
Поле в результирующей таблице: name, price, price_char
--
SELECT name,
       price,
       price::varchar as price_char
FROM   products
ORDER BY name asc;
----
+
--
SELECT name,
       price,
       cast(price as varchar) as price_char
FROM   products
ORDER BY name
----

Ещё немного поработаем с текстовыми данными и рассмотрим функцию CONCAT, с помощью которой можно соединять в одну строку значения из нескольких столбцов. 

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами -
--
SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022
----
- При этом аргументы не обязательно должны быть выражены текстовыми значениями — главное, они должны быть конвертируемыми в текст. В примере выше число 2022 можно конвертировать в текст '2022', поэтому запрос работает без ошибок.

Ознакомиться с другими примерами использования функции CONCAT можно здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-concat-function/

***

Задание:

Для первых 200 записей из таблицы orders выведите информацию в следующем виде (обратите внимание на пробелы):
Заказ № [id заказа] создан [дата]
Полученную колонку назовите order_info

При указании текстовых значений используйте одинарные кавычки.
Чтобы извлечь дату из значений в колонке, достаточно применить к ней функцию DATE или изменить её тип на DATE -
--
SELECT DATE(time)

SELECT CAST(time AS DATE)

SELECT time::DATE
----

ответ -
--
SELECT concat('Заказ № ',
              order_id,
              ' ',
              'создан ',
              creation_time::date) as order_info
FROM   orders limit 200;
----
+
--
SELECT concat('Заказ № ', order_id, ' создан ', date(creation_time)) as order_info
FROM   orders limit 200
----

в наших таблицах значения в некоторых колонках представлены в формате даты (DATE) и времени (TIMESTAMP). Давайте немного поработаем и с такими данными.
На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий -
--
SELECT DATE_PART(part, column)
----
- На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время. Можете самостоятельно запустить в Redash следующие запросы -
--
SELECT DATE_PART('year', DATE '2022-01-12')

Результат:
2022.00


SELECT DATE_PART('month', DATE '2022-01-12')

Результат:
1.00


SELECT DATE_PART('day', DATE '2022-01-12')

Результат:
12.00


SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05')

Результат:
20.00


SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')

Результат:
31.00
----
- Выше в качестве примера мы указали конкретную дату. На её месте могла быть, например, колонка с датами dates. Тогда запрос выглядел бы так -
--
SELECT DATE_PART('day', dates)
----

Ознакомиться с другими примерами использования функции DATE_PART можно здесь -
https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-date_part/

***

Задание:

Выведите id всех курьеров и их годы рождения из таблицы couriers.
Год рождения необходимо получить из колонки birth_date. Новую колонку с годом назовите birth_year. Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию id курьера.
Поля в результирующей таблице: courier_id, birth_year
--
SELECT courier_id,
       date_part('year', birth_date) as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id asc;
----

В прошлом задании для отдельных строк функция DATE_PART не вернула год рождения курьера — вместо них образовались пустые значения. Если не заметили, посмотрите внимательно на результат запроса из прошлого задания.

На самом деле это произошло потому, что в наших данных в колонке birth_date есть пропуски — так называемые NULL значения. Иными словами, для отдельных курьеров просто не указаны их дни рождения. Есть масса вариантов, почему так могло произойти, но у нас сейчас нет времени всё это выяснять — нам просто нужно научиться как-то обрабатывать такие случаи.

Давайте сделаем так, чтобы вместо пустых значений функция DATE_PART возвращала какое-нибудь другое значение. В этом нам поможет функция COALESCE, которая возвращает первое не NULL значение из списка поданных ей на вход аргументов.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры -
--
SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')

Результат:
I am not NULL


SELECT COALESCE(NULL, 25, 100, 150)

Результат:
25


SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')

Результат:
NULL
----

Одним из аргументов функции COALESCE может выступать результат выполнения другой функции -
--
SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null
----

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL -
--
SELECT COALESCE(column, 'filler value')
FROM table
----

Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.

При этом к колонке с пропусками можно также заранее применять разные другие функции -
--
SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table
----

С другими примерами использования функции COALESCE можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-coalesce/

***

Задание:

Как и в предыдущем задании, снова выведите id всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию COALESCE. Укажите параметры функции так, чтобы вместо NULL значений в результат попадало текстовое значение unknown. Названия полей оставьте прежними.
Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.
Поля в результирующей таблице: courier_id, birth_year
Пояснение:
При указании текстового значения используйте одинарные кавычки, как в примерах выше.
Не забудьте учесть, что unknown — значение типа VARCHAR, а значит, извлечённый из даты год нужно тоже привести к этому типу. Поэтому сначала извлеките год, затем преобразуйте его в текст и далее применяйте к полученному значению функцию COALESCE
--
SELECT courier_id,
       coalesce(cast(date_part('year', birth_date) as varchar), 'unknown') as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id asc;
----
+
--
SELECT courier_id,
       coalesce(date_part('year', birth_date)::varchar, 'unknown') as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id
----

Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы. Ниже в таблице указаны наиболее популярные -
--
+	Сложение	            2 + 3	5
-	Вычитание	            2 - 3	-1
*	Умножение	            2 * 3	6
/	Деление	                4 / 2	2
%	Остаток от деления	    5 % 4	1
^	Возведение в степень	2 ^ 3	8
----

Если бы мы захотели перевести 7500 рублей в доллары по курсу 1 доллар = 75 рублей, то операция выглядела бы следующим образом -
--
SELECT 7500 / 75

Результат:
100
----

Если бы нам потребовалось вычесть из каждого значения в одной из колонок нашей таблицы какое-то число (допустим, 100), то запрос выглядел бы так -
--
SELECT column - 100
FROM table
----

Кроме того, в арифметических операциях могут принимать участие сразу несколько колонок. Например, для каждой строчки таблицы можно вычислить среднее арифметическое двух чисел, которые содержатся в двух разных колонках -
--
SELECT (column_1 + column_2) / 2 AS average
FROM table
----

Ознакомиться со всеми арифметическими операторами можно здесь -
https://www.postgresql.org/docs/9.3/functions-math.html

***

Задание:

Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице products на 5%.
Выведите id и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите old_price, а колонку с новой — new_price.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
--
SELECT product_id,
       name,
       price as old_price,
       price*1.05 as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND -
--
SELECT ROUND(100.5454, 2)

Результат:
100.55


SELECT ROUND(100.551, 1)

Результат:
100.6


SELECT ROUND(100.5511)

Результат:
101.0
----
- Первым аргументом указывается само значение, которое хотим округлить. Вторым — число знаков после точки, до которого хотим округлить. Второй аргумент указывать не обязательно: если его не указать, произойдёт округление до целого числа (однако тип данных при этом не поменяется).

Также обратите внимание, что Redash накладывает дополнительное форматирование на выводимый результат, поэтому, например, результат второго запроса с настройками по умолчанию будет выглядеть так: 100.60

Настроить формат отображения и задать вручную число знаков после запятой можно с помощью кнопки Edit Visualization, расположенной в интерфейсе Redash сразу под результатом запроса.

Ознакомиться с другими математическими функциями можно здесь -
https://www.postgresqltutorial.com/postgresql-math-functions/

***

Задание:

Вновь, как и в прошлом задании, повысьте цену всех товаров на 5%, только теперь к колонке с новой ценой примените функцию ROUND. Выведите id и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
--
SELECT product_id,
       name,
       price as old_price,
       round((price * 1.05), 1) as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----

Если бы мы захотели повысить цену не на все товары, а, скажем, только на дорогие?

Для этого нам бы потребовалось создать некоторую функцию, которая проверяла бы каждое значение в колонке price и сравнивала бы его с каким-то пороговым значением. Если бы цена оказывалась выше этого порога, то функция повышала бы цену, а если нет — оставляла бы без изменений.

И такую функцию как раз можно задать с помощью условной конструкции CASE. Она имеет следующий синтаксис -
--
CASE  
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
...
ELSE expression_else
END AS case_example
----
- Эта конструкция может показаться громоздкой, но на самом деле в ней нет ничего сложного. Логика работы оператора CASE довольно простая:

1. На каждом этапе WHEN – THEN вычисляется некоторое логическое выражение logical_expression, стоящее после WHEN. Если оно оказывается истинным (TRUE), то в качестве результата оператор возвращает выражение expression, стоящее после THEN, и заканчивает свою работу.
2. Если выражение оказывается ложным (FALSE), то оператор продолжает работу и проверяет следующее условие.
3. Если ни одно из условий не проходит проверку на истинность, то возвращается выражение, указанное после ELSE. При этом ELSE указывать не обязательно — если его не указать, то вернётся пустое значение NULL (в случае, если все проверки после WHEN оказались ложными).
4. В конце обязательно указывается ключевое слово END, которое говорит об окончании конструкции CASE. Также после END новому расчётному полю с помощью AS можно присвоить некоторое имя, но это делать не обязательно. Обязательными являются только ключевые слова CASE,  WHEN,  THEN и END.

Пример:

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое» -
--
SELECT name,
       CASE 
       WHEN name='свинина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table
----

Теперь немного о логических выражениях: в SQL они могут включать операторы сравнения и логические операции.

К операторам сравнения относятся - 
= («равно»)
<> или != («не равно»)
< («меньше»)
> («больше»)
<= («меньше или равно»)
>= («больше или равно»)

Результатом работы операторов сравнения могут быть три состояния:
TRUE («истина»)
FALSE («ложь»)
NULL («неопределённое состояние» — когда одно из сравниваемых значений NULL)

С этими тремя состояниями можно проводить следующие логические операции:
AND («И»)
OR («ИЛИ»)
NOT («НЕ»)

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):
a	    b	    a AND b	   a OR b
TRUE	TRUE	TRUE	   TRUE
TRUE	FALSE	FALSE	   TRUE
TRUE	NULL	NULL	   TRUE
FALSE	FALSE	FALSE	   FALSE
FALSE	NULL	FALSE	   NULL
NULL	NULL	NULL	   NULL

a	    NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL

Таким образом, операторы сравнения и логические операции позволяют писать комплексные логические выражения.

Запоминать все эти таблицы и комбинации не обязательно. Вы разберётесь с ними по ходу курса — главное, всегда держите эту памятку под рукой. 

Существуют приоритеты выполнения операций:
1. умножение и деление (* и /)
2. сложение и вычитание (+ и -)
3. операторы сравнения (=, !=, >, <, >=, <=)
4. NOT
5. AND
6. OR

На порядок выполнения операторов также можно влиять с помощью скобок. Выражения, помещённые в скобки, будут иметь наивысший приоритет — всё как в математике.

***

Задание:

Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений. Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену. Цену округлять не нужно.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price
-
--
SELECT product_id,
       name,
       price AS old_price,
       CASE 
           WHEN price > 100 AND name <> 'икра' THEN price * 1.05 
           ELSE price
       END as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----
+
--
SELECT product_id,
       name,
       price as old_price,
       case when price <= 100 or
                 name = 'икра' then price
            when price > 100 then price*1.05
            else 0 
			end new_price
FROM   products
ORDER BY new_price desc, product_id
----

Представьте, что к вам обратился менеджер из соседнего отдела с просьбой посчитать НДС каждого товара. Никаких дополнительных данных он вам не предоставил, поэтому вы решили выполнить задачу на своё усмотрение, посчитав, что НДС единый для всех товаров и составляет 20%

***

Задание:

Вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и price_before_tax. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, tax, price_before_tax

Пояснение:

Так как НДС уже включён в текущую цену, налог считаем следующим образом: делим цену на 120% и умножаем на 20%.

Почему налог считается именно так, можно прочитать здесь -
https://nalog-nalog.ru/nds/stavka_nds/kak_pravilno_vyschitat_18_nds_iz_summy/
-
--
SELECT product_id, 
    name, 
	price, 
	ROUND((price / 120) * 20, 2) AS tax, 
	ROUND(price - ((price / 120) * 20), 2) AS price_before_tax
FROM products
ORDER BY price_before_tax DESC, product_id ASC;
----
+
--
SELECT product_id,
       name,
       price,
       round(price/120*20, 2) as tax,
       round(price - price/120*20, 2) as price_before_tax
FROM   products
ORDER BY price_before_tax desc, product_id
----

На этом уроке мы:

- Познакомились с операторами SELECT и FROM и научились составлять базовые запросы.

- Узнали, как сортировать записи с помощью оператора ORDER BY.

- Научились ограничивать количество выводимых записей с помощью оператора LIMIT.

- Выяснили, как преобразовывать типы данных с помощью CAST.

- Научились работать с датой и временем и познакомились с функцией DATE_PART.

- Узнали про NULL значения и поработали с COALESCE.

- Научились работать с текстовыми данными и соединять строки с помощью функции CONCAT.

- Поработали с арифметическими операторами и математическими функциями.

- Познакомились с конструкцией CASE и научились составлять комплексные логические выражения.

Известные нам на текущий момент ключевые слова и порядок их написания в запросе:
--
SELECT    -- перечисление полей результирующей таблицы
FROM      -- указание источника данных
ORDER BY  -- сортировка результирующей таблицы
LIMIT     -- ограничение количества выводимых записей
----

Лекция 4.1. Фильтрация данных -

WHERE - где 

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 167
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 AND order_id = 56176
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 AND action = 'deliver_order'
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 OR courier_id = 100
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE action = 'deliver_order' AND (courier_id = 3167 OR courier_id = 100)
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE action = 'deliver_order' AND courier_id IN (12, 100, 212) 
LIMIT 100;
----

Фильтрация данных позволяет включать в результирующий запрос не все строки исходной таблицы, а только те, которые соответствуют заранее заданному условию.

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:
--
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
----

Например, в результате указанного выше запроса в выборку попадут только записи с неотрицательными значениями в колонке column_2.

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:
--
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100
----

В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:
SELECT
FROM
WHERE
ORDER BY
LIMIT

Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:
1 - Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
2 - Далее WHERE — отфильтровываются строки, соответствующие условию.
3 - Затем SELECT — отбираются указанные столбцы и применяются функции.
4 - Потом ORDER BY — производится сортировка результирующей таблицы.
5 - И в самом конце LIMIT — ограничивается количество выводимых записей.

Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

Подробнее про оператор WHERE можно почитать здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-where/

***

Напишите SQL-запрос к таблице products и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию id товара.
Поля в результирующей таблице: product_id, name, price
--
SELECT product_id,
       name,
       price
FROM   products
WHERE  price <= 100
ORDER BY product_id;
----

Фильтровать данные в таблицах можно не только по полям с числовыми значениями, но и по полям со значениями, представленными в виде текста:
--
SELECT column_1, column_2
FROM table
WHERE column_2 = 'text'
----
- в результирующую таблицу попадут только строки, значения в которых полностью совпадают с указанной в WHERE строкой 'text'. 

При сравнении строк также допускается использовать неравенства:
--
SELECT column_1, column_2
FROM table
WHERE column_2 > 'text'
----
- такая операция используется реже, поскольку не вполне очевидно, что означает «одна строка больше другой».

На самом деле порядок сортировки данных строкового типа обычно определяется заранее установленными правилами сортировки, при которых значение имеют длина строки в символах, порядок букв в соответствии с алфавитом, наличие особых символов, регистр и т.д.

Подробнее о правилах сортировки данных строкового типа можно почитать здесь -
https://www.postgresql.org/docs/current/collation.html

***

Задание:

Отберите пользователей женского пола из таблицы users. Выведите только id этих пользователей. Результат отсортируйте по возрастанию id.
Добавьте в запрос оператор LIMIT и выведите только 1000 первых id из отсортированного списка.
Поле в результирующей таблице: user_id
Пояснение:
Обратите внимание, что в SELECT можно не включать колонку, которая используется для фильтрации в операторе WHERE. Так, например, в этом задании мы не включаем в результат колонку с полом пользователя.
--
SELECT user_id
FROM   users
WHERE  sex = 'female'
ORDER BY user_id limit 1000;
----

В качестве значений для фильтрации можно также использовать даты и время:
--
SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31'


SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31 00:00:00'
----
- при этом важно заранее убедиться, что в колонке, по которой будут фильтроваться данные, находятся именно даты или отметки времени, а не данные строкового типа, внешне похожие на даты. Если в колонке окажутся строки, то как таковой ошибки не произойдёт, однако результат будет сильно отличаться от ожидаемого.

Также в операциях сравнения дат важно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'.

Кстати, ничто не запрещает нам комбинировать в блоке WHERE разные условия с разными типами данных и создавать более сложные логические выражения:
--
SELECT column_1, column_2, column_3
FROM table
WHERE column_1 >= 0 
      AND column_2 = 'some text' 
      AND column_3 = '2022-12-31'
----

***

Задание:

Отберите из таблицы user_actions все действия пользователей по созданию заказов, которые были совершены ими после полуночи 6 сентября 2022 года. Выведите колонки с id пользователей, id созданных заказов и временем их создания.
Результат должен быть отсортирован по возрастанию id заказа.
Поля в результирующей таблице: user_id, order_id, time
Пояснение:
Обратите внимание, что в таблице user_actions у каждого пользователя могут быть записи не только со временем создания заказа, но и временем его отмены. Нам необходимо получить только записи с созданием заказов.
--
SELECT user_id, order_id, time
FROM user_actions
WHERE action = 'create_order' AND time > '2022-09-06'
ORDER BY order_id;
----
+
--
SELECT user_id,
       order_id,
       time
FROM   user_actions
WHERE  action = 'create_order'
   and time > '2022-09-06'
ORDER BY order_id
----

В операторе WHERE можно использовать не только колонки, которые уже есть в таблице, но в том числе и расчётные колонки. При этом указывать их в SELECT опять же не обязательно:
--
SELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average
FROM table
WHERE (column_1 + column_2) * 0.5 = 10


SELECT column_1, column_2
FROM table
WHERE (column_1 + column_2) * 0.5 = 10 
----

В примере выше мы отфильтруем только те записи, для которых среднее арифметическое двух чисел, которые содержатся в колонках column_1 и column_2, будет равно 10.

Также важно учитывать, что использовать в блоке WHERE алиасы, присвоенные новым расчётным колонкам, нельзя. Обратите внимание на примеры следующих запросов, которые считают долю значений из колонки column_1 в соответствующих им значениях из колонки column_2. Первый запрос сработает, а второй вернёт ошибку:
--
-- Этот запрос сработает:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE column_1 / column_2 > 50


-- Этот запрос вернёт ошибку:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE share > 50
----

Это связано со всё той же последовательностью выполнения операторов в запросе: на момент выполнения оператора WHERE алиас колонке ещё не присвоен, и поэтому база данных пока не знает о существовании колонки с новым именем.

Можно рассмотреть ещё более тривиальный пример: даже если мы просто сделаем дубликат колонки с другим именем и попробуем использовать это имя в WHERE, то всё равно получим ошибку:
--
-- Этот запрос вернёт ошибку:
SELECT column, column AS same_column
FROM table
WHERE same_column > 0
----

При указании фильтров в блоке WHERE важно учитывать рассмотренные особенности. Можете руководствоваться следующим правилом: если собираетесь фильтровать данные по расчётной колонке, то дублируйте расчёты в WHERE и не используйте алиасы, присвоенные новым колонкам.

***

Назначьте скидку 20% на все товары из таблицы products и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите id товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите old_price, с новой — new_price.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
Пояснение:
Будьте внимательны, когда будете указывать фильтр после оператора WHERE.
--
SELECT product_id, name, price AS old_price, price/100*80 AS new_price
FROM products
WHERE price/100*80 > 100
ORDER BY product_id;
----
+
--
SELECT product_id,
       name,
       price as old_price,
       price*0.8 as new_price
FROM   products
WHERE  price*0.8 > 100
ORDER BY product_id
----

После оператора WHERE к колонкам можно также применять разные функции:
--
SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'
----
































