https://github.com/halltape/HalltapeRoadmapDE

************************************
************************************
************************************

1 - SQL с нуля до оконок - 
https://karpov.courses/simulator-sql

karpov.courses
>>>
Логин -
smnhkthre@emltmp.com
Пароль -
a........kar!
>>>

Redash - 
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

Тренажер с упражнениями по SQL - 
https://www.sql-ex.ru/
lex1904
a........sx6!

Все необходимые для прохождения курса инструменты мы развернули на нашем сервере. Они находятся во вкладке Инструменты в левом верхнем углу.

Основной инструмент для работы на курсе — Redash. Подробнее о том, как с ним работать, вы узнаете в уроке Базовые запросы SQL.  

Подключение к Redash
Переходите во вкладку Инструменты и выбирайте Redash. 
Выбираем LDAP/SSO login

Заполняем поля:  
Логин: ваш email
Пароль: пароль от личного кабинета в LMS



Схема базы данных
В этом шаге хранится документация, которая поможет вам разобраться в данных. На схеме ниже показаны связи между таблицами, а ещё ниже представлено подробное описание данных.
Рекомендуем сохранить ссылку на этот шаг. Он ещё не раз вам пригодится — особенно, когда мы начнём объединять таблицы друг с другом -
https://lab.karpov.courses/learning/152/module/1762/lesson/17923/51794/244290/

Типы данных
В таблицах могут храниться разные типы данных: целые и дробные числа, текст, даты, массивы из чисел. В наших данных вы встретитесь со следующими типами:

Тип данных	
Описание	
Пример

INT	
Целое число	
id пользователя: 132

NUMERIC / DECIMAL	
Вещественное число	
Стоимость товара: 120.55

VARCHAR	
Текст	
Действие с заказом: «create_order»

DATE	
Дата с точностью до дня	
Дата рождения пользователя: 25/03/91

TIMESTAMP	
Дата с точностью до секунды	
Время регистрации в приложении: 24/08/22 01:52:24

[]	
Массив	
Список id товаров в заказе: [1, 13, 22]



Работа в Redash
В этом уроке мы начнем работать с инструментом Redash для написания SQL запросов. 

Чтобы попасть в Redash, зайдите в раздел Инструменты, или сохранить у себя ссылку -
https://redash.public.karpov.courses/?_gl=1*1us9fps*_ga*MzcxOTI0MDY1LjE3MzY3NjMyMDg.*_ga_DZP7KEXCQQ*MTczNjkzMTE4NC42LjAuMTczNjkzMTE4NC42MC4wLjA.

В предыдущем уроке мы подготовили инструкцию, как залогиниться в Redash - 
https://lab.karpov.courses/learning/152/module/1762/lesson/17931/51793/251405/

После успешного логина, чтобы начать писать запросы, нажмите на -
Create - New Query

Затем в списке доступных баз данных выберите -
Simulator SQL

запустить запрос - CTR + ENTER 

--
SELECT * 
FROM couriers 
LIMIT 20;
----

--
SELECT action, order_id, time 
FROM courier_actions 
LIMIT 20;
----

всегда ставить LIMIT (чтобы не зависла большая база)

чем более явный запрос - тем лучше (имена колонок, а не *)

ORDER BY name_colons DESK - сортировка -
--
SELECT action, order_id, time 
FROM courier_actions 
ORDER BY order_id DESC
LIMIT 20;

по возрастанию - 
ASC (или ничего не писать) - 
вверху маленькие внизу большие

по убыванию -
DESC - вверху большие внизу маленькие 

--
ASC   DESC
 A     V 
----
- ASC короче (3 буквы) и потом расширяется
- DESC длиннее (4 буквы) и потом сужается 

запросы к БД можно писать и напрямую из командной строки терминала -
--
simulator-sql-karpov-editor=> select * from users limit 1;
----

ключевые слова - писать заглавными буквами 

redash - это целая инфраструктура, позволяет делать дашборды, настраивать алерты и т.п. 

под окном для ввода кода запросов кнопки - 

- третья слева (с молнией) - включает подсказки для запросов 

- вторая слева - автоформатирование - расставляет отступы 

- внизу кнопка с тремя точками - выгрузить результаты 

- кнопка Save справа под окном для запросов - созранить запрос - ввести название и будет сформирована интернет-ссылка на запрос - потом созраненные запросы можно объединять в дашборды 

Redash в выводе не выводит полностью секунды, хотя в БД записи храняться с секундами 

Redash в выводе округляет числа до двух знаков после запятой, но в фактическом результате нет - использовать -
--
SELECT round(10.0 / 7, 2) as res;
----
- ручное округление

--
SELECT (10.0 / 7, 2)::text;
----
- выводит как текст

--так делают комментарий в коде SQL 

ответ на задание Карпова - 
--
SELECT *
FROM courier_actions 
ORDER BY courier_id DESC
LIMIT 100;
----

нужно и важно уметь самому переводить требования на язык SQL 

Общепринятый стиль написания SQL-запросов -
https://www.sqlstyle.guide/ru/

Отформатировать свой код можно с помощью этого сервиса - 
https://codebeautify.org/sqlformatter

Правильный порядок операторов в запросе выглядит так -
SELECT -- перечисление полей результирующей таблицы
FROM -- указание источника данных
WHERE -- фильтрация данных
GROUP BY -- группировка данных
HAVING -- фильтрация данных после группировки
ORDER BY -- сортировка результирующей таблицы
LIMIT -- ограничение количества выводимых записей

для начала напишем самый простой запрос и посмотрим, как выглядит таблица products.

Чтобы вывести все записи со значениями во всех колонках, необходимо либо перечислить все колонки в операторе SELECT, либо указать после оператора специальный символ «*»:
--
SELECT column_1, column_2, ...
FROM table


SELECT *
FROM table
----
Оператор FROM всегда указывается после оператора SELECT. В обратном порядке их записывать нельзя — база данных вернёт ошибку.

***

Задание:

Выведите все записи из таблицы products.
Поля в результирующей таблице: product_id, name, price
--
SELECT product_id,
       name,
       price
FROM   products;
----

Для сортировки значений по какой-либо колонке в SQL используется оператор ORDER BY с ключевыми словами ASC (по возрастанию) или DESC (по убыванию).

При этом по умолчанию сортировка происходит по возрастанию, т.е. ASC указывать не обязательно. Для сортировки по убыванию после ORDER BY необходимо явно указать DESC:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1        -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 ASC    -- сортировка по возрастанию


SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC   -- сортировка по убыванию
----
Оператор ORDER BY всегда указывается после операторов SELECT и FROM

***

Задание:

Выведите все записи из таблицы products, отсортировав их по наименованиям товаров в алфавитном порядке, т.е. по возрастанию. Для сортировки используйте оператор ORDER BY.
Поля в результирующей таблице: product_id, name, price
Пояснение:
Сортировку можно делать не только по полям со значениями, выраженными числами, но и по полям, значения в которых представлены в виде текста, как в нашем случае.
--
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name asc;
----
+
--
SELECT product_id,
       name,
       price
FROM   products
ORDER BY name
----

Сортировать результат SQL-запроса можно сразу по нескольким колонкам, указывая их после ORDER BY через запятую вместе с направлением сортировки (ASC или DESC):
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2    
-- сначала сортировка по первой колонке (по убыванию), 
-- затем по второй (по возрастанию)
----

Для ограничения числа извлекаемых из таблицы записей применяется оператор LIMIT -
--
SELECT column
FROM table
LIMIT n 
----
На месте n может быть любое целое число — ровно столько записей, сколько вам необходимо. Например, 100:
--
SELECT column
FROM table
LIMIT 100
----
Если n превысит количество записей в таблице, то в результат попадут все записи.

Важно помнить, что при работе с большими таблицами нужно по возможности ограничивать число извлекаемых записей, чтобы не создавать лишнюю нагрузку на базу данных.

Разумеется, операторы ORDER BY и LIMIT можно совмещать в одном запросе, при этом оператор LIMIT записывается и выполняется после оператора ORDER BY, ограничивая число записей в уже отсортированном результате:
--
SELECT column_1, column_2
FROM table
ORDER BY column_1 DESC, column_2
LIMIT 100
----

***

Задание:

Отсортируйте таблицу courier_actions сначала по колонке courier_id по возрастанию id курьера, потом по колонке action (снова по возрастанию), а затем по колонке time, но уже по убыванию — от самого последнего действия к самому первому. Не забудьте включить в результат колонку order_id.
Добавьте в запрос оператор LIMIT и выведите только первые 1000 строк результирующей таблицы.
Поля в результирующей таблице: courier_id, order_id, action, time
Пояснение:
Как вы уже догадались, сортировать таблицы можно в том числе по полям с датами и временем
--
SELECT courier_id,
       order_id,
       action,
       time
FROM   courier_actions
ORDER BY courier_id, action, time desc limit 1000;
----

Важно запомнить порядок записи всех известных нам ключевых слов:
SELECT
FROM
ORDER BY
LIMIT

Также важно понять, что порядок их выполнения несколько отличается от того, в какой последовательности они указываются в SQL-запросе:
1 - Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
2 - Затем SELECT — отбираются указанные столбцы.
3 - Потом ORDER BY — производится сортировка результирующей таблицы.
4 - И в самом конце LIMIT — ограничивается количество выводимых записей.

***

Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, определите 5 самых дорогих товаров в таблице products, которые доставляет наш сервис. Выведите их наименования и цену.
Поля в результирующей таблице: name, price
--
SELECT name,
       price
FROM   products
ORDER BY price desc limit 5;
----

При составлении SQL-запросов колонкам в результирующей таблице можно присваивать любые другие имена (их ещё называют «алиасами»). Это можно делать с помощью оператора AS:
--
SELECT name AS new_name
FROM table
----

Если вдруг вам покажется, что на написание оператора AS уходит слишком много времени и сил, то его можно опустить, указав новое имя колонки без него. Следующая запись тоже сработает:
--
SELECT name new_name
FROM table
----

***

Задание:

Как в прошлом задании определите 5 самых дорогих товаров в таблице products. Но теперь колонки name и price переименуйте соответственно в product_name и product_price.
Поля в результирующей таблице: product_name, product_price
--
SELECT name as product_name,
       price as product_price
FROM   products
ORDER BY product_price desc limit 5;
----

В SQL-запросах к колонкам таблиц можно применять разные функции — так же, как, например, в Excel. В общем виде синтаксис функций выглядит примерно так -
--
SELECT function(a, b, c, ...)
FROM table
----
Вместо function указывается название функции, а в скобках — её аргументы. В качестве аргументов могут выступать как колонки со значениями, так и отдельные значения. В зависимости от функции количество необходимых для её работы аргументов может отличаться.

Если вы когда-нибудь работали в Excel, то вам наверняка знакомы разные функции вроде SUM, MIN, MAX и т.д., которые производят некоторые вычисления по столбцам. В SQL они называются агрегирующими функциями, и подробно о них мы будет говорить в последующих уроках.

Сейчас же в качестве примера рассмотрим функцию LENGTH. Она выполняет довольно простую задачу — подсчитывает количество символов в поданном ей на вход значении текстового типа (текстовый тип данных ещё часто называют строкой — от англ. «string»). Иными словами, функция LENGTH измеряет длину некоторой строки в символах -
--
SELECT LENGTH('karpov.courses')

Результат:
14
----

Функция LENGTH также может применяться ко всему столбцу. В таком случае длина в символах будет посчитана для каждого значения в столбце. Соответствующий запрос будет выглядеть так -
--
SELECT LENGTH(column) AS column_length
FROM table
----

***

Задание:

Используя операторы SELECT, FROM, ORDER BY и LIMIT, а также функцию LENGTH, определите товар с самым длинным названием в таблице products. Выведите его наименование, длину наименования в символах, а также цену этого товара. Колонку с длиной наименования в символах назовите name_length.
Поля в результирующей таблице: name, name_length, price
Пояснение:
Обратите внимание, что в этой задаче вам придётся сортировать результирующую таблицу по расчётной колонке name_length, которой изначально не было в таблице products.
Такая сортировка по новым колонкам возможна, поскольку это согласуется с порядком выполнения операторов в запросе: сначала выполняется выбор колонок и все преобразования над ними в операторе SELECT — и только потом производится сортировка по указанным в ORDER BY столбцам. То есть к моменту сортировки все расчётные поля уже существуют, а значит, их можно указывать в ORDER BY.
Также обратите внимание, что мы дважды указываем колонку name в операторе SELECT: в первый раз просто обращаемся к ней по имени, а во второй — используем её в качестве аргумента функции LENGTH. В этом случае тоже нет никаких противоречий — мы можем выбирать колонку столько раз, сколько необходимо, причём для этого даже необязательно присваивать этим колонкам разные алиасы (база данных сама переименует дубликат колонки).
--
SELECT name,
       length(name) as name_length,
       price
FROM   products
ORDER BY name_length desc limit 1;
----

В SQL, как и во многих других языках, функции можно применять к результату других функций, т.е. последовательно -
--
SELECT function_one(function_two(a, b), c)
----

В приведённой выше конструкции a, b, c — аргументы функций. При этом одним из аргументов функции function_one является результат выполнения функции function_two.
Таким образом, сначала будет выполнена функция function_two, а затем её результат будет подан на вход функции function_one в качестве одного из аргументов.
Рассмотрим такой случай на примере функций UPPER и LEFT. Функция UPPER приводит поданное ей на вход текстовое значение к верхнему регистру, а функция LEFT — возвращает первые n символов в строке -
--
SELECT UPPER('karpov.courses')

Результат:
KARPOV.COURSES


SELECT LEFT('karpov.courses', 6)

Результат:
karpov
----

Мы можем применить эти функции последовательно, и в результате получим первые шесть символов верхнего регистра -
--
SELECT UPPER(LEFT('karpov.courses', 6)) AS new_name

Результат:
KARPOV
----

Важно: обратите внимание, что в блоке SELECT нельзя выполнить эти две операции раздельно, т.е. мы не можем сначала создать расчётную колонку с первыми шестью символами, а потом сразу же обратиться к этой новой колонке, применив к ней функцию UPPER. Следующий запрос выполнен не будет, база данных вернёт ошибку -
--
SELECT LEFT('karpov.courses', 6) AS new_name, UPPER(new_name) AS another_new_name

Результат:
Error running query: column "new_name" does not exist
----

В рамках одного запроса колонки создаются не по очереди, а вместе, поэтому в рамках одного запроса колонки new_name не существует, пока блок SELECT не будет выполнен полностью. Крайне важно учитывать эту особенность языка.

Однако на практике к новым колонкам приходится обращаться довольно часто — именно для этого существуют подзапросы (запросы к другим запросам), которые мы будем рассматривать в соответствующем уроке. А пока нам достаточно понимать, что применять функции к расчётным колонкам в том же запросе нельзя.

В следующей задаче мы будем использовать ещё одну функцию для работы с данными строкового типа — SPLIT_PART. Функция SPLIT_PART разбивает поданную ей на вход строку на несколько частей в соответствии с указанным разделителем и возвращает одну из частей.

Помимо самой строки (или колонки со значениями строкового типа) функция принимает ещё два аргумента — разделитель и порядковый номер части, которую необходимо вернуть -
--
SELECT SPLIT_PART('karpov.courses', '.', 2)

Результат:
courses
----
В примере выше строка 'karpov.courses' была разбита на две части ('karpov' и 'courses') по разделителю, выраженному символом «точка». Функция вернула 'courses', поскольку третьим аргументом мы указали часть с порядковым номером 2.

Подробнее с другими функциями для работы со строками можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/

***

Задание:

Примените последовательно функции UPPER и SPLIT_PART к колонке name и преобразуйте наименования товаров в таблице products так, чтобы от названий осталось только первое слово, записанное в верхнем регистре. Колонку с новым названием, состоящим из первого слова, назовите first_word.
В результат включите исходные наименования товаров, новые наименования из первого слова, а также цену товаров. Результат отсортируйте по возрастанию исходного наименования товара в колонке name.
Поля в результирующей таблице: name, first_word, price
--
SELECT name,
       upper(split_part(name, ' ', 1)) as first_word,
       price
FROM   products
ORDER BY name asc;
----

Иногда возникает необходимость изменить тип данных в какой-нибудь колонке результирующей таблицы, не меняя при этом свойства исходной таблицы — например, преобразовать число в текст (тип данных VARCHAR). Для этого существует функция CAST.

На вход функции CAST необходимо подать имя колонки, указав через AS тип данных, к которому нужно привести все значения -
--
SELECT CAST(column AS VARCHAR)
FROM table
----

Также изменить тип данных можно с помощью специального синтаксиса с двумя двоеточиями («::») -
--
SELECT column::VARCHAR
FROM table
----

Можете самостоятельно запустить в Redash следующий запрос -
--
SELECT CAST('100' AS INTEGER)

Результат:
100
----

В примере выше вместо колонки мы использовали всего одно значение и перевели текст '100' в число 100.

Обратите внимание, что для успешной конвертации значения должны быть конвертируемыми в указываемый тип. Например, текст, который не выглядит как число, перевести в числовой тип данных не получится -
--
SELECT CAST('text' AS INTEGER)

Результат:
Error running query: invalid input syntax for type integer: "text"
----

Аналогичным образом можно, например, преобразовать текст в дату (если он выглядит как дата) -
--
SELECT '2022-12-31'::DATE

Результат:
31/12/22
----

В Redash тип данных в колонке указан справа от её названия.

Подробнее с функцией CAST и преобразованием типов данных можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-cast/

Про сами типы данных можно почитать тут -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-data-types/

***

Задание:

Измените тип колонки price из таблицы products на VARCHAR. Выведите колонки с наименованием товаров, ценой в исходном формате и ценой в формате VARCHAR. Новую колонку с ценой в новом формате назовите price_char.
Результат отсортируйте по возрастанию исходного наименования товара в колонке name. Количество выводимых записей не ограничивайте.
Поле в результирующей таблице: name, price, price_char
--
SELECT name,
       price,
       price::varchar as price_char
FROM   products
ORDER BY name asc;
----
+
--
SELECT name,
       price,
       cast(price as varchar) as price_char
FROM   products
ORDER BY name
----

Ещё немного поработаем с текстовыми данными и рассмотрим функцию CONCAT, с помощью которой можно соединять в одну строку значения из нескольких столбцов. 

Функция CONCAT принимает на вход несколько аргументов и возвращает результат их последовательного сложения друг с другом. Хорошая аналогия — составление предложений из разных карточек со словами -
--
SELECT CONCAT('SQL', ' ', 'Simulator ', 2022)

Результат:
SQL Simulator 2022
----
- При этом аргументы не обязательно должны быть выражены текстовыми значениями — главное, они должны быть конвертируемыми в текст. В примере выше число 2022 можно конвертировать в текст '2022', поэтому запрос работает без ошибок.

Ознакомиться с другими примерами использования функции CONCAT можно здесь -
https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-concat-function/

***

Задание:

Для первых 200 записей из таблицы orders выведите информацию в следующем виде (обратите внимание на пробелы):
Заказ № [id заказа] создан [дата]
Полученную колонку назовите order_info

При указании текстовых значений используйте одинарные кавычки.
Чтобы извлечь дату из значений в колонке, достаточно применить к ней функцию DATE или изменить её тип на DATE -
--
SELECT DATE(time)

SELECT CAST(time AS DATE)

SELECT time::DATE
----

ответ -
--
SELECT concat('Заказ № ',
              order_id,
              ' ',
              'создан ',
              creation_time::date) as order_info
FROM   orders limit 200;
----
+
--
SELECT concat('Заказ № ', order_id, ' создан ', date(creation_time)) as order_info
FROM   orders limit 200
----

в наших таблицах значения в некоторых колонках представлены в формате даты (DATE) и времени (TIMESTAMP). Давайте немного поработаем и с такими данными.
На практике часто встречаются задачи, когда нужна, например, не вся дата, а какая-то её часть: год, месяц, день, час и т.д. Извлечь эту часть из исходных данных позволяет функция DATE_PART. Её синтаксис следующий -
--
SELECT DATE_PART(part, column)
----
- На месте part необходимо в кавычках указать ту часть, которую нужно извлечь: 'year', 'month', 'day', 'hour' и т.д. На месте column следует указать нужную колонку либо конкретную дату или время. Можете самостоятельно запустить в Redash следующие запросы -
--
SELECT DATE_PART('year', DATE '2022-01-12')

Результат:
2022.00


SELECT DATE_PART('month', DATE '2022-01-12')

Результат:
1.00


SELECT DATE_PART('day', DATE '2022-01-12')

Результат:
12.00


SELECT DATE_PART('hour', TIMESTAMP '2022-01-12 20:31:05')
Результат:
20.00


SELECT DATE_PART('minute', TIMESTAMP '2022-01-12 20:31:05')

Результат:
31.00
----
- Выше в качестве примера мы указали конкретную дату. На её месте могла быть, например, колонка с датами dates. Тогда запрос выглядел бы так -
--
SELECT DATE_PART('day', dates)
----

Ознакомиться с другими примерами использования функции DATE_PART можно здесь -
https://www.postgresqltutorial.com/postgresql-date-functions/postgresql-date_part/

***

Задание:

Выведите id всех курьеров и их годы рождения из таблицы couriers.
Год рождения необходимо получить из колонки birth_date. Новую колонку с годом назовите birth_year. Результат отсортируйте сначала по убыванию года рождения курьера (т.е. от самых младших к самым старшим), затем по возрастанию id курьера.
Поля в результирующей таблице: courier_id, birth_year
--
SELECT courier_id,
       date_part('year', birth_date) as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id asc;
----

В прошлом задании для отдельных строк функция DATE_PART не вернула год рождения курьера — вместо них образовались пустые значения. Если не заметили, посмотрите внимательно на результат запроса из прошлого задания.

На самом деле это произошло потому, что в наших данных в колонке birth_date есть пропуски — так называемые NULL значения. Иными словами, для отдельных курьеров просто не указаны их дни рождения. Есть масса вариантов, почему так могло произойти, но у нас сейчас нет времени всё это выяснять — нам просто нужно научиться как-то обрабатывать такие случаи.

Давайте сделаем так, чтобы вместо пустых значений функция DATE_PART возвращала какое-нибудь другое значение. В этом нам поможет функция COALESCE, которая возвращает первое не NULL значение из списка поданных ей на вход аргументов.

Работу COALESCE можно описать следующим образом: она буквально читает список значений слева направо и, как только видит значение, которое не является NULL, сразу же возвращает его и прекращает чтение списка. Посмотрите внимательно на следующие примеры -
--
SELECT COALESCE(NULL, 'I am not NULL' , 'karpov.courses')

Результат:
I am not NULL


SELECT COALESCE(NULL, 25, 100, 150)

Результат:
25


SELECT COALESCE('NULL', 'I am not NULL', 'karpov.courses')

Результат:
NULL
----

Одним из аргументов функции COALESCE может выступать результат выполнения другой функции -
--
SELECT COALESCE(NULL, LOWER('I am not NULL'), 'karpov.courses')

Результат:
i am not null
----

Чтобы заполнить пропуски в колонке, достаточно применить функцию COALESCE к колонке с пропусками и указать в качестве второго аргумента то значение, которое мы хотим видеть вместо NULL -
--
SELECT COALESCE(column, 'filler value')
FROM table
----

Функция COALESCE применится к каждому значению в колонке. Если это значение окажется NULL, она заменит его на значение, указанное вторым аргументом. Если значение в колонке, наоборот, окажется не NULL, то функция просто вернёт это значение.

При этом к колонке с пропусками можно также заранее применять разные другие функции -
--
SELECT COALESCE(LEFT(column, 5), 'filler value')
FROM table
----

С другими примерами использования функции COALESCE можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-coalesce/

***

Задание:

Как и в предыдущем задании, снова выведите id всех курьеров и их годы рождения, только теперь к извлеченному году примените функцию COALESCE. Укажите параметры функции так, чтобы вместо NULL значений в результат попадало текстовое значение unknown. Названия полей оставьте прежними.
Отсортируйте итоговую таблицу сначала по убыванию года рождения курьера, затем по возрастанию id курьера.
Поля в результирующей таблице: courier_id, birth_year
Пояснение:
При указании текстового значения используйте одинарные кавычки, как в примерах выше.
Не забудьте учесть, что unknown — значение типа VARCHAR, а значит, извлечённый из даты год нужно тоже привести к этому типу. Поэтому сначала извлеките год, затем преобразуйте его в текст и далее применяйте к полученному значению функцию COALESCE
--
SELECT courier_id,
       coalesce(cast(date_part('year', birth_date) as varchar), 'unknown') as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id asc;
----
+
--
SELECT courier_id,
       coalesce(date_part('year', birth_date)::varchar, 'unknown') as birth_year
FROM   couriers
ORDER BY birth_year desc, courier_id
----

Для работы с числовыми значениями в PostgreSQL доступны разные арифметические операторы. Ниже в таблице указаны наиболее популярные -
--
+	Сложение	            2 + 3	5
-	Вычитание	            2 - 3	-1
*	Умножение	            2 * 3	6
/	Деление	                4 / 2	2
%	Остаток от деления	    5 % 4	1
^	Возведение в степень	2 ^ 3	8
----

Если бы мы захотели перевести 7500 рублей в доллары по курсу 1 доллар = 75 рублей, то операция выглядела бы следующим образом -
--
SELECT 7500 / 75

Результат:
100
----

Если бы нам потребовалось вычесть из каждого значения в одной из колонок нашей таблицы какое-то число (допустим, 100), то запрос выглядел бы так -
--
SELECT column - 100
FROM table
----

Кроме того, в арифметических операциях могут принимать участие сразу несколько колонок. Например, для каждой строчки таблицы можно вычислить среднее арифметическое двух чисел, которые содержатся в двух разных колонках -
--
SELECT (column_1 + column_2) / 2 AS average
FROM table
----

Ознакомиться со всеми арифметическими операторами можно здесь -
https://www.postgresql.org/docs/9.3/functions-math.html

***

Задание:

Давайте представим, что по какой-то необъяснимой причине мы вдруг решили в одночасье повысить цену всех товаров в таблице products на 5%.
Выведите id и наименования всех товаров, их старую и новую цену. Колонку со старой ценой назовите old_price, а колонку с новой — new_price.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
--
SELECT product_id,
       name,
       price as old_price,
       price*1.05 as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----

Наряду с арифметическими операторами в PostgreSQL также доступны разные математические функции. Например, для округления вещественных чисел («чисел с плавающей точкой») можно использовать ROUND -
--
SELECT ROUND(100.5454, 2)

Результат:
100.55


SELECT ROUND(100.551, 1)

Результат:
100.6


SELECT ROUND(100.5511)

Результат:
101.0
----
- Первым аргументом указывается само значение, которое хотим округлить. Вторым — число знаков после точки, до которого хотим округлить. Второй аргумент указывать не обязательно: если его не указать, произойдёт округление до целого числа (однако тип данных при этом не поменяется).

Также обратите внимание, что Redash накладывает дополнительное форматирование на выводимый результат, поэтому, например, результат второго запроса с настройками по умолчанию будет выглядеть так: 100.60

Настроить формат отображения и задать вручную число знаков после запятой можно с помощью кнопки Edit Visualization, расположенной в интерфейсе Redash сразу под результатом запроса.

Ознакомиться с другими математическими функциями можно здесь -
https://www.postgresqltutorial.com/postgresql-math-functions/

***

Задание:

Вновь, как и в прошлом задании, повысьте цену всех товаров на 5%, только теперь к колонке с новой ценой примените функцию ROUND. Выведите id и наименования товаров, их старую цену, а также новую цену с округлением. Новую цену округлите до одного знака после запятой, но тип данных не меняйте.
Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
--
SELECT product_id,
       name,
       price as old_price,
       round((price * 1.05), 1) as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----

Если бы мы захотели повысить цену не на все товары, а, скажем, только на дорогие?

Для этого нам бы потребовалось создать некоторую функцию, которая проверяла бы каждое значение в колонке price и сравнивала бы его с каким-то пороговым значением. Если бы цена оказывалась выше этого порога, то функция повышала бы цену, а если нет — оставляла бы без изменений.

И такую функцию как раз можно задать с помощью условной конструкции CASE. Она имеет следующий синтаксис -
--
CASE  
WHEN logical_expression_1 THEN expression_1
WHEN logical_expression_2 THEN expression_2
...
ELSE expression_else
END AS case_example
----
- Эта конструкция может показаться громоздкой, но на самом деле в ней нет ничего сложного. Логика работы оператора CASE довольно простая:

1. На каждом этапе WHEN – THEN вычисляется некоторое логическое выражение logical_expression, стоящее после WHEN. Если оно оказывается истинным (TRUE), то в качестве результата оператор возвращает выражение expression, стоящее после THEN, и заканчивает свою работу.
2. Если выражение оказывается ложным (FALSE), то оператор продолжает работу и проверяет следующее условие.
3. Если ни одно из условий не проходит проверку на истинность, то возвращается выражение, указанное после ELSE. При этом ELSE указывать не обязательно — если его не указать, то вернётся пустое значение NULL (в случае, если все проверки после WHEN оказались ложными).
4. В конце обязательно указывается ключевое слово END, которое говорит об окончании конструкции CASE. Также после END новому расчётному полю с помощью AS можно присвоить некоторое имя, но это делать не обязательно. Обязательными являются только ключевые слова CASE,  WHEN,  THEN и END.

Пример:

Следующая конструкция разобъёт весь список наименований на три категории: «мясо», «рыба» и «другое». Соответственно, если в первых двух условиях мы не учтём какие-то наименования из колонки name (например, «телятину»), то они попадут в категорию «другое» -
--
SELECT name,
       CASE 
       WHEN name='свинина' OR name='курица' THEN 'мясо'
       WHEN name='треска' OR name='окунь' THEN 'рыба'
       ELSE 'другое'
       END AS сategory
FROM table
----

Теперь немного о логических выражениях: в SQL они могут включать операторы сравнения и логические операции.

К операторам сравнения относятся - 
= («равно»)
<> или != («не равно»)
< («меньше»)
> («больше»)
<= («меньше или равно»)
>= («больше или равно»)

Результатом работы операторов сравнения могут быть три состояния:
TRUE («истина»)
FALSE («ложь»)
NULL («неопределённое состояние» — когда одно из сравниваемых значений NULL)

С этими тремя состояниями можно проводить следующие логические операции:
AND («И»)
OR («ИЛИ»)
NOT («НЕ»)

Результатом этих логических операций также могут быть три вышеуказанных логических состояния (TRUE, FALSE или NULL):
a	    b	    a AND b	   a OR b
TRUE	TRUE	TRUE	   TRUE
TRUE	FALSE	FALSE	   TRUE
TRUE	NULL	NULL	   TRUE
FALSE	FALSE	FALSE	   FALSE
FALSE	NULL	FALSE	   NULL
NULL	NULL	NULL	   NULL

a	    NOT a
TRUE	FALSE
FALSE	TRUE
NULL	NULL

Таким образом, операторы сравнения и логические операции позволяют писать комплексные логические выражения.

Запоминать все эти таблицы и комбинации не обязательно. Вы разберётесь с ними по ходу курса — главное, всегда держите эту памятку под рукой. 

Существуют приоритеты выполнения операций:
1. умножение и деление (* и /)
2. сложение и вычитание (+ и -)
3. операторы сравнения (=, !=, >, <, >=, <=)
4. NOT
5. AND
6. OR

На порядок выполнения операторов также можно влиять с помощью скобок. Выражения, помещённые в скобки, будут иметь наивысший приоритет — всё как в математике.

***

Задание:

Повысьте цену на 5% только на те товары, цена которых превышает 100 рублей. Цену остальных товаров оставьте без изменений. Также не повышайте цену на икру, которая и так стоит 800 рублей. Выведите id и наименования всех товаров, их старую и новую цену. Цену округлять не нужно.

Результат отсортируйте сначала по убыванию новой цены, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, old_price, new_price
-
--
SELECT product_id,
       name,
       price AS old_price,
       CASE 
           WHEN price > 100 AND name <> 'икра' THEN price * 1.05 
           ELSE price
       END as new_price
FROM   products
ORDER BY new_price desc, product_id asc;
----
+
--
SELECT product_id,
       name,
       price as old_price,
       case when price <= 100 or
                 name = 'икра' then price
            when price > 100 then price*1.05
            else 0 
			end new_price
FROM   products
ORDER BY new_price desc, product_id
----

Представьте, что к вам обратился менеджер из соседнего отдела с просьбой посчитать НДС каждого товара. Никаких дополнительных данных он вам не предоставил, поэтому вы решили выполнить задачу на своё усмотрение, посчитав, что НДС единый для всех товаров и составляет 20%

***

Задание:

Вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и price_before_tax. Округлите значения в этих колонках до двух знаков после запятой.

Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.

Поля в результирующей таблице: product_id, name, price, tax, price_before_tax

Пояснение:

Так как НДС уже включён в текущую цену, налог считаем следующим образом: делим цену на 120% и умножаем на 20%.

Почему налог считается именно так, можно прочитать здесь -
https://nalog-nalog.ru/nds/stavka_nds/kak_pravilno_vyschitat_18_nds_iz_summy/
-
--
SELECT product_id, 
    name, 
	price, 
	ROUND((price / 120) * 20, 2) AS tax, 
	ROUND(price - ((price / 120) * 20), 2) AS price_before_tax
FROM products
ORDER BY price_before_tax DESC, product_id ASC;
----
+
--
SELECT product_id,
       name,
       price,
       round(price/120*20, 2) as tax,
       round(price - price/120*20, 2) as price_before_tax
FROM   products
ORDER BY price_before_tax desc, product_id
----

На этом уроке мы:

- Познакомились с операторами SELECT и FROM и научились составлять базовые запросы.

- Узнали, как сортировать записи с помощью оператора ORDER BY.

- Научились ограничивать количество выводимых записей с помощью оператора LIMIT.

- Выяснили, как преобразовывать типы данных с помощью CAST.

- Научились работать с датой и временем и познакомились с функцией DATE_PART.

- Узнали про NULL значения и поработали с COALESCE.

- Научились работать с текстовыми данными и соединять строки с помощью функции CONCAT.

- Поработали с арифметическими операторами и математическими функциями.

- Познакомились с конструкцией CASE и научились составлять комплексные логические выражения.

Известные нам на текущий момент ключевые слова и порядок их написания в запросе:
--
SELECT    -- перечисление полей результирующей таблицы
FROM      -- указание источника данных
ORDER BY  -- сортировка результирующей таблицы
LIMIT     -- ограничение количества выводимых записей
----

Лекция 4.1. Фильтрация данных -

WHERE - где 

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 167
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 AND order_id = 56176
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 AND action = 'deliver_order'
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE courier_id = 3167 OR courier_id = 100
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE action = 'deliver_order' AND (courier_id = 3167 OR courier_id = 100)
LIMIT 100;
----

--
SELECT action, courier_id, order_id, time
FROM courier_actions
WHERE action = 'deliver_order' AND courier_id IN (12, 100, 212) 
LIMIT 100;
----

Фильтрация данных позволяет включать в результирующий запрос не все строки исходной таблицы, а только те, которые соответствуют заранее заданному условию.

В SQL для фильтрации данных используется оператор WHERE. После оператора WHERE указывается логическое выражение, результат которого определяет, будет ли строка включена в результирующую таблицу. Если условие оказывается истинным (TRUE), то строка включается в результат, если ложным (FALSE) — строка исключается.

Таким образом, каждая строка в таблице проходит проверку на соответствие определённому условию, и в результате этих проверок формируется таблица, над которой затем проводятся операции, указанные в блоке SELECT.

Оператор WHERE и логическое выражение указываются после блока FROM:
--
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
----

Например, в результате указанного выше запроса в выборку попадут только записи с неотрицательными значениями в колонке column_2.

В свою очередь операторы ORDER BY и LIMIT записываются уже после оператора WHERE. Если добавить их в пример выше, то запрос будет выглядеть так:
--
SELECT column_1, column_2
FROM table
WHERE column_2 >= 0
ORDER BY column_1
LIMIT 100
----

В результате мы сначала отфильтруем необходимые нам строки, затем выберем столбцы, отмеченные в SELECT, а потом отсортируем результирующую таблицу, ограничив число выводимых записей.

Таким образом, порядок записи известных нам на текущий момент ключевых слов выглядит так:
SELECT
FROM
WHERE
ORDER BY
LIMIT

Снова обратим внимание, что порядок их выполнения отличается от того, в какой последовательности они указываются в запросе:
1 - Сначала выполняется оператор FROM — происходит выбор нужной таблицы.
2 - Далее WHERE — отфильтровываются строки, соответствующие условию.
3 - Затем SELECT — отбираются указанные столбцы и применяются функции.
4 - Потом ORDER BY — производится сортировка результирующей таблицы.
5 - И в самом конце LIMIT — ограничивается количество выводимых записей.

Иными словами, в результате выполнения запроса сначала происходит подготовка таблицы к работе, а уже затем над ней выполняются разные операции.

Подробнее про оператор WHERE можно почитать здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-where/

***

Напишите SQL-запрос к таблице products и выведите всю информацию о товарах, цена которых не превышает 100 рублей. Результат отсортируйте по возрастанию id товара.
Поля в результирующей таблице: product_id, name, price
--
SELECT product_id,
       name,
       price
FROM   products
WHERE  price <= 100
ORDER BY product_id;
----

Фильтровать данные в таблицах можно не только по полям с числовыми значениями, но и по полям со значениями, представленными в виде текста:
--
SELECT column_1, column_2
FROM table
WHERE column_2 = 'text'
----
- в результирующую таблицу попадут только строки, значения в которых полностью совпадают с указанной в WHERE строкой 'text'. 

При сравнении строк также допускается использовать неравенства:
--
SELECT column_1, column_2
FROM table
WHERE column_2 > 'text'
----
- такая операция используется реже, поскольку не вполне очевидно, что означает «одна строка больше другой».

На самом деле порядок сортировки данных строкового типа обычно определяется заранее установленными правилами сортировки, при которых значение имеют длина строки в символах, порядок букв в соответствии с алфавитом, наличие особых символов, регистр и т.д.

Подробнее о правилах сортировки данных строкового типа можно почитать здесь -
https://www.postgresql.org/docs/current/collation.html

***

Задание:

Отберите пользователей женского пола из таблицы users. Выведите только id этих пользователей. Результат отсортируйте по возрастанию id.
Добавьте в запрос оператор LIMIT и выведите только 1000 первых id из отсортированного списка.
Поле в результирующей таблице: user_id
Пояснение:
Обратите внимание, что в SELECT можно не включать колонку, которая используется для фильтрации в операторе WHERE. Так, например, в этом задании мы не включаем в результат колонку с полом пользователя.
--
SELECT user_id
FROM   users
WHERE  sex = 'female'
ORDER BY user_id limit 1000;
----

В качестве значений для фильтрации можно также использовать даты и время:
--
SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31'


SELECT column_1
FROM table
WHERE column_2 <= '2022-12-31 00:00:00'
----
- при этом важно заранее убедиться, что в колонке, по которой будут фильтроваться данные, находятся именно даты или отметки времени, а не данные строкового типа, внешне похожие на даты. Если в колонке окажутся строки, то как таковой ошибки не произойдёт, однако результат будет сильно отличаться от ожидаемого.

Также в операциях сравнения дат важно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'.

Кстати, ничто не запрещает нам комбинировать в блоке WHERE разные условия с разными типами данных и создавать более сложные логические выражения:
--
SELECT column_1, column_2, column_3
FROM table
WHERE column_1 >= 0 
      AND column_2 = 'some text' 
      AND column_3 = '2022-12-31'
----

***

Задание:

Отберите из таблицы user_actions все действия пользователей по созданию заказов, которые были совершены ими после полуночи 6 сентября 2022 года. Выведите колонки с id пользователей, id созданных заказов и временем их создания.
Результат должен быть отсортирован по возрастанию id заказа.
Поля в результирующей таблице: user_id, order_id, time
Пояснение:
Обратите внимание, что в таблице user_actions у каждого пользователя могут быть записи не только со временем создания заказа, но и временем его отмены. Нам необходимо получить только записи с созданием заказов.
--
SELECT user_id, order_id, time
FROM user_actions
WHERE action = 'create_order' AND time > '2022-09-06'
ORDER BY order_id;
----
+
--
SELECT user_id,
       order_id,
       time
FROM   user_actions
WHERE  action = 'create_order'
   and time > '2022-09-06'
ORDER BY order_id
----

В операторе WHERE можно использовать не только колонки, которые уже есть в таблице, но в том числе и расчётные колонки. При этом указывать их в SELECT опять же не обязательно:
--
SELECT column_1, column_2, (column_1 + column_2) * 0.5 AS average
FROM table
WHERE (column_1 + column_2) * 0.5 = 10


SELECT column_1, column_2
FROM table
WHERE (column_1 + column_2) * 0.5 = 10 
----

В примере выше мы отфильтруем только те записи, для которых среднее арифметическое двух чисел, которые содержатся в колонках column_1 и column_2, будет равно 10.

Также важно учитывать, что использовать в блоке WHERE алиасы, присвоенные новым расчётным колонкам, нельзя. Обратите внимание на примеры следующих запросов, которые считают долю значений из колонки column_1 в соответствующих им значениях из колонки column_2. Первый запрос сработает, а второй вернёт ошибку:
--
-- Этот запрос сработает:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE column_1 / column_2 > 50


-- Этот запрос вернёт ошибку:

SELECT column_1, column_2, 
       column_1 / column_2 AS share
FROM table
WHERE share > 50
----

Это связано со всё той же последовательностью выполнения операторов в запросе: на момент выполнения оператора WHERE алиас колонке ещё не присвоен, и поэтому база данных пока не знает о существовании колонки с новым именем.

Можно рассмотреть ещё более тривиальный пример: даже если мы просто сделаем дубликат колонки с другим именем и попробуем использовать это имя в WHERE, то всё равно получим ошибку:
--
-- Этот запрос вернёт ошибку:
SELECT column, column AS same_column
FROM table
WHERE same_column > 0
----

При указании фильтров в блоке WHERE важно учитывать рассмотренные особенности. Можете руководствоваться следующим правилом: если собираетесь фильтровать данные по расчётной колонке, то дублируйте расчёты в WHERE и не используйте алиасы, присвоенные новым колонкам.

***

Назначьте скидку 20% на все товары из таблицы products и отберите те, цена на которые с учётом скидки превышает 100 рублей. Выведите id товаров, их наименования, прежнюю цену и новую цену с учётом скидки. Колонку со старой ценой назовите old_price, с новой — new_price.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name, old_price, new_price
Пояснение:
Будьте внимательны, когда будете указывать фильтр после оператора WHERE.
--
SELECT product_id, name, price AS old_price, price/100*80 AS new_price
FROM products
WHERE price/100*80 > 100
ORDER BY product_id;
----
+
--
SELECT product_id,
       name,
       price as old_price,
       price*0.8 as new_price
FROM   products
WHERE  price*0.8 > 100
ORDER BY product_id
----

После оператора WHERE к колонкам можно также применять разные функции:
--
SELECT column_1, column_2
FROM table 
WHERE LOWER(column_1) = 'karpov.courses'
----

В примере выше каждое значение в колонке column_1 сначала будет приведено к нижнему регистру, а затем сопоставлено со значением 'karpov.courses'. При этом в результат будут включены исходные значения в колонке column_1. Таким образом, функция послужит только для фильтрации записей, но на сами значения в колонках никак не повлияет.

Обратите внимание, что использовать алиасы, присвоенные колонкам в операторе SELECT, всё так же нельзя. Следующий запрос вернёт ошибку:
--
-- Этот запрос вернёт ошибку:

SELECT column_1 AS new_column_1, column_2
FROM table 
WHERE LOWER(new_column_1) = 'karpov.courses'
----

***

Задание:
Отберите из таблицы products все товары, названия которых либо начинаются со слова «чай», либо состоят из пяти символов. Выведите две колонки: id товаров и их наименования.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name
Пояснение:
Для решения задачи вам пригодятся функции SPLIT_PART и LENGTH, которые мы рассматривали на прошлом уроке.
--
SELECT product_id, name
FROM products 
WHERE LENGTH(name) = 5 OR SPLIT_PART(name, ' ', 1) = 'чай'
----
+
--
SELECT product_id,
       name
FROM   products
WHERE  split_part(name, ' ', 1) = 'чай'
    or length(name) = 5
ORDER BY product_id
----

Из общего списка наименований товаров нам вдруг понадобилось отобрать определённые позиции, содержащие определённые слова или даже символы. Но при этом мы точно не знаем, в какой части наименования их можно встретить.

Например, нам нужны все «чаи», но они необязательно должны начинаться со слова «чай». Нам также подойдёт «иван-чай» или какой-нибудь «чайный напиток».

Но как это сделать? Неужели нам придётся просматривать всю таблицу, вручную составлять список товаров и писать длинное логическое выражение, учитывающее все возможные сценарии?

Разумеется, не придётся. Для фильтрации по колонкам с текстовыми значениями в SQL предусмотрен оператор LIKE.

Оператор LIKE не просто сравнивает строки на полное совпадение (или несовпадение), а проверяет их на соответствие заданному шаблону: если строка ему соответствует, то возвращается TRUE, в противном случае — FALSE. Как можно догадаться, конструкция NOT LIKE работает с точностью до наоборот.

Шаблоны могут содержать как обычные символы, так и символы-шаблоны: знак процента ( % ) и подчёркивание ( _ ). Подчёркивание подменяет любой одиночный символ, а знак процента — любую (в том числе и пустую) последовательность символов:
--
SELECT 'karpov.courses' LIKE 'karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov_'

Результат:
false

SELECT 'karpov.courses' LIKE '%karpov%'

Результат:
true

SELECT 'karpov.courses' LIKE '_karpov%'

Результат:
false

SELECT 'karpov.courses' LIKE '%.%'

Результат:
true

SELECT 'karpov.courses' LIKE '_._'

Результат:
false

SELECT 'karpov.courses' LIKE 'Karpov%'

Результат:
false
----
- обратите внимание на последний пример: оператор LIKE чувствителен к регистру.

Если шаблон не содержит знаков процента и подчёркиваний, тогда шаблон представляет собой строку и LIKE работает как оператор сравнения, проверяя строки на точное совпадение -
--
SELECT 'karpov.courses' LIKE 'karpov.courses'

Результат:
true

SELECT 'karpov.courses' LIKE 'karpov'

Результат:
false
----

Подробнее про оператор LIKE и шаблоны можно почитать здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-like/

***

Задание:

Отберите из таблицы products все товары, содержащие в своём названии последовательность символов «чай» (без кавычек). Выведите две колонки: id продукта и его название.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name
--
SELECT product_id, name
FROM products 
WHERE name LIKE '%чай%'
ORDER BY product_id ASC;
----
+
--
SELECT product_id,
       name
FROM   products
WHERE  name like '%чай%'
ORDER BY product_id
----

Сделаем наш фильтр чуть поинтереснее

***

Задание:

Выберите из таблицы products id и наименования только тех товаров, названия которых начинаются на букву «с» и содержат только одно слово.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name
--
SELECT product_id, name
FROM products 
WHERE name LIKE 'с%' AND name NOT LIKE '% %'
ORDER BY product_id ASC;
----
+
--
SELECT product_id,
       name
FROM   products
WHERE  name not like '% %'
   and name like 'с%'
ORDER BY product_id
----

К вам обратился менеджер, которому в голову пришла идея сделать скидку на самый дорогой чай. Он попросил вас предоставить ему выгрузку из базы данных со всеми чаями и новыми ценами на них с учётом скидки

***

Задание:

Составьте SQL-запрос, который выбирает из таблицы products все чаи стоимостью больше 60 рублей и вычисляет для них цену со скидкой 25%.
Скидку в % менеджер попросил указать в отдельном столбце в формате текста, то есть вот так: «25%» (без кавычек). Столбцы со скидкой и новой ценой назовите соответственно discount и new_price.
Также необходимо любым известным способом избавиться от «чайного гриба»: вряд ли менеджер имел в виду и его, когда ставил нам задачу.
Результат должен быть отсортирован по возрастанию id товара.
Поля в результирующей таблице: product_id, name, price, discount, new_price
Пояснение:
Чтобы указать столбец с одним значением для всех записей (в нашем случае это столбец со скидкой), достаточно просто ввести нужное значение и дать столбцу какое-то название — указанное значение автоматически проставится во всех строках результирующей таблицы (пример) -
--
SELECT column_1, 'text' AS column_2
FROM table
----

--
SELECT product_id, name, price, '25%' AS discount, price*0.75 AS new_price
FROM products 
WHERE price > 60 AND name LIKE '%чай%' AND name NOT LIKE 'чайный гриб'
ORDER BY product_id ASC;
----
+
--
SELECT product_id,
       name,
       price,
       '25%' as discount,
       price*0.75 as new_price
FROM   products
WHERE  name like '%чай %'
   and price > 60
ORDER BY product_id
----

Но что если мы всё-таки не хотим проверять наши данные на соответствие какому-то шаблону, а просто хотим отобрать значения из некоторого списка или даже диапазона? В этом случае в логическом выражении после ключевого слова WHERE можно использовать операторы IN и BETWEEN.

Оператор IN проверяет, соответствует ли значение в колонке одному из значений из заданного списка. Иными словами, он проверяет, входит ли значение в этот список -
--
SELECT column_1, column_2
FROM table
WHERE column_1 IN ('product_1', 'product_2', 'product_3')
----

В свою очередь оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу. При этом границы интервала включаются:
--
SELECT column_1, column_2
FROM table
WHERE column_2 BETWEEN 5 AND 10
----
- этот запрос равносилен следующему запросу:
--
SELECT column_1, column_2
FROM table
WHERE column_2 >= 5 AND column_2 <= 10
----

Оператор BETWEEN можно использовать и для фильтрации по колонкам с датами и временем:
--
SELECT column_1, column_2, column_3
FROM table
WHERE column_3 BETWEEN '2022-11-20' AND '2022-12-31'
----
- в этом случае снова нужно учитывать, что дата всегда интерпретируется как полночь (начало дня), т.е. '2022-12-31' в действительности означает '2022-12-31 00:00:00'. Поэтому в заданный выше интервал не попадут записи позже полуночи '2022-12-31', т.е. этот день практически не будет учтён в интервале.

Запрос выше будет равносилен следующему запросу:
--
SELECT column_1, column_2, column_3
FROM table
WHERE column_3 >= '2022-11-20' AND column_3 <= '2022-12-31'
----

Для получения обратного результата в сочетании с операторами IN и BETWEEN можно использовать оператор NOT:
--
SELECT column_1, column_2
FROM table
WHERE column_1 NOT IN ('product_1', 'product_2', 'product_3')


SELECT column_1, column_2
FROM table
WHERE column_2 NOT BETWEEN 5 AND 10
----

Подробнее про операторы IN и BETWEEN можно прочитать здесь и здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-in/
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-between/

***

Задание:

Из таблицы user_actions выведите всю информацию о действиях пользователей с id 170, 200 и 230 за период с 25 августа по 4 сентября 2022 года включительно. Результат отсортируйте по убыванию id заказа — то есть от самых поздних действий к самым первым.
Поля в результирующей таблице: user_id, order_id, action, time
--
SELECT user_id, order_id, action, time
FROM user_actions
WHERE user_id IN (170, 200, 230) AND (time BETWEEN '2022-08-25' AND '2022-09-05')
ORDER BY order_id DESC;
----
+
--
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  user_id in (170, 200, 230)
   and time >= '2022-08-25'
   and time < '2022-09-05'
ORDER BY order_id desc
----

Ранее мы столкнулись с пропущенными значениями в таблице couriers — у некоторых курьеров не были указаны их дни рождения.

Для проверки на NULL значения в SQL есть оператор IS NULL. В сочетании с WHERE записывается он так:
--
SELECT column_1, column_2
FROM table
WHERE column_1 IS NULL
----

Если же, наоборот, необходимо отобрать не NULL значения, то дополнительно используется оператор NOT:
--
SELECT column_1, column_2
FROM table
WHERE column_1 IS NOT NULL
----

Как мы уже знаем, в мире данных NULL означает отсутствие информации. NULL — это не какая-то величина, и поэтому её нельзя сравнить с чем-либо ещё. Результатом сравнения NULL с любым другим значением будет тот же NULL. Более того, NULL не получится сравнить и с другим NULL, потому что в таком случае будут сравниваться две неопределённости и нельзя наверняка сказать, равны они или нет.

Попробуйте самостоятельно запустить в Redash следующие запросы и посмотрите на их результат:
--
SELECT NULL = NULL

Результат:
NULL

SELECT NULL IS NULL

Результат:
true

SELECT 100 = NULL

Результат:
NULL

SELECT 100 IS NULL

Результат:
false
----

Подробнее про NULL значения можно прочитать здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-is-null/

***

Задание:

Напишите SQL-запрос к таблице couriers и выведите всю информацию о курьерах, у которых не указан их день рождения.
Результат должен быть отсортирован по возрастанию id курьера.
Поля в результирующей таблице: birth_date, courier_id, sex
--
SELECT birth_date, courier_id, sex
FROM couriers
WHERE birth_date IS NULL
ORDER BY courier_id ASC;
----
+
--
SELECT birth_date,
       courier_id,
       sex
FROM   couriers
WHERE  birth_date is null
ORDER BY courier_id
----

***

Задание:

Определите id и даты рождения 50 самых молодых пользователей мужского пола из таблицы users. Не учитывайте тех пользователей, у которых не указана дата рождения.
Поле в результирующей таблице: user_id, birth_date
--
SELECT user_id, birth_date
FROM users
WHERE sex = 'male' AND birth_date IS NOT NULL
ORDER BY birth_date DESC
LIMIT 50;
----
+
--
SELECT user_id,
       birth_date
FROM   users
WHERE  sex = 'male'
   and birth_date is not null
ORDER BY birth_date desc limit 50
----

***

Задание:

Напишите SQL-запрос к таблице courier_actions, чтобы узнать id и время доставки последних 10 заказов, доставленных курьером с id 100.
Поля в результирующей таблице: order_id, time
Пояснение:
Обратите внимание, что в исходной таблице есть записи не только со временем доставки, но и временем принятия заказа.
--
SELECT order_id, time
FROM courier_actions
WHERE action = 'deliver_order' AND courier_id = 100
ORDER BY time DESC
LIMIT 10;
----
+
--
SELECT order_id,
       time
FROM   courier_actions
WHERE  courier_id = 100
   and action = 'deliver_order'
ORDER BY time desc limit 10
----

***

Задание:
Из таблицы user_actions получите id всех заказов, сделанных пользователями сервиса в августе 2022 года.
Результат отсортируйте по возрастанию id заказа.
Поле в результирующей таблице: order_id
Пояснение:
Обратите внимание, что в исходной таблице есть записи не только со временем оформления, но и временем отмены заказа.
В этой задаче вам может пригодиться функция DATE_PART
--
SELECT order_id
FROM user_actions
WHERE action = 'create_order' 
    AND DATE_PART('month', time) = 8 
	AND DATE_PART('year', time) = 2022
ORDER BY order_id ASC;
----
+
--
SELECT order_id
FROM   user_actions
WHERE  action = 'create_order'
   and date_part('month', time) = 8
   and date_part('year', time) = 2022
ORDER BY order_id
----

***

Задание:

Из таблицы couriers отберите id всех курьеров, родившихся в период с 1990 по 1995 год включительно.
Результат отсортируйте по возрастанию id курьера.
Поле в результирующей таблице: courier_id
Пояснение:
В этой задаче вам снова может пригодиться функция DATE_PART
--
SELECT courier_id
FROM couriers
WHERE DATE_PART('year', birth_date) >= 1990 
    AND DATE_PART('year', birth_date) <= 1995
ORDER BY courier_id ASC;
----
+
--
SELECT courier_id
FROM   couriers
WHERE  date_part('year', birth_date) between 1990
   and 1995
ORDER BY courier_id
----

***

Задание:

Из таблицы user_actions получите информацию о всех отменах заказов, которые пользователи совершали в течение августа 2022 года по средам с 12:00 до 15:59.
Результат отсортируйте по убыванию id отменённых заказов.
Поля в результирующей таблице: user_id, order_id, action, time
Пояснение:
Будьте внимательны при работе с датами и временем.
Для решения задачи вам может пригодиться функция DATE_PART. Для получения дня недели можно указать аргумент 'dow' («day of week»):
--
SELECT DATE_PART('dow', DATE '2022-12-31')

Результат:
6.00
----
В PostgreSQL дни недели считаются с воскресенья (0) до субботы (6)
--
SELECT user_id, order_id, action, time
FROM user_actions
WHERE action = 'cancel_order'
   and date_part('month', time) = 8
   and date_part('year', time) = 2022
   and date_part('dow', time) = 3
   and DATE_PART('hour', time) BETWEEN 12 AND 15
   and DATE_PART('minute', time) BETWEEN 00 AND 59
ORDER BY order_id DESC;
----
+
--
SELECT user_id,
       order_id,
       action,
       time
FROM   user_actions
WHERE  action = 'cancel_order'
   and date_part ('dow', time) = 3
   and date_part ('month' , time) = 8
   and date_part('hour', time) between 12
   and 15
   and date_part('year', time) = 2022
ORDER BY order_id desc
----

В прошлом уроке мы решили задачу для одного из менеджеров и посчитали НДС каждого товара. Вы долго смотрели на получившиеся расчёты и вас всё-таки замучила совесть: вы ведь точно знаете, что на отдельные группы товаров НДС составляет не 20%, а 10%.

Поскольку менеджер внезапно перестал отвечать на ваши сообщения, вы решили написать напрямую бухгалтеру и запросили список товаров, на которые распространяется НДС 10%.

Вот какой список вы получили:
--
'сахар', 'сухарики', 'сушки', 'семечки', 
'масло льняное', 'виноград', 'масло оливковое', 
'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 
'овсянка', 'макароны', 'баранина', 'апельсины', 
'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 
'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 
'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 
'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 
'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины'
----

Задание:
Как и в задаче из прошлого урока, вычислите НДС каждого товара в таблице products и рассчитайте цену без учёта НДС. Однако теперь примите во внимание, что для товаров из списка налог составляет 10%. Для остальных товаров НДС тот же — 20%.
Выведите всю информацию о товарах, включая сумму налога и цену без его учёта. Колонки с суммой налога и ценой без НДС назовите соответственно tax и price_before_tax. Округлите значения в этих колонках до двух знаков после запятой.
Результат отсортируйте сначала по убыванию цены товара без учёта НДС, затем по возрастанию id товара.
Поля в результирующей таблице: product_id, name, price, tax, price_before_tax
Пояснение:
Порядок расчёта налога тот же, что и в задании из прошлого урока.
Для решения задачи вам могут пригодиться конструкция CASE и оператор IN. Конструкцию CASE мы рассматривали в этом задании.
--
SELECT product_id, 
    name, 
    price, 
    CASE 
    WHEN name in ('сахар', 'сухарики', 'сушки', 'семечки', 
'масло льняное', 'виноград', 'масло оливковое', 
'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 
'овсянка', 'макароны', 'баранина', 'апельсины', 
'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 
'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 
'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 
'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 
'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN ROUND(price/110*10, 2) 
    ELSE ROUND(price/120*20, 2)
    END as tax, 
    CASE 
    WHEN name in ('сахар', 'сухарики', 'сушки', 'семечки', 
'масло льняное', 'виноград', 'масло оливковое', 
'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 
'овсянка', 'макароны', 'баранина', 'апельсины', 
'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 
'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 
'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 
'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 
'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') THEN ROUND(price - (price/110*10), 2) 
    ELSE ROUND(price - (price/120*20), 2)
    END as price_before_tax
FROM products
ORDER BY price_before_tax DESC, product_id ASC;
----
+
--
SELECT product_id,
       name,
       price,
       case when name in ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') then round(price/110*10, 2)
            else round(price/120*20, 2) end as tax,
       case when name in ('сахар', 'сухарики', 'сушки', 'семечки', 'масло льняное', 'виноград', 'масло оливковое', 'арбуз', 'батон', 'йогурт', 'сливки', 'гречка', 'овсянка', 'макароны', 'баранина', 'апельсины', 'бублики', 'хлеб', 'горох', 'сметана', 'рыба копченая', 'мука', 'шпроты', 'сосиски', 'свинина', 'рис', 'масло кунжутное', 'сгущенка', 'ананас', 'говядина', 'соль', 'рыба вяленая', 'масло подсолнечное', 'яблоки', 'груши', 'лепешка', 'молоко', 'курица', 'лаваш', 'вафли', 'мандарины') then round(price - price/110*10, 2)
            else round(price - price/120*20, 2) end as price_before_tax
FROM   products
ORDER BY price_before_tax desc, product_id
----

В этом уроке мы:

Научились фильтровать данные и применять логические выражения в блоке WHERE.

Выяснили, что фильтрацию можно делать сразу по расчётным полям с применением функций к колонкам.

Разобрались, как задавать шаблоны для текстовых значений с помощью оператора LIKE.

Познакомились с операторами IN и BETWEEN.

Узнали ещё больше о NULL значениях и научились отфильтровывать их с помощью IS NULL.

Поработали с датами и временем и научились задавать диапазоны значений.

Совместили новые знания с информацией из прошлого урока и решили большую задачу на CASE.

Известные нам на текущий момент ключевые слова и порядок их написания в запросе:
--
SELECT     -- перечисление полей результирующей таблицы
FROM       -- указание источника данных
WHERE      -- фильтрация данных
ORDER BY   -- сортировка результирующей таблицы
LIMIT      -- ограничение количества выводимых записей
----

Лекция 5. Агрегация данных

Агрегация - это такая процедура, которая получает на вход много данных и схлопывает их в одно число 

--
SELECT COUNT(product_id)
FROM products 
----
87
------

COUNT - считает количество 

DISTINCT - считает количество уникальных значений

MAX - максимальное значение 

MIN - минимальное значение 

SUM - сумма 

AVG - среднее 

ANY - возвращает случайное значение
 
Мы познакомились с ключевым словом DISTINCT. Перед тем как переходить к задачам на агрегацию, давайте сперва разберёмся, как его использовать.

Ключевое слово DISTINCT позволяет отбирать уникальные записи, т.е. избавляться от всех дубликатов в таблице.

Указывается DISTINCT сразу после SELECT. Для вывода уникальных значений в одной колонке можно составить следующий запрос - 
--
SELECT DISTINCT column
FROM table
----

***

Задание:

Выведите id всех уникальных пользователей из таблицы user_actions. Результат отсортируйте по возрастанию id.
Поле в результирующей таблице: user_id
--
SELECT DISTINCT user_id
FROM user_actions
ORDER BY user_id;
----

Ключевое слово DISTINCT можно применять не только к одной колонке, но и сразу к нескольким.
Например, запрос для двух колонок будет выглядеть так -
--
SELECT DISTINCT column_1, column_2
FROM table
----
- в таком случае в качестве результата запрос вернёт уникальные комбинации значений в колонках

Подробнее про ключевое слово DISTINCT можно почитать здесь -
https://www.postgresqltutorial.com/postgresql-tutorial/postgresql-select-distinct/

***

Задание:

Примените DISTINCT сразу к двум колонкам таблицы courier_actions и отберите уникальные пары значений courier_id и order_id.
Результат отсортируйте сначала по возрастанию id курьера, затем по возрастанию id заказа.
Поля в результирующей таблице: courier_id, order_id
--
SELECT DISTINCT courier_id, order_id
FROM courier_actions
ORDER BY courier_id, order_id;
----

Агрегирующими функциями называют функции, которые обрабатывают определённый набор строк и возвращают одно обобщающее значение. Если вы когда-нибудь работали в Excel, то наверняка сталкивались с подсчётом суммы или максимального/минимального значения по столбцу — речь идёт именно об этом.

Вот несколько примеров таких функций в SQL:
COUNT — считает количество значений в колонке.
SUM — вычисляет сумму значений.
AVG — вычисляет среднее значение.
MAX — вычисляет максимальное значение.
MIN — вычисляет минимальное значение.

Примеры -
--
SELECT COUNT(column) AS count
FROM table


SELECT SUM(column_1) AS sum,
       AVG(column_2) AS average
FROM table
----

Обратите внимание, что некоторые из вышеуказанных функций нельзя применять к колонкам с текстом, датами и временем, поскольку не вполне понятно, что, например, означает найти среднее значение или сумму наименований товаров.

В то же время «максимальное» наименование товара вычислить можно — функция MAX будет искать наибольшее значение в упорядоченной последовательности (в соответствии с установленными правилами сортировки значений строкового типа).

Впрочем, заучивать границы применимости этих функций не нужно — просто руководствуйтесь здравым смыслом.

Подробнее с агрегирующими функциями можно ознакомиться здесь -
https://www.postgresqltutorial.com/postgresql-aggregate-functions/

В документации PostgreSQL есть и более специфические функции -
https://www.postgresql.org/docs/9.5/functions-aggregate.html
но списка выше на первое время нам точно хватит.

***

Задание:

Посчитайте максимальную и минимальную цены товаров в таблице products. Поля назовите соответственно max_price, min_price.
Поля в результирующей таблице: max_price, min_price
Пояснение:
В одном запросе можно использовать сразу несколько агрегирующих функций — если необходимо, то даже по нескольким разным колонкам.
--
SELECT MAX(price) AS max_price, 
       MIN(price) AS min_price
FROM products;
----

Также при подсчёте количества записей иногда вместо наименования колонки в качестве атрибута функции COUNT используют звёздочку «*» -
--
SELECT COUNT(*)
FROM table
----
- важно учитывать один нюанс: запрос со звёздочкой возвращает количество вообще всех записей в таблице, а запрос с указанием столбца — количество тех записей, где в заданном столбце значения не являются NULL.
Таким образом, если в некоторой колонке column есть пропуски, выражения COUNT(*) и COUNT(column) вернут разные значения.

***

Задание:

Как вы помните, в таблице users у некоторых пользователей не были указаны их даты рождения.
Посчитайте в одном запросе количество всех записей в таблице и количество только тех записей, для которых в колонке birth_date указана дата рождения.
Колонку с общим числом записей назовите dates, а колонку с записями без пропусков — dates_not_null.
Поля в результирующей таблице: dates, dates_not_null
--
SELECT COUNT(*) AS dates, 
       COUNT(birth_date) AS dates_not_null
FROM users;
----

Агрегирующие функции можно применять в сочетании с ключевым словом DISTINCT. В таком случае расчёты будут производиться только по уникальным значениям.
Если в случае с MIN и MAX это не имеет особого смысла, то при расчёте AVG, SUM и COUNT иногда это бывает полезно -
--
SELECT SUM(DISTINCT column) AS sum_distinct
FROM table
----

При этом довольно часто DISTINCT используется именно в сочетании с COUNT — для подсчёта числа уникальных пользователей, уникальных заказов и т.д. -
--
SELECT COUNT(DISTINCT column) AS count_distinct
FROM table
----

***

Задача:

Посчитайте количество всех значений в колонке user_id в таблице user_actions, а также количество уникальных значений в этой колонке (т.е. количество уникальных пользователей сервиса).
Колонку с первым полученным значением назовите users, а колонку со вторым — unique_users.
Поля в результирующей таблице: users, unique_users
--
SELECT COUNT(user_id) AS users, 
       COUNT(DISTINCT user_id) AS unique_users
FROM user_actions;
----

Если для расчётов нам нужны не все данные в столбце, а только какая-то часть? Тогда в запрос с агрегирующими функциями можно включить оператор WHERE, указав условие для отбора записей -
--
SELECT COUNT(column_1) AS count
FROM table
WHERE column_2 > 100
----

В таком случае сначала будет выполнена фильтрация таблицы и только потом будет произведена агрегация по оставшимся записям.

На всякий случай напомним порядок выполнения в запросе известных нам ключевых операторов:

FROM       -- выбор источника данных

WHERE      -- фильтрация данных

SELECT     -- перечисление полей результирующей таблицы и проведение расчётов

ORDER BY   -- сортировка результирующей таблицы

LIMIT      -- ограничение количества выводимых записей

***

Задание:

Посчитайте количество курьеров женского пола в таблице couriers. Полученный столбец с одним значением назовите couriers.
Поле в результирующей таблице: couriers
--
SELECT COUNT(courier_id) AS couriers
FROM couriers
WHERE sex = 'female';
----

7




























++++++++++++++++++++++++++++++++++++++

Звонок с HR -
https://youtube.com/watch?v=JWfZK8GMnWw&si=62oAZNEikkMafK78

рассказ о себе - 
- где работал (работал там то, делал то то)
- с кем (кто был с тобой в команде)
- что делал (какие задачи выполнял)
- актуальный опыт 
- какая возникла проблема и как ты её исправлял 
- что ты можешь дать компании (какие задачи можешь решить сходу, какие есть фреймворки и наработки)

оффер другой - есть всегда 

успеем ли мы за неделю (до конкретного числа) пройти все этапы собеседования, мне нужно дать ответ по другому офферу (на 7-10 дней позже этого звонка)

почему ты не принял этот оффер -
компания хорошая, предлагают сумму которую я хочу, но нельзя брать первое попавшееся предложение, я хочу выбрать из нескольких предложений, вы же тоже смотрите несколько кандидатов и выбираете лучшего, и у меня та же мотивация 

компании всегда ставят сами в оффере срок ответа - 7 дней 

вопрос - когда готовы выйти к нам
твой ответ - через 2 недели после принятия оффера 

вопрос - вы где находитесь?
ответ - в Москве 

вопрос - почему задумались о смене работы?
ответ (не завиясщие от тебя обстоятельства) - 
- сменилось руководство, команда
- сокращение команды 
- финансирование проекта сокращается
- работодатель закрывает(продаёт) бизнес и эмигрирует
- проект закончился

если спросят сколько сейчас получаешь - 
никогда не говори что меньше заявленной тобой суммы 

сразу спрашивать какая вилка на позицию 

какой формат работы - офис, гибрид, удаленка 

твои вопросы - 
- процессы
- задачи 
- цели 
- вакансия открыта на расширение или на замену 
- какая вилка на позицию 
- сколько планируется этапов собесов (если больше 2 - на х....)
- что будет дальше 
- кто будет в моей команде 

но будет 10-20 отказов на собесах 

будет тильт....

++++++++++++++++++++++++++++++++++++++
















































