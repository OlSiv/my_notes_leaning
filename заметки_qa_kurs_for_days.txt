
Ещё больше курсов бесплатно вы можете скачать в тг @FreeZnanija
https://t.me/+7AtkDPv9XiwxYWU6



honor - диск D:/ - QA - QA курс по дням

Telegram - избранное - 03.08.2025 

8 уроков + 5 уроков 



******************************************

- 1 - 1 - Введение

тестирование ПО для начинающих 

цель - устроится на работу тестировщиком 

только самая необходимая информация 

практическая часть 



******************************************

- 1 - 2 - Что такое тестирование

Тестирование - это проверка соответствия реальных и ожидаемых результатов поведения программы, а также это одна из техник контроля качества, которая включает -
- планирование работ
- проектирование тестов 
- выполнение тестирования 
- анализ полученных данных 

источник ожидаемого результата - это требования (спецификация), и здравый смысл в условиях отсутствия требований 

требования (спецификация) - это детальное описание того, как должно работать программное обеспечение 

составлением спецификаций занимаются системные аналитики и бизнес-аналитики, бизнес-аналитики собирают требования с бизнеса а системные аналитики переводят их на технический язык 

баг - это отклонение фактического результата от ожидаемого 

условия жизни бага -
1 - известен фактический результат 
2 - известен ожидаемый результат 
3 - первое не равно второму (фактический результат не равен ожидаемому) 

цель тестирования - 
- найти баги до того, как их найдут пользователи 
- проверка соответствия ПО предъявленным требованиям 

самое главное в тестировании - это счастье клиента (пользователя), удовлетворение его качеством продукта 

QA - это обеспечение качества 

качество - это результат работы всех участников разработки ПО, результат отлаженности и настроек самого процесса 



******************************************

- 1 - 3 - виды тестирования 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

1 - по запуску кода на исполнение -

- статическое - без запуска кода, тестирование требований, code review (анализ програмного кода)

- динамическое - проводится при помощи запуска продукта, например юнит-тестирование 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

2 - по знанию внутренностей системы (по доступу к коду и архитектуре приложения) - 

- черный ящик - тестировщик не знает, как устроен виртуальный мост, соединяющий фактически ввод и фактический вывод. Идеи тестирования идут от предполагаемых паттернов поведения пользователей. Также черный ящик называют поведенческим подходом. Другими словами это тестирование без учета внутренней структуры кода и без доступа к базе данных. 

- белый ящик - при таком подходе тестировщик основывает идеи для тестирования на знании об устройстве и логике тестируемой части бэкенда. Написание тестов, используя программный код. К примеру можно отнести юнит-тестирование, которое как правило проводят разработчики. 

- серый ящик - сочетает элементы черного и белого ящика. Подразумевает частичный доступ, например к структуре базы данных.

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

3 - по объекту (цели) тестирования - 

I - функциональное тестирование - проверяет, правильно ли выполняет ПО функции, описанные в требованиях, а также как выполняется взаимодействие с другими системами. К этому виду тестирования относятся -
- модульное
- интеграционное 
- системное тестирование 

- тестирование безопасности - это множество вещей, суть которых - усложнить условия для кражи данных, денег, информации 

- тестирование взаимодействия - проверка взаимодействия ПО с различными внешними компонентами и системами, например, можно ли использовать сервис авторизации "Google" для регистрации на сторонних сайтах. 



II - нефункциональное тестирование - описывает тесты, необходимые для определения характеристик программного обеспечения, которые могут быть измерены разными величинами - то есть это тестирование того, как работает система (не что работает, а как работает) -
- нагрузочное тестирование 
- стресс-тестирование
- тестирование стабильности и надежности
- юзабилити-тестирование 

- нагрузочное тестирование - измерение того, как быстро работает ПО под заданной нагрузкой, например при тестировании производительности анализируют изменение времени отклика ПО при определенном количестве пользователей (100, 200, 500, 1000 и больше)

- стресс-тестирование - позволяет проверить, насколько приложение и система в целом работоспособны в условиях стресса. Оценивается и способность к регенерации, то есть возвращению к нормальному состоянию после стресса (повышения интенсивности выполнения до очень высоких значений)

- тестирование стабильности и надежности - проверка работоспособности приложения при длительном (многочасовом) тестировании со средним уровнем нагрузки. Время выполнения операций может играть второстепенную роль. Тут на первый план выходит отсутствие утечек памяти, перезапусков 

- юзабилити-тестирование - оценка ПО с точки зрения удобства использования, изучения и освоения, понятности и привлекательности для пользователей в контексте заданных условий 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

4 - связанное с изменениями в коде - после внесения изменений (исправление бага/дефекта) ПО должно быть протестировано заново, чтобы подтвердить что проблема действительно решена 

виды тестирования, которые необходимо проводить после установки ПО - 

- дымовое тестирование - проверка основного функционала с целью убедится, что дальнейшее тестирование возможно 

- регрессионное тестирование - вид тестирования, направленный на проверку изменений, сделанных в приложении или окружающей среде (починка дефекта, слияние кода, миграция на другую операционную систему, базу данных, сервер или веб-сервер)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

5 - по степени автоматизации - 

- ручное тестирование - выполнение тест-кейсов без помощи каких-либо программ, автоматизирующих работу 

- автоматизированное тестирование - отдельная дисциплина, используются программные средства для выполнения тестов и проверки результатов. Автотесты позволяют сократить время тестирования и упростить сам процесс, но автоматизация - это не просто, все тесты автоматизировать не нужно 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

6 - по степени изолированности тестируемых компонентов - 

- компонентное (модульное) тестирование - это тестирование на уровне логического компонента. Модульное тестирование проверяет функциональность и ищет дефекты в частях приложения, которые доступны и могут быть протестированы по отдельности (модули программ, объекты, классы, функции). Обычно модульное тестирование выполняют разработчики, создавая и программируя специальные модульные тесты (юнит-тесты) при разработке модуля программы.

- интеграционное - это тестирование на уровне 2-х и более компонентов, то есть тестируется взаимодействие этих программ или систем 

- системное тестирование - проверка всей системы от начала и до конца 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

7 - по степени важности тестируемых функций - 

- дымовое тестирование - это минимальный набор тестов на явные ошибки, его успешное прохождение говорит о том, что ПО можно тестировать более глубоко и основательно. Если ПО не прошло smoke-тестирование - то проверять его дальше смысла нет 

- тестирование критического пути - это проверка функциональности которая используется пользователем повседневно, то есть наиболее часто используемые функции ПО 

- расширенное тестирование - направлено на исследование всей заявленной в требованиях функциональности, даже той, которая низко проранжирована по степени важности. При этом здесь также учитывается какая функциональности является более важной, а какая менее важной 

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

8 - по критерию позитивности сценариев - 

- позитивное тестирование - проверяются функции ПО строго по требованиям и инструкциям, только с допустимыми действиями и корректными данными 

- негативное тестирование - проверка поведения ПО при вводе некорректных данных, рассматривается то, что не предусмотренно требованиями или типом данных 



схема по видам тестирования - Telegram - Избранное - 07-08-2025 



что спрашивают - 

- что такое функциональное и нефункциональное тестирование, чем они отличаются 

- позитивное и негативное тестирование

- дымовое тестирование 

- регрессионное тестирование и когда оно проводится 

- ручное и автоматизированное 

- черный ящик, белый ящик, серый ящик 



******************************************

- 1 - 4 - тестирование карандаша 

на собеседовании часто могут попросить протестировать какой-либо посторонний предмет, например карандаш, но уловив суть, вы сможете протестировать любой бытовой предмет 

суть - 

1 - попросить требования на карандаш (цвет, твердость, форма)

2 - начинать следует с позитивных тестов -
- убедится что карандаш можно заточить 
- что им можно писать с заявленной твердостью 
- стирает ли резинка написанное (если она есть)

3 - негативные тесты -
- будет ли писать карандаш на мокрой бумаге 
- будет ли писать на стене 

4 - юзабилити-тестирование - 
- удобно ли держать в руке 
- удобно ли держать за ухом
- не скатывается ли со стола 

5 - нагрузочное тестирование -
- надавить на карандаш с силой и писать им, но так чтобы он не сломался, делать так некоторое время и посмотреть что будет с карандашом 

6 - стресс-тестирование - с силой ударить карандашом об стол, и посмотреть выдержал ли грифель удар 



******************************************

- 1 - 5 - цикл разработки ПО -

цикл разработки ПО - это путь от идеи до поддержки готового продукта 

идея ->
дизайн и документация ->
кодирование ->
тестирование и ремонт ->
релиз и поддержка

идея - это описание цели (обычно этим занимаются маркетологи)

дизайн - это описание пути к достижению цели, на этом этапе разрабатываются требования и целевой дизайн - то есть как продукт должен выглядеть, разработкой требований и спецификаций занимаются аналитики 

кодирование - этап разработки ПО, задействованы программисты 

тестирование и ремонт - этап начала тестирования (чем раньше - тем лучше) может начинаться одновременно с разработкой требований, так как часто практикуется тестирование требований и документации, тут задействоваются тестировщики, продукт менеджеры. Тестировщики проводят тест приемки (smoke test) в процессе которого проверяются основные функциональности 
Пример - если мы не можем зайти в аккаунт нашего сайта (www.main.shop.com) то о дальнейшем тестировании пока нельзя говорить, а если тест приемки пройден, то код замораживается и тестировщики начинают тестирование новых компонентов (новой функциональности)
После того, как новые функциональности протестированы, наступает очередь исполнения старых "тест-кейсов" и этот процесс называется регрессивным тестированием и проводится для того, чтобы удостоверится что компоненты ПО, которые работали раньше, не сломались и всё ещё работают
Баги заносятся в систему трекинга багов (обычно Jira, но может быть и другая), программисты ремонтируют баги, и тестировщики проверяют, насколько качественным был ремонт 

релиз - выпуск продукта для реальных пользователей, за релиз обычно отвечает релиз-менеджер 

поддержка



******************************************

- 1 - 6 - Методологии разработки -

Методология разработки ПО - это система принципов и совокупности идей, понятий, методов, способов, средств, определяющих стиль разрамотки ПО 

Наиболее популярные модели разработки ПО - 



1 - каскадная модель (модель "водопад", waterfall model) - одна из самых старых, упомитнается с 1970 года, модель разбивает жизненный цикл ПО на стадии:
- проектирование 
- дизайн
- кодирование 
- тестирование 
- поддержка 
Каждая стадия должна завершиться до начала следующей

Эта модель используется в банках и корпорация с госучастием 



2 - agile-подходы (гибкая методология разработки) - это семейство "гибких" подходов к разработке ПО. Такие подходы также иногда называются фреймворками или agile-методами. В гибкой методологии разработки после каждой итерации заказчик может наблюдать результат и понимать, удовлетворяет он его или нет, это одно из преимуществ этой методологии, а к недостаткам относится то, что из-за отсутствия конкретных формулировок результатов сложно оценить трудозатратность и стоимость разработки.

В основе гибкой методологии лежат непродолжительные отрезки времени (sprint-ы), во время которых выполняется определенный (ограниченный) список задач, ежедневные встречи (stand-up meeting) и регулярные собрания (планирование спринта, итоги спринта)

На ежедневных совещаниях участники команды обсуждают: 
- отчет о проделанной работе с момента последнего stand-up meeting
- список задач, которые сотрудник должен выполнить до следующего задания 
- затруднения, возникающие в ходе работы 

Методология подходит для больших и нацеленных на длительный жизненный цикл проектов, постоянно адаптируемых к условиям рынка, соответственно в процессе реализации требования изменяются 

Спринты обычно идут одну или две недели 



Сравнительный анализ моделей разработки "agile" и "водопад" (различия) - 

- в методологии разработки "водопад" четко и заранее определены требования, а в "agile" требования в процессе реализации меняются 

- в "agile" плавающее значение стоимости продукта, а в "водопаде" фиксированная стоимость 

- в "agile" готовность к изменениям в процессе разработки важнее, чем бесприкословное следование изначальному плану, в отличии от методологии "водопад"

- в "agile" разработка через короткие итерации, а в "водопаде" - длительная разработка 

- в "agile" заказчик привлекается к процессу разработки продукта, а в "водопаде" - нет 

- приоритет в "agile" - удовлетворение потребностей заказчика, а в "водопаде" - жесткая последовательность этапов разработки 



В современных компаниях в 95% используется в "agile"



******************************************

- 1 - 7 - Аксиомы тестирования -

Аксиомы тестирования - это истины, не требующие доказательств -

1 - тестирование не доказывает отсутствие ошибок - тестирование помогает выявить наличие и характер дефектов, но успешное завершение всех тестов не говорит о том, что дефектов на 100% нет 

2 - исчерпывающее тестирование невозможно - между "не тестировать ничего" и "протестировать всё" располагается множество других вариантов, полное тестирование всего невозможно, тут нужно искать компромис и выдать результат, отвечающий требованиям заказчика 

3 - раннее тестирование - чем раньше обнаружен дефект, тем быстрее, проще и дешевле его исправить 

4 - скопление дефектов - часто бывает что дефекты "кучкуются" по коду неравномерно, в этом случае данная часть кода сложна и запутанна или внесенные изменения вызывают эффект "домино", и тогда при планировании тестов тестировщик фиксируется на "проблемных зонах". О том где "кучкуются" дефекты можно узнать ещё на ранних этапах разработки, во время статического тестирования (code review, анализ кода с помощью специальных инструментов). Когда дело дойдет до динамического тестирования, то нужно сконцентрироваться на тех областях, где статическими методами было обнаружено больше дефектов. 

5 - парадокс пестицидов - если повторять одни и те же тесты снова и снова, в определенный момент этот набор тестов перестанет выявлять дефекты, то есть скопления дефектов, упомянутых в аксиоме 4, имеют тенденцию перемещаться. Это аналагично обработке полей с насекомыми пестицидом, те насекомые, которые не погибли после первой обработки, в большинстве своём выживают и после второй. 
Повторное применение одних и тех же тестов и методик приводит к тому, что остаются именно те дефекты, против которых эти тесты и методики неэффективны, чтобы преодолеть "парадокс пестицидов" необходимо регулярно пересматривать существующие тест-кейсы и создавать новые разнообразные тесты, которые будут выполнятся на различных частях системы. 

6 - тестирование зависит от контекста - разные системы связаны с различными уровнями риска, влияние того или иного дефекта также сильно варьируется, одни проблемы довольно тривиальны, другие могут дорого обойтись и привести к большим потерям времени и денег. При этом проблема (риск), связанная со значительным ущербом, может иметь незначительную вероятность, и наоборот, риск с небольшим ущербом может иметь достаточно большую вероятность. Уровень риска влияет на выбор методологий, техник и типов тестирования. 

7 - если построенная система неудобна для использования пользователями и не соответствует их ожиданиям и нуждам, нахождение и исправление дефектов в ней бесполезно. Заказчикам ПО совершенно неинтересно наличие дефектов и их количество, кроме тех случаев, когда они сталкиваются со сбоями продукта, и их не интересуют задокументированные формальные требования, пользователям ПО необходимо чтобы их задачи решались, они оценивают ПО с точки зрения соответствия их потребностям. 



******************************************

- 1 - 8 - Что такое API -

Через API системы взаимодействуют между собой, система внутри себя тоже общается по API 

API (application programming interface) - это контракт, который предоставляет программа - "ко мне можно обращаться так и так, я оюязуюсь делать то и это"

API отвечает на вопрос - "как ко мне, к моей системе можно обратиться?" и включает в себя - 
- саму операцию, которую мы можем выполнить 
- данные, которые поступают на вход
- данные, которые оказываются на выходе (контент данных или сообщение об ошибке)

Как вызывается API -

I - напрямую - 
1 - система вызывает функции внутри себя
2 - система вызывает методы другой системы 
3 - человек вызывает метод
4 - автотесты дергают методы 

II - косвенно -
5 - пользователь работает с GUI (графический интерфейс)

1 - система вызывает функции внутри себя - разные части программы общаются между собой, они делают это на программном уровне (то есть на уровне API), это самый простой в использовании способ, потому что автор API которое вызывается - разработчик. И он же его потребитель. 

2 -система вызывает метод другой системы - это типичный кейс, которые тестируют тестировщики в интеграторах, или тестировщики, проверяющие интеграцию своей системы с чужой. Одна система дергает через API какой-то метод другой системы, она может попытаться получить данные из другой системы, либо наоборот отправить данные в эту систему. 

К примеру  я решил подключить подсказки из ДАДАТЫ к своему интернет-магазину, чтобы пользователь легко ввел адрес доставки, и я подключаю подсказки через API, и теперь когда пользователь начинает вводить адрес на моём сайте, он видит подсказки из ДАДАТЫ. Как это получается - он вводит букву на моём сайте, мой сайт отправляет запрос в подсказки ДАДАТЫ по API и ДАДАТА возвращает ответ, мой сайт его обрабатывает и отображает результаты пользователю. И так на каждый введенный символ. 

3 - человек вызывает метод - причины разные - 
- для ускорения работы 
- для локализации бага (проблемы где? на сервере или на клиенте?)
- для проверки логики без докруток фронта

4 -  автотесты дергают методы - если система предоставляет API, обычно проще дернуть его, чем делать это через графический интерфейс, тем более что вызов API можно сохранить в инструменте, один раз сохранил - на любой базе применяешь, даже если она 10 раз в день чистится 

Для примера возьмем страницу регистрации нового пользователя, где нужно заполнить кучу полей (далее показывает в видео) - заполнять поля вручную долго и муторно, тем более если это нужно делать часто на чистой тестовой базе, сразу возникает необходимость это автоматизировать. В этом случае роль автоматизатора выполняет Postman. Пользователя можно создать через REST-запрос CreateUser. Один раз прописали нормальные данные (которые по содержанию как настоящие) и каждый раз пользуемся. Вместо долгого ручного заполнения формы нажимаем кнопку "Send" и делаем всё за 1 секунду. 

5 - пользователь работает с GUI (графический интерфейс) - на самом деле пользователь с помощью графического интерфейса тоже работает с API, но в этом случае ему не важно как работает система и что там внутри, он просто нажимает на кнопку "загрузить отчет", и функция построения отчета уже может вызвать 10 разных других функций, если это необходимо, а пользователь видит перед собой уже готовый отчет, таким образом он вызвал сложный API даже не подозревая об этом. 

Что значит "тестирование API" - в первую очередь подразумевается тестирование ЧЕРЕЗ API. "Тестирование API" - общеупотребляемый термин, но технически он некорректен, мы не тестируем API, мы не тестируем GUI (графический интерфейс), а мы тестируем какую-то функциональность через графический или программный интерфейс. Когда мы говорим "тестирование API", то подразумеваем "автотесты на уровне API"

Интеграция - когда одна систем общается с другой по какому-то протоколу передачи данных, это называется Remote API, то есть общение по сети, по некому протоколу (HTTP, JMS и т.д.), в противовес ему есть еще Local API (он же "Shared memory API") - это такой API, по которому программа общается сама с собой или общается с другой программой внутри одной виртуальной памяти. 

Когда мы говорим про тестирование API, чаще всего мы подразумеваем тестирование Remote API, когда у нас есть две системы, находящиеся на разных компьютерах которые как-то между собой общаются. 



******************************************

- 2 - 1 - Разработка чек - листа, тест - кейса, баг - репорта -

чек-лист - таблица - столбцы - 
Список проверок - Статус - Устройство - Среда - Доп. информация (дефекты)

чек-лист говорит что мы будем проверять, но не говорит как мы будем это делать 


00-45



























