https://stepik.org/course/132808/promo

stepik -
sojmoscow@...
a........St

+ его же курс от 2022 - 
Тестирование ПО с нуля до специалиста - 
https://s1.sharewood.co/threads/aleksandr-popov-testirovanie-po-s-nulja-do-specialista-2022.376663
-
в телеграм - 29.08.2022 
и на жд4тб в _QA

************************************

По всем вопросам, просьба писать на aleksandr_stepik@mail.ru

1 - Курс "Тестирование ПО с Нуля до Специалиста" - https://stepik.org/course/116411/
+
https://bw10.skladchik.org/threads/testirovanie-po-s-nulja-do-specialista-stepik-aleks-smit.446376/

2 - Курс "Тестирование: Автоматизация и Программирование на Python.Selenium" - https://stepik.org/course/120491/
+
куплен на stepik

3 -Курс "Тестирование: Автоматизация и Программирование на Python. API" - https://stepik.org/course/127716/
+
куплен на stepik

4 - Курс "Программирование на Python с Нуля + Работа с SQL" - https://stepik.org/course/134773/

5 - Курс "Симулятор собеседования для Тестировщика" - https://stepik.org/course/118983/

6 - Курс "Нагрузочное тестирование ПО с помощью Jmeter" - https://stepik.org/course/122902/

Так же, жду Вас на своем Youtube канале - https://www.youtube.com/channel/UCq-PbXBWej-lxniUkyEmUxw

Телеграмм-канал с новостями и тематическими видео о Тестировании и Мире IT - https://t.me/QaTestingChannel

как выполнять дз если не получается - 
1 - проверить код на ошибки 
2 - прочитать коментарии ниже 
3 - гуглить 
4 - если не помогло - писать в коментариях со скриншотами кода 

Решения необходимо помещать в окне "Решение", если задание требует свободный ответ (текст) или написание кода, то просто помещаете его в данное окно и отправляете, если же необходимы скриншоты, то прикрепляете их в окно. Если не получается прикрепить скриншоты, пишите следующий текст "Отправил/ла решение на почту моя_почта@mail.ru" и отправляете скриншоты на почту aleksandr_stepik@mail.ru. Очень важно отправлять файлы в таком виде, чтоб их не нужно было скачивать, либо ссылка на яндекс(гугл) диск, с открытым доступом, либо скриншоты. Не нужно слать архивы, файлы с баз данных и python, только как в условии. В письме которое вы отправили на почту, обязательно напишите как Вас звать на площадке (на ней сотни Александров, Марий и т.д), так же приложите номер решения задания #78......, Вы увидите его при отправке. 

************************************
2.1
установка python и IDE PyCharm 

python.org 
далее показывает как установить python и PyCharm 
создать проект в PyCharm
создать файл в проекте 

--
print("Hello world!")
----

************************************
2.2
основные типы данных и знакомство с переменными 

для хранения разных типов данных требуется разное количество памяти 

int 
float 
complex
str 
bool
list 
dict 
typle 
set 
None
и т.д. 

переменные - ссылки на ячейки памяти 

название переменной - первый знак - буква или _, а потом можно _, a-z, A-Z

называть так - first_name (с нижним подчеркиванием вместо пробела)

коментировать код - CTRL + / (ENG)

Посмотреть список зарезервированных имен -
--
import keyword

print(keyword.kwlist)
----

ДЗ - ответ -

1 -
int
float
str
bool
list
typle
dict
set 

2 -
int  - 0, -2, 1234
float  - 3.14, -4.56, 9.9999 
str  - 'abc', "Hey hey hey"
bool  - True, False 
list  - [], [1, 2, 'hey, True]
typle  - (1, 2, 3)
dict  - {'name': 'Alex', 'age': 42}
set  - {1, 2, 3, 4, 5}

3 - 
для оптимизации использования памяти 

************************************
2.4
определение типа данных 

--
a = 22
b = 'hey'

print(type(a))
print(type(b))
----
<class 'int'>
<class 'str'>
------

можно использовать функцию isinstance() для проверки, является ли переменная экземпляром определенного класса или одного из его подклассов -
--
if isinstance(x, int):
    print("x - является числом")
else:
    print("x - не является числом")
----

Преобразование типов данных -
--
int(x)    - преобразует x в целое число
float(x)  - преобразует x в число с плавающей точкой
str(x)    - преобразует x в строку
bool(x)   - преобразует x в логическое значение

x = 3.14
y = int(x)
print(y)
----

************************************
2.5
числовые типы данных 

type() - тип
id()   - id
dir()  - все методы класса, к которому принадлежит переменная 

+
-
*
**
/
//
%

<
>
<=
>=
==
!=
not 
True 
False 
round(x)
round(x, 2)
int()
float()
bool()

abs(x)
round(x, y)
max()
min()
sum(iterable, start=0)
sum(iterable, 100) - будет прибавлятся к 100 

int()
float()
str()
bool()

************************************
2.6
строковый тип данных 

<class 'str'>

str1 = 'hello'
print(str1)
print(type(str1))

str2 = 'world'
print(str1 + ' ' + str2)
print(str1, str2)
print(str1 * 3)

преобразование int к str - 
var_1 = 777
print("Result: " + str(var_1))

поменять в PyCharm все аналогичные переменные в коде - 
выделить переменную - Refactor - Rename 

--
st = '   Hello-world   '
st2 = '---Hello-world---'

print(st * 3)
print(st.strip())
print(st.strip('-'))
print(st2.strip('-'))
----
   Hello-world   Hello-world   Hello-world
Hello-world
   Hello-world
Hello-world
------

upper()
title()
dir() -
--
st = 'abc'
print(dir(st))
----
- посмотреть все методы класса (в данном случае - класса str)

срезы (слайсы) - 
string[start:end:step]
Где:
start — индекс, с которого начинается срез (включительно).
end — индекс, на котором срез заканчивается (исключительно).
step — шаг, с которым выбираются элементы.

Если параметры не указаны, используются значения по умолчанию:
start — 0 (начало строки)
end — длина строки
step — 1 (каждый элемент)

st[::-1]

************************************

2.7 - 2.8
продолжаем работать со строковым типом данных 
конструкция f-string

--
str_1 = "hello"
print(dir(str_1))

str_2 = str_1.upper()
print(str_2)

str_3 = str_1.title()
print(str_3)

str_4 = str_2.lower()
print(str_4)
----

--
name = "Ivan"
status = "friend"

a = "Hello {}"
res_1 = a.format(name)
print(res_1)

b = "Hello {} my {}"
res_2 = b.format(name, status)
print(res_2)

c = "Hello {0} my {1} and {0}"
res_3 = c.format(name, status)
print(res_3)
----
Hello Ivan
Hello Ivan my friend
Hello Ivan my friend and Ivan
------

--
first_name = 'Ivan'
last_name = 'Ivanov'
a = '{} {}'
result = a.format(first_name, last_name)
print('Klient name:', result)
----
Klient name: Ivan Ivanov
------

--
first_name = 'Ivan'
last_name = 'Ivanov'
print(f'Klient name: {first_name} {last_name}')
----
Klient name: Ivan Ivanov
------
- в f-строку не обязательно передавать только значения str, можно передавать и int, float, а также осуществлять действия внутри {} - 
--
name = 'Alex'
age = 30
print(f'Я {name} и через 10 лет мне будет {age + 10} лет!')
----
- то есть внутри фигурных скобок {} вы можете использовать любые допустимые выражения Python, включая вызовы функций, математические операции, обращение к атрибутам объектов и т.д.

************************************

2.9
ввод и вывод данных 

input() - по умолчанию принимает в str 

--
var = input('Enter text: ')
print(var)
print(type(var))
----

--
var = int(input('Enter number: '))
print(var)
print(type(var))
----

--
var = float(input('Enter number: '))
print(var)
print(type(var))
----

************************************

2.10
что такое функции и работа с ними 

функция - изолированный именованный блок кода, который можно использовать повторно 

--
def fun_sum(x, y):
	return x + y


print(fun_sum(100, 200))
print(fun_sum('hello', 'world'))
print(fun_sum(y='hello', x='world'))
----
300
helloworld
worldhello
------

--
name = input("Enter you'r name:   ")


def hi(name1, age1):
	return ("Hello " + name1 + " vozrast - " + age1)


res = hi(name, "32")
print(res)
----
Hello Alex vozrast - 32
------

Параметры могут быть как обязательными, так и необязательными (со значениями по умолчанию) -
--
def greet(name, message="Привет"):
     print(f"{message}, {name}!")

greet("Иван")
greet("Мария", "Здравствуйте")
----
Привет, Иван!
Здравствуйте, Мария!
------
- В этом примере функция greet() имеет два параметра: name (обязательный) и message (необязательный, со значением по умолчанию "Привет").  И в зависимости от того, указали ли Мы при ее вызове второй параметр, то значение переменной message и подставится

************************************

2.11
область видимости переменных

глобальные и локальные переменные 

--
var_1 = 10
var_2 = 20
print(var_1, var_2)

def fun_sum():
    res = var_1 + var_2 
    print(res)

fun_sum()
----
10 20
30
------
- тут функция берет глобальные переменные 

--
var_1 = 10
var_2 = 20
print(var_1, var_2)

def fun_sum():
    var_1 = 100
    var_2 = 200
    res = var_1 + var_2 
    print(res)

fun_sum()
----
10 20
300
------
- тут функция берет первыми локальные переменные из своего тела, и эти переменные видит только функция, в теле которой они прописаны 

переменные берутся сначала вложенные а потом глобальные (либо в направлении - от самых вложенных к глобальным - если несколько уровней вложенности)

ДЗ - 

Напишите своими словами (не использовать определения из лекции), что такое область видимости переменных и для чего их разделять? - 

1. Что такое области видимости переменных? - Области видимости переменных - это уровни очередности использования переменных вложенными в код конструкциями(функциями). Вы в обучении давали 2 уровня вложенности. Переменные берутся по принципу - от самых вложенных к менее вложенным. Если в функции есть переменная с именем "x" - то сперва для использования берется она, если в функции переменной "x" нет, то используестся переменная "x" с более высокого уровня(глобальная).

2. Для чего разделять области видимости переменных? - Для оптимизации работы функций и передачи в функции уникальных переменных, то есть в каждую функцию можно установить свою переменную и изначально будет использоваться она, а если в функции переменная не определена, то будет использоваться глобальная переменная.

************************************

2.13
условные операторы - if, else, elif

if - else 
if - elif - elif - ... - else 

--
age = 25 

if age == 25:
    print("age = 25")
elif age > 25:
    print("age > 25")
else:
    print("age < 25")
----

and - И 
or -  ИЛИ 
in -  В (if "A" in "Alex":)

--
pin = 1234
print("Hello!")
user_pin = int(input("Enter pin - 4 digits: "))

if pin == user_pin:
    print("Welcome!")
else:
    print("Code uncorrect!")
----

ограничим количество попыток ввода пин-кода до 3-х -
--
pin = 1234
print("Hello!")
res = 0

for _ in range(3):
    user_pin = int(input("Enter pin - 4 digits: "))

    if pin == user_pin:
        print("Welcome!")
        res = 1
        break
    else:
        print("Code uncorrect!")

if not res:
    print("The end!")
----
- это моё решение  

решение автора - 
--
pin = 1234
print("Введите пароль")
user_pin = int(input())

if pin==user_pin:
    print("Какую сумму вы хотите снять?")
    suma = int(input())
    print("Выдача купюр")
else:
    print("Ошибка ввода данных, введите корректный пин код, осталось 2 попытки")
    user_pin = int(input())
    if pin == user_pin:
        print("Какую сумму вы хотите снять?")
        suma = int(input())
        print("Выдача купюр")
    else:
        print("Ошибка ввода данных, введите корректный пин код, осталась 1 попытка")
        user_pin = int(input())
        if pin == user_pin:
            print("Какую сумму вы хотите снять?")
            suma = int(input())
            print("Выдача купюр")
        else:
            print("Ваша карта заблокирована, обратитесь в отделение банка")
----

************************************

2.14
списки (list)

список - это контейнер, который содержит в себе ссылки на другие объекты, к элементам списка можно обращаться по индексу 

--
personal = ['Alex', 'Ivan', 'Olga', 'Robert']
#            0       1       2       3
print(personal[0])
print(personal[1])
print(personal[2])
print(personal[3])

print(personal[-1])

print(personal[:2])

print(personal[2:])

print(personal[::2])

print(personal[::-1])

personal.append("Fedor")
print(personal)

sp1 = [1, 2, 3]
sp2 = [4, 5, 6]
print(sp1 + sp2)

print(len(personal))
----
Alex
Ivan
Olga
Robert
Robert
['Alex', 'Ivan']
['Olga', 'Robert']
['Alex', 'Olga']
['Robert', 'Olga', 'Ivan', 'Alex']
['Alex', 'Ivan', 'Olga', 'Robert', 'Fedor']
[1, 2, 3, 4, 5, 6]
5
------

--
sp = [1, 2, 3, 'abc']

print(sp * 3)
print('abc' in sp)
print('abc' not in sp)
----
[1, 2, 3, 'abc', 1, 2, 3, 'abc', 1, 2, 3, 'abc']
True
False
------

list.insert(index, element) - вставить в список элемент на нужный индекс, при этом остальные элементы сдвинуться вправо на одну позицию -
--
sp = ['a', 'b', 'c']

sp.insert(1, 'x')
print(sp)
----
['a', 'x', 'b', 'c']
------

remove() - используется для удаления первого вхождения указанного элемента из списка. Если элемент не найден в списке, будет выдаст исключение ValueError.
--
fruits = ['яблоко', 'банан', 'вишня']
if 'банан' in fruits:
    fruits.remove('банан')
print(fruits)
----
['яблоко', 'вишня']
------

sort() используется для сортировки элементов списка в определенном порядке. Он изменяет исходный список, упорядочивая его элементы -
--
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
numbers.sort()
print(numbers)
----
[1, 1, 2, 3, 4, 5, 5, 6, 9]
------

узнаёте индекс значения, которое требуется заменить: 
list(index('объект')) (не забываем print). 
Узнав индекс, меняете значение: 
list[индекс] = 'значение'. 
Если у вас много объектов, то их индексы можно вытянуть через цикл.

************************************

2.15
цикл for 

цикл for в Python используется для последовательного выполнения блока кода для каждого элемента в итерируемом объекте, таком как список, кортеж, строка, диапазон чисел и т.д. Он позволяет легко обрабатывать коллекции данных и выполнять повторяющиеся действия

--
students = ['Alex', 'Ivan', 'Olga', 'Semen', 'Igor', 'Sveta']

for i in students:
    var = 'Injener - ' + i
    print(var)
----
Injener -Alex
Injener -Ivan
Injener -Olga
Injener -Semen
Injener -Igor
Injener -Sveta
------

enumerate() - позволяет одновременно получать индекс и элемент, что делает подсчет итераций более удобным - 
--
fruits = ['яблоко', 'банан', 'вишня']

for i, fruit in enumerate(fruits):
    print(f"Итерация {i}: {fruit}")
----
Итерация 0: яблоко
Итерация 1: банан
Итерация 2: вишня
------

если нужно начать не с 0 а с 1 - 
--
fruits = ['яблоко', 'банан', 'вишня']

for i, fruit in enumerate(fruits, start=1):
    print(f"Итерация {i}: {fruit}")
----
Итерация 1: яблоко
Итерация 2: банан
Итерация 3: вишня
------

************************************

2.16
цикл while 

цикл while выполняет блок кода пока определенное условие остается истинным(True), но важно следить чтобы не сделать цикл бесконечным - 
--
while условие:
    блок кода, который будет выполняться, пока условие истинно
----

--
a = 10

while a > 1:
    print(a)
    a -= 1
----

for - проходит по списку элементов 
while - выполняется пока условие истинно 

************************************

2.17 
операторы break и continue

цикл while работает пока условие равно истине 
--
sp = [1, 4, 6, 10, 12]

for i in sp:
    if i == 4:
	    continue   # - пропускает итерацию
    elif i == 10:
		print('Yo-hooo, 10!!!')
	    break   # - прерывает цикл  
    print(i)
----
1
6
Yo-hooo, 10!!!
------

--
login = input("Enter your login:   ")

while True:
	if login == 'Alex':
		print('Login true!')
		pass = input('Enter password:   ')
		
	else:
		print('Login false!')
		break 
----

************************************

2.19
функция range

range() - используется для создания списка, содержащего арифметическую прогрессию 

старт - стоп - шаг 

--
r1 = range(0, 10, 2)
print(r1)

r2 = list(range(10))
print(r2)

r3 = list(range(0, 10))
print(r3)

r4 = list(range(1, 10))
print(r4)

for i in range(5):
	print(i)
	
print()

# создание последовательности в обратном порядке -
for i in range(4, -1, -1):
	print(i)

# преобразование в лист - 
x = list(range(5))
----
range(0, 10, 2)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9]
0
1
2
3
4

4
3
2
1
0
------

************************************

2.20
работа со словарями и множествами 

--
# list - упорядоченный набор элементов 
family_1 = ['Alex', 'Olga', 'Bob', 'Roy', 'Sam', 'Sam']
print(family_1)

# set - множество - неупорядоченный набор уникальных элементов 
family_2 = {'Alex', 'Olga', 'Bob', 'Roy', 'Sam', 'Sam'}
print(family_2)
----
['Alex', 'Olga', 'Bob', 'Roy', 'Sam', 'Sam']
{'Sam', 'Bob', 'Olga', 'Alex', 'Roy'}
------

--
# dict - словарь (ключ : значение) - неупорядоченный набор пар ключ-значение, где ключи уникальны - 
family_3 = {'name_1':'Sam', 'name_2':'Bob', 'name_3':'Olga', 'name_4':'Alex'}

print(family_3['name_2'])
print()
print(family_3.get('name_2'))
print()

for k, v in family_3.items():
	print(k)
	print(v)
	print(f'{k} - {v}')
	print()
	
# удаление по ключу -	
del family_3['name_3']
print(family_3)
----
Bob

name_1
Sam
name_1 - Sam

name_2
Bob
name_2 - Bob

name_3
Olga
name_3 - Olga

name_4
Alex
name_4 - Alex
------

keys()
values()
items()

# проверять, есть ли среди ключей словаря определенный ключ, который является для нас важным -
--
if "name" in person.keys():
    print("Ключ name присутствует в словаре")
----

#  проверять, есть ли среди значений словаря определенное значение, который является для нас важным -
--
if 30 in person.values():
    print("Значение 30 есть в словаре")
----

values() - возвращает список кортежей 

s = {1, 2, 3}
s2 = set()

s.add(4) - добавить элемент 

s.remove(1) - удаляет элемент 

print(s | s2) - сложит два множества и выведет на печать 

print(s & s2) - пересечение множеств 

print(s ^ s2) - вывод элементов из первого и второго множества, за вычетом дублей

************************************

2.21
работа с файлами 

у кого была проблема с utf-8 (не читался русский текст), то вот решение -
https://dzen.ru/media/sejeenn/kak-nastroit-kodirovku-utf8-v-pycharm-po-umolchaniiu-62b21588c45e2840ecb7c0dc

можем создавать файл 
можем записывать в файл данные 
можем читать данные из файла 
можем изменять данные в файле 
можем закрывать данный файл 

создадим в рабочей дирректории где расположен файл в котором мы пишем код папку - doc 
--
fw = open('doc/file.txt', 'a')
fw.write("Hello world\n")
fw.close()
----
- в папке doc будет создан файл - file.txt, если запустить файл несколько раз, то Hello world будет записано несколько раз 

'a' - запись новых данных в файл и помещение новых данных в конец файла 

'w' - запись новых данных но с удалением старых 

'r' - чтение файла 

--
var = input('Enter text:   ')
fw = open('doc/file.txt', 'a')
fw.write(var + "\n")
fw.close()
----
- этот код будет добавлять строки, которые мы введем в input() 

прочитать содержимое файла - 
--
fr = open('doc/file.txt', 'r')
text = fr.read()
fr.close()

print(text)
----
- выведет содержимое файла 

--
v1 = input()
v2 = input()

fw = open('doc/file.txt', 'a')
fw.write(v1 + "\n")
fw.write(v2)
fw.close()

fr = open('doc/file.txt', 'r')
print(fr.read())
fr.close()
----

Режимы доступа, доступные для open() функции, следующие:

r: Открывает файл в режиме только для чтения. Начинает чтение с начала файла и является режимом по умолчанию для open() функции.

rb: Открывает файл как доступный только для чтения в двоичном формате и начинает чтение с начала файла. Хотя двоичный формат может использоваться для разных целей, он обычно используется при работе с такими вещами, как изображения, видео и т.д.

r+: Открывает файл для чтения и записи, помещая указатель в начало файла.

w: Открывается в режиме только для записи. Указатель помещается в начало файла, и это перезапишет любой существующий файл с тем же именем. Он создаст новый файл, если файл с таким же именем не существует.

wb: Открывает файл, доступный только для записи, в двоичном режиме.

w+: Открывает файл для записи и чтения.

wb+: Открывает файл для записи и чтения в двоичном режиме.

a: Открывает файл для добавления в него новой информации. Указатель размещается в конце файла. Новый файл создается, если файл с таким же именем не существует.

ab: Открывает файл для добавления в двоичном режиме.

a+: Открывает файл как для добавления, так и для чтения.

ab+: Открывает файл как для добавления, так и для чтения в двоичном режиме.

************************************

2.23
конструкция With

при использовании with нет необходимости закрывать файл, система будет это делать автоматически

--
file_name = "file.txt"
data = "Hello world"


# ранее мы делали так - 
fw = open(file_name, 'a')
fw.write(data)
fw.close()


# теперь можно делать так - 
with open(file_name, 'a') as fw:
	fw.write(data)
----
- то есть fw.close() уже прописывать не нужно 


добавление данных в файл - 
--
with open('test.txt', 'a') as file:
    file.write('\nHi, World!')
----


Использование with для работы с файлами имеет несколько преимуществ:

- Автоматическое закрытие файла: После выхода из блока with файл автоматически закрывается, даже если произошло исключение. Это помогает избежать утечек ресурсов и гарантирует, что файл всегда будет корректно закрыт.

- Более чистый и компактный код: Использование with делает код более читабельным и компактным, так как нет необходимости вручную вызывать метод close() для закрытия файла.

************************************

2.24 
Работа с модулями. 1 часть

...






