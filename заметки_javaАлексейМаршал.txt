курс Java Core от Лёши Маршала

плейлист -
https://www.youtube.com/playlist?list=PLZqgWWF4O-zgDLDBMva788aJf_vQ9GKJv

*********

урок_1
java - простой язык
он применим для разных нужд 
недостатки - многословность языка
хорошая поддержка от разработчиков языка
в курсе - синтаксис и как работает язык java
на java можно написать сайт на фреймворке Spring
фреймворк - научится пользоваться 
.java -> .class (байт-код) -> JVM -> в 000 и 111
несколько версий java, популярные - 8 и 11
не забегать вперед при прохождении курса
сначала ничего не будешь понимать но потом поймешь
настроится на работу вдолгую 
нужно будет учится всю профессиональную карьеру

*********

урок_2
установить jdk с сайта oracle
java - высокоуровневый язык 
jvm есть практически для всех платформ и ос
java - объектно-ориентированный язык
jdk лучше устанавливать в - С:/Java 
установить среду разработки - 
https://www.jetbrains.com/idea/download
автор считает что idea лучше чем eclipse
написали первую программу - Hello World

*********

урок_3
бит - байт - килобайт - мегабайт - гигабайт - терабайт
1 байт - это 8 бит
создавая переменную мы резервируем в памяти место в зависимости от типа переменной

8 примитивных типов данных -
byte - 8 бит - от -128 до 127
short - 16 бит - от -32768 до 32767
int - 32 бит - от -2147483648 до 2147483647 - использовать его !!!
long - 64 бита - для очень больших чисел (больше двух миллиардов)
float - 32 бита - 6-7 знаков поле запятой и ставить F после числа
double - 64 бита - использовать его !!!
char - 16 бит - (символьный тип данных, из юникода, в свободном доступе есть таблицы со значениями)
boolean - 1 ,bn - логический тип данных - истина или ложь - true или false

*********

урок_4
можно сначала объявить переменную а уже потом присвоить ей значение -
int x;
x = 42;

можно назначить сразу несколько переменных (но это плохо для читаемости кода и лучше так не делать) -
int a, b, c;

в именах переменных можно использовать английские буквы, цифры, нижнее подчеркивание
имена переменных в java принято писать с маленькой буквы так -
firstNameProject (в верблюжем стиле)
стремится чтобы имя переменной по смыслу совпадало с её значением -
int houseNumber = 5;

область видимости переменных - зависят от расположения переменной в фигурных скобках - область видимости переменной ограничивается фигурными скобками, в которых нахначена переменная

переменную для класса лучше назначать после наименования класса и использовать модификатор static

static - означает что переменная принадлежит этому классу и должна использоваться для этого класса 

если перед именем переменной стоит модификатор static, то из другого класса использовать эту переменную не получится
но если эту переменную нужно использовать из другого класса то можно изменить модификатор с static на public 

константа - это переменная которую впоследствии невозможно изменить -
public final int pi = 3,14;

то есть чтобы создать константу, нужно использовать слово final 

*********

урок_5
математические операции (и логические операторы)

-
public class HelloWorld {
    public static void main(String[] args) {
        int num1 = 3;
        int num2 = 4;

        int result = num1 + num2;

        System.out.println("Rezultat - " + num1 + num2);  
-
- и тут выведет не Rezultat - 7, а - Rezultat - 34 
если в скобках есть String (строка), то и остальные результаты будут не суммироваться, а выводится как строки 

+ сложение
- вычитание
* умножение
/ деление
% остаток от деления

операции - инкремента и декримента -
int a = a++;   // это то же что и int a = a + 1;
int a = a--;   // это то же что и int a = a - 1;

int a = ++a;   // сперва прибавляется 1 а потом считается результат
int a = a++;   // сперва считается результат а потом прибавляется 1

эта операция (++ и --) используется очень часто
эта операция используется только к переменным, но не к числам

if - означает "ЕСЛИ"
else - означает "ИНАЧЕ"
else if - означает "ИНАЧЕ ЕСЛИ"

== - оператор сравнения (если равно то true, если не равно то false)
!= - оператор сравнения (если равно то false, если не равно то true)

еще операторы сравнения -
<
>
<=
>=

сравнение -
-
if (num1 == num2) {
   // тут пишется код который нужно выполнить если заданное условие совпало (true)
} else {
   // тут пишется код который нужно выполнить если заданное условие не совпало (false)
}
-

логические операторы -
&& - "И"
|| - "ИЛИ"

*********

урок_6
управляющие конструкции (if - else и т.п.)

проверка на что-то, логика проверки кода, управляющие инструкции

System.out.println(); // после печати строки делает перенос на следующую строку
System.out.print(); // после печати строки перенос не делает

принудительно приводим тип данных к типу char -
        ch = (char)System.in.read();
		
if - else if - else if - else
если - иначе если - иначе если - иначе
		
код игры "угадай букву" -
-
import java.io.IOException;
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) throws IOException {

        char ch, answer = 'B';

        System.out.println("Какую букву я загадал ? ");
        System.out.println("попытайтесь её угадать: ");

        ch = (char)System.in.read();

        if (ch == answer) {
            System.out.print("Поздравляю, вы угадали!   ");
        } else if (ch > answer) {
            System.out.println("Перестарался");
        } else {
            System.out.println("Недостарался");
        }
    }
}
-

конструкция switch - case
её нужно использовать тогда, когда мы знаем какие могут быть варианты ответов
-
import java.io.IOException;
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) throws IOException {

        int month = 1;

        String monthString;

        switch (month) {
            case 1:
                monthString = "январь";
                break;
            case 2:
                monthString = "февраль";
                break;
            case 3:
                monthString = "март";
                break;
            case 4:
                monthString = "апрель";
                break;
            default:
                monthString = "Не знаю такого";
                break;
        }
            System.out.println(monthString);
    }
}
-

*********

урок_7
циклы

цикл for -
for (int x = 0; x < 5; x++) {
    // тут код который нужно выполнять пока выполняется условие цикла (true)
	System.out.println("Итерация номер " + i);
}
в цикле не обязательно использовать только больше или меньше, можно задавать иные функции (равно true или false)как в этом примере -
-
import java.io.IOException;
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) throws IOException {

        for (int i = 0; (char) System.in.read() != 'S'; i++) {

            System.out.println("Iterasia nomer " + i);
        }
    }
}
-

обычно переменную для счетчика цикла принято называть - i

while - другой вариант цикла
while - означает "ПОКА" - то есть пока выполняется условие (true) цикл будет работать -
-
int i = 5;
	while (i > 0) {
		System.out.println(i);
		i--;
}

если условие изначально false, то цикл while может не выполниться вообще
а вот в цикле do while операция один раз выполнится в любом случае -

цикл do while -
-
public class HelloWorld {

    public static void main(String[] args) throws IOException {
        int i = 0;

        do {
            System.out.println(i);
            i++;
        } while (i < 11);
    }
}
-

если мы знаем количество операций - выбираем цикл for
если мы не знаем количество операций - выбираем цикл while 

оператор break - осуществляет прерывание цикла -
-
import java.io.IOException;
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) throws IOException {
        int count = 1;

        while (count < 10) {
            System.out.println(count);
            count++;

            if (count == 5) break;
        }
    }
}
-

оператор continue - возвращает исполнение к началу цикла тем самым не выполняя дальнейший код -
-
import java.io.IOException;
import java.util.Scanner;

public class HelloWorld {

    public static void main(String[] args) throws IOException {
        int count = 0;

        while (count < 10) {

            count++;
                if ((count%2) != 0) continue;
            System.out.println(count);
        }
    }
}
-

break - позволяет выйти из цикла при определенном условии
continue - позволяет вернутся к началу цикла при определенном условии

*********

урок_8
массивы

массив - это переменная в которой находится какое-то неопределенное или определенное количество каких-то данных

создадим несколько переменных типа int с одинаковыми либо разными значениями -
int num1 = 1;
int num2 = 1;
int num3 = 1;
int num4 = 1;

чтобы передать их в другое место нужно создать массив из этих значений -
int[] nums = {1, 1, 1, 1};
- тип массива - имя массива - переменные в массиве
к каждой переменной в этом массиве можно обратится отдельно и что-либо с ней сделать 

int[] nums = {1, 1, 1, 1};
             [0][1][2][3] - это номера ячеек данного массива 
			 
можно записать этот массив и так -
int nums[] = {1, 1, 1, 1};
но лучше записывать массивы так -
int[] nums = {1, 1, 1, 1};

если нужно создать массив, а у нас пока нет его значений, можно создать массив так -
int[] nums = new int[4];
- то есть мы как-бы говорим компьютеру - создай нам в памяти новое место где мы будем хранить 4 элемента типа int

можно представить себе элементы массива как набор переменных, только у этих переменных нет имен, а есть индексы, и обращаться к ним можно по индексу (читать, записывать, перезаписывать)

присвоить значение ячейке массива под номером 3 -
nums[3] = 100; 

существует замена цикла for для массивов, где не нужно считать количество ячеек в массиве а можно просто перебирать каждую из них и что-то с ней делать -
-
        for (int e : nums) {
            System.out.println(e);
        }
-

вот что получилось -
-
public class HelloWorld {

    public static void main(String[] args) {
        int[] nums = new int[4];

        for (int i = 0; i < 4; i++) {
            nums[i] = i;
        }
        
        for (int e : nums) {
            System.out.println(e);
        }
    }
}
-

многомерные массивы
двумерный массив -
int table[][] = new int[3][4];
- внутри этого массива еще 3 массива по 4 ячейки в каждом

в начале можно не определять эти данные а присвоить их позже -
int table[][] = new int[3][];

позже можно определить количество ячеек в каждом из этиз 3-х массивов -
int table[][] = new int[3][];
table[0] = new int[4];
table[1] = new int[4];
table[2] = new int[40];

существуют методы работы с массивами - они позволяют сортировать, добавлять, менять (элементы массива) и т.д.

*********

урок_9
классы

язык java объектоориентированный и строится на классах и их взаимодействии

класс - это формочка для выпечки печенья, а печенье, которое выпекается в этой формочке - это объект класса или экземпляр класса 

public - этот модификатор говорит о том, что этот класс можно использовать в других классах 

создадим новый класс -
-
public class Computer {

        int memory;
        int cpu;
        String name;

        void isCpu() {
                System.out.println(cpu);
        }
}
-

и основной класс с main -
-
public class Start {

    public static void main(String[] args) {

        Computer apple = new Computer();

        apple.cpu = 2500;
        apple.memory = 1000;
        apple.name = "MacBook12";
		
        apple.isCpu();



        Computer deal = new Computer();
        deal.cpu = 4500;

        deal.isCpu();
    }
}
-
класс - это тоже тип данных (ссылочный)

-
public class Start {

    public static void main(String[] args) {

        Computer apple = new Computer();

        apple.cpu = 2500;
        apple.memory = 1000;
        apple.name = "MacBook12";
        apple.isCpu();

        Computer deal = apple;

        apple.memory = 1500;
        
        apple.isMemory();
        deal.isMemory();
    }
}
-
-
public class Computer {

        int memory;
        int cpu;
        String name;

        void isCpu() {
                System.out.println(cpu);
        }

        void isMemory() {
                System.out.println(memory);
        }
}
-

инкапсуляция - когда переменные класса доступны только внутри этого класса и недоступны в другом месте (из других классов)

скрыть переменные - ключевое слово private 

если мы создаём метод, который будет присваивать имя одному из наших полей, то название метода должно начинаться со слова set (пример - setMemory) 

get - в начале названия метода где смотрим (get - в переводе "получить") значение (пример - getMemory)

конструктор класса - сначала класс создается с нулевыми значениями (если переменные объявлены но им ничего не присвоено)

конструктор класса - базовый метод, который будет выполняться при создании экземпляра 

тут конструктор внизу, через строку после переменных класса -
-
public class Computer {

        private int memory;
        private int cpu;
        private String name;

        Computer(int defMemory, int defCpu, String defName) {
                memory = defMemory;
                cpu = defCpu;
                name = defName;
        }
-

и при создании в другом классе нового класса прописываем уже с значениями -
-
        Computer apple = new Computer(1000, 3000, "MacBook");
-

ключевое слово this

конструктор будет выглядеть так -
-
        Computer(int memory, int cpu, String name) {
                this.memory = memory;
                this.cpu = cpu;
                this.name = name;
        }
-

создадим над первым конструктором ещё один пустой конструктор -
-
        Computer() {};
		
		Computer(int memory, int cpu, String name) {
        this.memory = memory;
        this.cpu = cpu;
        this.name = name;
        }
-
- это нужно для того, чтобы не было ошибки при создании объекта класса без параметров 
в зависимости от того ввели ли мы параметры или нет будет использоваться первый либо второй конструктор 

*********

урок_10
тип данных String в java

как объявляется String -
String str1 = new String("Hello");
или так -
String str2 = "Hello";


String в отличии от примитивных типов данных хранится в виде объекта, это ссылочный тип данных 

объединение строк (конкатенация)
String str3 = str1 + str2;

String - это неизменяемый тип данных

метод substring
String str3 = str2.substring();
каждый символ в строке имеет свой индекс, так же как и в массиве, начиная с 0 -
0, 1, 2, 3, 4......
если есть пробел, то у него тоже свой индекс

чтобы передать первых 3 символа - 0, 1, 2 (3-ий не передаётся) -
String str3 = str2.substring(0, 3);

сравнение строк 
== - строки так сравнивать неправильно, для сравнения строк есть метод equals (эквивалентно) -
boolean r = str1.equals(str2);

сравнить строки не обращая внимание на регистр букв в них -
str1.equalsIgnoreCase(str2); 
-
        String s1 = "Aaa";
        String s2 = "aaa";

        System.out.println(s1.equalsIgnoreCase(s2));
-

toLowerCase - переводит все символы строки в маленькие

toUpperCase - переводит все символы строки в большие

length - считает количество символов в строке -
System.out.println(s2.length());

в массивах индекс начинается с 0 - 0, 1, 2, 3, 4, 5.... -
String[] s2 = {"Hello", "World", "People"};
индекс -          0        1         2

обратится к 2-му элементу массива -
-
        String[] s2 = {"Hello", "World", "People"};

        System.out.println(s2[2]);
-

в терминале - 
sd - перейти
sd.. - перейти на каталог вверх
dir - просмотреть файлы и папки в данном каталоге 

скомпелировать программу с помощью javac -
перейти в терминале в каталог где находится javac - C:\Java\jdk11\bin\
скомпелировать файл -
C:\Java\jdk11\bin\javac Start.java 
запустить файл -
C:\Java\jdk11\bin\java Start.class (или без .class)

*********

урок_11
наследование 

создаём класс Cow который будет наследовать класс Animal -
-
public class Cow extends Animal {

}
-

ключевое слово для наследования - extends (прошлые тенденции)

инкапсуляция - у класса параметры должны быть приватными (private)

методы - геттеры и сеттеры (get и set) -
нажать Alt + Ins 
там выбрать - геттер/сеттер/геттер и сеттер
выбрать параметры класса для которых нужно создать методы 
-
public class Animal {
    private String say = ".......";
    private int teeth = 0;

    public String getSay() {
        return say;
    }

    public void setSay(String say) {
        this.say = say;
    }

    public int getTeeth() {
        return teeth;
    }

    public void setTeeth(int teeth) {
        this.teeth = teeth;
    }
}
-

так как класс Cow наследует класс Animal, там уже есть всё то же самое что и в методе Animal 

создадим конструктор - Alt + Ins 

тема наследования простая - мы создаем общий класс и потом другой класс, который наследует параметры и методы родительского класса, но также может иметь и свои методы 

переопределение методов - создать в классе который наследует свойства родительского, метод с названием как в родительском классе, но чтобы он выполнял какие-то другие действия 
- и этот метод должен быть public, так как мы будем вызывать его в других местах -
-
    public String getSay() {
        String say = super.getSay();
        return say + " New ";
    }
-
слово super означает что мы обращаемся к методу в родительском классе 
-
public class Start {
    public static void main(String[] args) {

        Cow bur = new Cow("Mooooo", 28);

        bur.mu();
        
    }
}
-
public class Animal {
    private String say = ".......";
    private int teeth = 0;

    public String getSay() {
        return say;
    }

    public void setSay(String say) {
        this.say = say;
    }

    public int getTeeth() {
        return teeth;
    }

    public void setTeeth(int teeth) {
        this.teeth = teeth;
    }
}
-
public class Cow extends Animal {

    public Cow(String say, int teeth) {
        setTeeth(teeth);
        setSay(say);
    }

    void mu () {
        System.out.println(getSay() + " vo vse " + getTeeth() + " zuba ");
    }

    public String getSay() {
        String say = super.getSay();
        return say + " New ";
    }
}
-

*********

урок_12
интерфейсы 

создание интерфейса - File - New - Java Class - Interface - ввести имя интерфейса -
-
public interface Player {
}
-
идея интерфейса в том, что мы связываем интерфейс с каким-то классом 

создадим новый класс Boy и свяжем его с интерфейсом с помощью слова implements (в дальнейшем мы будем говорить - имплеметируем интерфейс) -
-
public class Boy implements Player {

}
-
как только мы это сделали, мы обязали класс Boy иметь все методы, которые имеет интерфейс Player 

если в интерфейсе создать метод -
-
void play ();
-
то в классе Boy нужно имплементировать этот метод -
-
Alt + Ins - Implement Metod - выбрать название метода, который нужно имплементировать 

также создадим класс Girl, и имплементируем туда также метод void play ();

при этом Boy у нас будет запускать игру ногой, а Girl запускать игру рукой, вот что получилось - 
-
public class Start {
    public static void main(String[] args) {
        
	Boy jon = new Boy();
    Girl kat = new Girl();

    jon.play();
    kat.play();
    }
}
-
public interface Player {

    void play();
}
-
public class Boy implements Player {

    public void play() {
        System.out.println("Zapuskat nogoy");
    }
}
-
public class Girl implements Player{

    public void play() {
        System.out.println("Zapuskat rukoy");
    }
}
-

можно создать переменную на основе интерфейса -
        Player unit = jon;
		
если бы мы обращались напрямую к jon, то могли бы вызвать все методы, которые есть в классе Boy, но так как мы обращаемся к jon через Player, то можно вызвать только те методы, которые есть в классе Player 

создадим интерфейс Study, в нем пропишем метод read -
    void read();
	
в классе Boy в первой строке через запятую после implements Player добавим Study а также добавим метод read -
-
public class Boy implements Player, Study {

    public void play() {
        System.out.println("Zapuskat nogoy");
    }

    public void read() {
        
    }
}
-

создадим класс Schkool -
-
public class School {
    Study study;

    void start (Study study) {
        study.read();
    }
}
-

мы обращаемся к Boy через интерфейс Study или Player, и забираем только те методы, которые нам нужны, то есть во время игры забираем метод play(), а во время учебы забираем метод read()

код -
-
public class Start {
    public static void main(String[] args) {

        Boy jon = new Boy();
        Girl kat = new Girl();

        jon.play();
        kat.play();

        Player unit = jon;
    }
}
-
public interface Player {

    void play();

}
-
public interface Study {

    void read();
}
-
public class Boy implements Player, Study {

    public void play() {
        System.out.println("Zapuskat nogoy");
    }

    public void read() {

    }
}
-
public class Girl implements Player{

    public void play() {
        System.out.println("Zapuskat rukoy");
    }
}
-
public class Game {

    public  Player player;

    void start (Player player) {
        player.play();
    }
}
-
public class School {
    Study study;

    void start (Study study) {
        study.read();
    }
}
-

*********

урок_12
абстрактные классы 

чтобы сделать метод абстрактным нужно написать abstract -
	abstract void func ();
	
абстрактные классы должны быть публичными, поэтому так -
	public abstract void func ();
	

если у нас в классе есть абстрактный метод, то и этот класс тоже должен быть абстрактным -
-
public abstract class Human {
    public abstract void func ();
}
-

когда мы создаем абстрактный класс, мы его просто называем и всё, мы не прописываем его реализацию, то есть не так -
	public abstract void func () {
}
а так -
	public abstract void func ();
после точки с запятой быть ничего не должно 

в абстрактном классе могут быть не только абстрактные методы, но и обычные -
-
public abstract class Human {

    public abstract void func ();

    void say () {
        System.out.println("'''''''''''");
    }
}
-

обычно в интерфейсе создаются абстрактные методы (без реализации)

абстрактвый класс создаётся для абстракции, то есть мы не можем создать отдельную переменную для Human? этот абстрактный класс нужен для того, чтобы от него кто-то наследовался 

создадим класс Person, который будет наследником класса Human?куда также имплементируем метод, объявленный в классе Human -
-
public class Person extends Human {

    public void func() {
        System.out.println("123");
    }
}
-

один класс может унаследовать много разных интерфейсов, но унаследовать много разных классов не может, а может унаследовать только один класс 

если нужны только абстрактные методы, то делать класс абстрактным, если же абстрактные методы не нужны, то делать его обычным 

*********

урок_13
вложенные классы 

создадим класс Human и в него можно вложить другой класс, это обычно делают тогда, когда класс может иметь составляющие - например Человек а внутри него Голова, Руки, Ноги и т.п.
-
public class Human {
    public Head head;

    public Human() {
        this.head = new Head();
    }

    void say () {
        System.out.println("Moy golos " + head.voice);
    }

    class Head {
        String voice = "Tonkiy";

    }
}
-
- то есть внутри класса Human мы можем работать с вложенными в него классами 

а в стартовом классе следующее -
-
public class Start {
    public static void main(String[] args) {

        Human karl = new Human();

        karl.say();
    }
}
-

*********

урок_14
пакеты (Package)

по сути - пакет это папка 
при этом в каждой папке (пакете) могут находится классы, которые будут называться одинаково 
если одинаковые классы лежат в одном пакете, то они конфликтуют между собой (так делать нельзя)

создать пакет - File - New - Package - присвоить имя 

можно брать что-то из соседнего пакета с помощью импорта -
import People.Human;
- тут People это название пакета, а Human это название класса 

вверху каждого класса нужно писать название пакета в самом верху, а потом уже весь остальной код -
-
package People;
// тут прописано название текущего пакета

import Man.Human;
// тут импортируется класс Human из пакета Man

public class Start {
    public static void main(String[] args) {
	...
	}
}
-

при создании пакета рекомендуется использовать название компании (доменное имя) -
com.yandex.calculater;

и через точку можно писать еще много названий, типа так -
com.yandex.calculater.superclass;

*********

урок_15
перегрузка методов (перегрузка конструкторов)

создать конструктор -
правая кнопка мыши - Generate... - Constructor

создадим в классе один пустой конструктор, один конструктор с значениями int, один конструктор с значениями String -
-
public class Human {

    public Human() {
    }

    public Human(int a) {
        System.out.println(a);
    }

    public Human(String a) {
        System.out.println(a);
    }
}
-
в зависимости от типа переменной переданной как значение в стартовом классе в Human imia = new Human();
если мы ничего не передаём - вызывается пустой конструктор, если передаем значение int - вызывается интовый конструктор, если передаем значение String - вызывается конструктор с String

*********

урок_16
основы ООП (объектно-ориентированного программирования)

ООП - это подход (принцип) согласно которого мы програмируем на Java 

наследование (Class2 наследует свойства и функции Class1)-
-
public class Class2 extends Class1 {
}
-

инкапсуляция -
-
public class Human {
    private String imiaperemennoy = "Znachenie";
}
-
слово private означает что данная переменная доступна только из этого класса (то есть мы её инкапсулировали) и теперь чтобы с ней работать нужно использовать геттеры и сеттеры и обращаться через них 

полиморфизм (многообразие форм) -
как пример - перегрузка методов и перегрузка конструкторов (тут выше в уроке 15)

также проявлением полиморфизма является то, когда мы здесь -
-
public class Class2 extends Class1 {
}
-
в Class2 наследуем методы от Class1 а потом переопределяем их 

абстракция - 
абстрактные классы, которые потом будут унаследованы всеми классами-потомками

про ООП прочитать ещё в других источниках 

*********

урок_17
обработка исключений

обработка исключений - это обработка ошибок 

мы написали какой-то код (допустим прописали что нужно разделить на ноль) и в результате него произошла ошибка 
илимы сами вручную генерируем какое-то исключение (ошибку) и управляем им 

создадим массив на 4 элемента и в блоке try код, который должен выполняться -
-
package com.olsi.testone;

public class Main {
    public static void main(String[] args) {
        int nums[] = new int[4];

        try {
            System.out.println("Nachalo");
            nums[7] = 10;
        } catch (ArrayIndexOutOfBoundsException exc) {
            System.out.println("U nas oshibka");
        } 
    }
}
-
- здесь ArrayIndexOutOfBoundsException - название возможной ошибки, а exc - произвольное имя переменной 

если мы не пропишем такую конструкцию, как в примере выше, то наша программа аварийно остановит свою работу, также можно продолжить выполнение программы из другого места а не привести её к завершению из-за возникшей ошибки 

блок try - catch помогает обрабатывать исключения и помогает пользователю понять в чем проблема при работе программы

у разных типов ошибок есть свой объект, который эту ошибку характеризует (в данном примере это - ArrayIndexOutOfBoundsException)

если ошибки не произошло, то catch вообще не будет выполняться 

блоков catch может быть несколько, так как в коде может быть несколько разных ошибок, и соответственно код каждой возможной ошибки прописывается в отдельном блоке catch -
-
package com.olsi.testone;

public class Main {
    public static void main(String[] args) {
        int nums[] = new int[4];

        try {
            System.out.println("Nachalo");
            nums[7] = 10;
        } catch (ArrayIndexOutOfBoundsException exc) {
            System.out.println("U nas oshibka");
        } catch (ArithmeticException exc) {
            System.out.println("U nas oshibka");
        }
    }
}
-
- и если один блок кода catch запущен, то второй уже запускаться не будет 

названия (типы) ошибок, с которыми скорее всего придется столкнуться:

попытка обратиться за пределы массива (переполнение массива) - 
ArrayIndexOutOfBoundsException

арифметическая ошибка (например при делении на 0)- ArithmeticException

когда пытаются ввести в массив элемент, не совместимый с ним по типу -
ArrayStoreException

когда мы пытаемся привести тип данных, но делаем это неправильно (недопустимое приведение типов данных) -
ClassCastException 

когда при вызове метода передаётся недопустимый параметр -
IllegalArgumentException

когда создаём массив динамическим образом и вдруг массив становится отрицательного размера -
NegativeArraySizeException

если в переменную мы передаём ссылочный тип данных, то есть ссылку на что-то, и эта ссылка оказывается пустой и никуда не ведёт (недопустимое использование пустой ссылки) -
NullPointerException 

когда вдруг произошел неизвестный тип -
TypeNotPresentException

когда операция которую мы делаем не поддерживается -
UnsupportedOperationException

когда класс не найден -
ClassNotFoundException 

у классов есть абстрактные классы, но когда мы это забываем и пытаемся их создать -
InstantiationException 

название ошибок выводятся внизу в терминале красной строкой 

искать в google по названию ошибки и понять что она означает 

*********

урок_заключительный
что делать дальше

портал с задачами для тренировки -
codewars.com

на чистой java программисты не пишут 

java програмист - это бэкэнд програмист

+ базы данных - SQL
+ JUnit
+ Git
+ Spring (создание веб-сервисов (сайтов))
+ REST API (протоколы)

найти работу джуниор java разработчика, но в любом случае тебя будут доучивать на работе 

то есть два направления -
- Spring
- Android (kotlin) разработка

*********

THE END


