
D:\1_CODING\АНАЛИТИКА ДАННЫХ\инженер данных Бердышев



телеграм - my_coding - 24.07.2024 (архивы с файлами курса)

текстовый файл с ДЗ - телеграм - my_coding - 24.07.2024

канал автора - 
https://www.youtube.com/@digitalberd

плейлист "инженер данных" -
https://youtube.com/playlist?list=PLLxnyHENCxBBPQHlKvj_fMY5EOtyd5570&si=PyrPbtSd_UpymW0S

Можешь мой курс на ютубе пройти. Как все 40 уроков пройдёшь - дальше уже можно работать инженером данных и остальное доучивать уже в процессе.

Рассчитывайте в неделю откликаться на 200-300 вакансий, идеально выйти на 5 техсобесов в неделю, желательно хотя бы на 3.

В ЛЮБОМ случае не надо ничего дополнительного проходить.
1. Проходите 40 уроков из этого курса, делаете все ДЗ.
2. Больше ничего не проходите - сразу после 40-го занятия - делаете резюме по 41-му уроку и начинаете ходить по собесам.
По такой схеме люди уже устраиваются на работу (месяца через 2-3 сделаю видос с полной статистикой по результатам).

моё видео: https://youtu.be/yaNbfA0Bvpk?feature=shared (Как устроиться на работу в IT - пишем резюме и ищем работу.)
- это видео 45 курса 
Там я рассказываю, что джуном идти устраиваться точно не стоит.
На курсе я даю знаний, с которыми люди получали офферы на мидла.
Для этого необходимо пройти весь курс и сделать все ДЗ, дополнительно хорошо позаниматься SQL - просто в течении месяца каждый день задачи на SQL решать, потом накрутить 3 года опыта и устраиваться на мидла.

Если захотите SQL-ные задачи порешать -
(купил 09.10.2024 за 300 р.): 
https://stepik.org/a/215218

Увидел тут курс, очень похожий на мой - только с SQL частью - очень рекомендую всем ознакомиться. Смотрите лучше прям с самого начала (3 года назад):
https://www.youtube.com/@DataCourse/videos
- этот курс изучить сразу после завершения курса Бердышева

потом пройти курс Саши Ильина - Python за 6 часов (в этой папке)

потом ещё 2 курса - "инженер данных" -
- яндекс.практикум 
- karpov.courses

-----------------------------------------
github.com - 
sojmoscow@g........
OlSiv
a........git 
-----------------------------------------
или этот - 
-----------------------------------------
github.com -
pomo24abc@g........
pomo24
a........24git
------------------------------------------
+
------------------------------------------
gitlab.com
---
sojmoscow@.......
olegsiv
a........gb6!
------------------------------------------

100 записались - 50 прошли курс - 25 устроились на работу 

самый найм - с середины сентября и до нового года 

на hh.ru искать -
инженер данных sql 
- 150_000 - 200_000 на руки 
и поставить 39 лет чтобы обойти фильтры кадровиков

для практики SQL - 
sql-ex.ru
>>>
lex1904
a........sx6!
lex1904@mailforspam.com
<<<
sql-academy.org/ru/trainer
pgexercises.com 
+ 
на karpov.courses 



Нашёл просто топ контент, человек проводит моковые собесы на инженера данных:
https://www.youtube.com/@rzv_de/videos

Тут его контакт:
https://getmentor.dev/mentor/aleksey-razvodov-2740



Еще роадмап по DE - 
https://github.com/halltape/HalltapeRoadmapDE

Как составлять резюме - 
https://github.com/halltape/HalltapeRoadmapDE/tree/main/Resume



******************************************************************

1 -
https://youtu.be/B7aEzW_QZcs?si=pzBhZDJqJjgOmeMm

простой стек технологий - python и SQL 

в бекэнд сейчас мало вакансий, и ещё в бекэнде много других ЯП - PHP, Go и т.п. 

инженер данных - сейчас вакансий много 

можно пойти аналитиком данных или BI-аналитиком

можно переучится на бекэндера - выучить Alchemy + модели таблиц + фреймворк (Django, FastAPI, Flask) 

можно пойти тестировщиком - python, SQL, библиотека Requests

все синьёры-аналитики задумываются об ML - большие перспективы для роста 

SQL - один раз выучил - всю жизнь используешь
 
с годами данных меньше не станет, а станет только больше 

******************************************************************

2 -
https://youtu.be/xF-xIr3c_yY?si=vK7NEIls5Gl-iSwD
-
Знакомство.
Учиться надо много.
Базовые типы данных, немного практики.
-

python, airflow, sql, linux

урок в день + 2 часа ежедневно - самостоятельное программирование и ДЗ 

нужны будут навыки самостоятельного решения задач и навыки программирования 

нужно научиться самому писать код, много кода 

писать код через немогу и нехочу 



--
v_int = 2

v_float = 3.0

v_string = 'test string'

v_int2 = v_int * 15

# v_int = 'val string'

result = v_int * v_float

# явное преобразование типов - 
v_int = float(v_int)

v_list = list()
v_list = []
v_list = [1, 2, 3, 4, 5.1, 'some string', False]
v_list2 = [10, 20, 30, v_list]

# сложение списков -
v_list3 = [10, 20, 30] + v_list

print(v_int)
print(v_float)
print(v_string)
print(v_int2)
print(result)
print(type(v_int))
print(v_list)
print(v_list2)
print(v_list3)
----
2.0
3.0
test string
30
6.0
<class 'float'>
[1, 2, 3, 4, 5.1, 'some string', False]
[10, 20, 30, [1, 2, 3, 4, 5.1, 'some string', False]]
[10, 20, 30, 1, 2, 3, 4, 5.1, 'some string', False]
------



--
# добавление элемента в список -
v_list = [1, 2, 3, 4, 5]
v_list.append('yoho')
print(v_list)
----
[1, 2, 3, 4, 5, 'yoho']



или так, сложением списков - 
--
v_list = [1, 2, 3, 4, 5]
cc = [6]
d = v_list + cc
print(d)
----
[1, 2, 3, 4, 5, 6]
------

отступы в python - это критично

python регистрозависимый - name и Name - это не одно и то же 

; - в python в конце строк не ставить 

переключить в PyCharm вид со старого на новый и обратно - 
File - Settings - Appearance & Behavior - New UI - Enable new UI (квадратик с галочкой)

pep8 - стандарт



ДЗ:

1. Прочитать про типы данных:
https://pyneng.readthedocs.io/ru/latest/book/04_data_structures/index.html  
- тут хорошо написано + подробнее откройте и посмотрите по каждому типу.

2. Практическая часть:
- создайте проект и файл .py
- присвойте переменной любое значение.
- выведите её через print()
- запустите файл (сверху на вкладке с файлом кликните правкой кнопкой -> Run)

3. Создайте несколько переменных каждого типа, какие были в п.1 (Numbers (числа), Strings (строки), Boolean (логический тип данных))

4. Сделайте все возможные операции над этими переменными:
- сложение
- вычитание
- умножение
- деление
- найдите остаток от деления на числа - загуглите как.
- явное преобразование типов - например float 1.3 преобразуйте в int

5. Попробуйте поработать с типом list()
- создайте переменную
- внесите туда какие-то значения
- добавьте туда ещё значений при помощи функции .append()
- добавьте один list внутрь другого
- сложите 2 разных list

--
val_int = 10
val_float = 2.34
val_str = 'hello'
val_bool = True

print(val_int % 3)
print(int(val_float))

v_list = ['a', 2, True, 5.23]
v_list1 = [1, 2, 3]
v_list.append(555)
print(v_list)
v_list.append(v_list1)
print(v_list)
v_list2 = v_list + v_list1
print(v_list2)
----
1
2
['a', 2, True, 5.23, 555]
['a', 2, True, 5.23, 555, [1, 2, 3]]
['a', 2, True, 5.23, 555, [1, 2, 3], 1, 2, 3]
------

******************************************************************

3 -
https://youtu.be/Bx_Rp-bzZ8U?si=tdydgn5v6WtAbQVF
-
Телеграм группа для тех, кто проходит курс "Инженерия данных с 0"
Телеграм группа ПТ - для флуда
3 телеграм группы для опытных.
-

Учимся инженерии данных - DigitalBerd
https://t.me/study_digitalberd
Группа для тех, кто проходит курс "Инженерия данных с 0"

ПТ - DigitalBerd 
https://t.me/pt_digitalberd
Просто трёп. Обсуждаем всё, что угодно. Включая политику.

data engineers - DigitalBerd
https://t.me/de_digitalberd
Группа для инженеров данных

data аналитики - DigitalBerd
https://t.me/da_digitalberd
Группа для аналитиков данных

DS ML - DigitalBerd
https://t.me/ds_digitalberd
Группа для дата сайнтистов

CDO - DigitalBerd
Группа для CDO.
Для вступления в группу с CDO - пишите мне в телеграмм
https://t.me/Alexander_Berdyshev

******************************************************************

4 -
https://youtu.be/YZqHT8BXPCY?si=2K6yumkkKIT-jeA0
-
Python
Коллекции
Повторяем списки (list)
Проходим словари (dict)
-

в словаре (dict) - значения достаются по ключу 
автор при обращении к словарю всегда использует метод get -
--
dict1 = {'Jon': 20, 'Sam': 25}
print(dict1.get('Sam'))
----



--
list1 = [1, 2, 3, 'hello']
print(list1)

# оставить только уникальные значения с помощью set - 
# (автор использует на практике set только для этого) -
list2 = [1, 1, 2, 2, 3, 3, 4]
list3 = list(set(list2))
print(list3)

d1 = dict()
print(d1)
print(type(d1))

d1['first'] = 1
d1['second'] = 234

d1['first'] = 567

print(d1)
----

тип None 

тип boolean (bool) - True и False 


создание словаря -
--
d2 = dict()
d3 = {}
d4 = {'a': 1, 'b': 2}
----


вывести только ключи словаря - keys() -
--
dict1 = {'a': 1, 'b': 2, 'c': 3}
print(dict1.keys())
print(type(dict1.keys()))
----
dict_keys(['a', 'b', 'c'])
<class 'dict_keys'>
------

аналогично -
- values() - выведет все значения 
- items() - выведет ключи и значения 
--
dict1 = {'a': 1, 'b': 2, 'c': 3}

for i in dict1.values():
	print(i)

print('***')

for i, j in dict1.items():
	print(f'{i} - {j}')

print('***')

print(dict1.values())
print(type(dict1.values()))

print(dict1.items())
print(type(dict1.items()))
----
1
2
3
***
a - 1
b - 2
c - 3
***
dict_values([1, 2, 3])
<class 'dict_values'>
dict_items([('a', 1), ('b', 2), ('c', 3)])
<class 'dict_items'>
------

можно размещать в словаре другие словари в качестве значений -
--
d1 = {'a': 1, 'b': 2, 'c': 3}
d2 = dict()
d2['new'] = d1 
d2['old'] = 123
print(d2)
print(d2.get('new').get('b'))
----
{'new': {'a': 1, 'b': 2, 'c': 3}, 'old': 123}
2
------

словарь подходит для хранения до 1000 элементов, если больше - то уже будет медленно работать 

словарь работает медленее чем список(list)

ключ словаря - обязательно неизменяемый тип данных - число, строка, но не колекции 

tuple (кортеж) - неизменяемое множество -
--
a = (1, 2, 3)
b = (1,)

print(a[0])
----

set - изменяемое неупорядоченное множество уникальных элементов -
--
s = set()
s1 = {1, 2, 3}

list1 = [1, 2, 2, 3, 3, 3, 4, 4, 5]
s1 = set(list1)
print(s1)
----
{1, 2, 3, 4, 5}
------

посмотреть методы (например методы словаря d3) -
- написать в IDE d3 и поставить точку 
- print(dir(d3))

гуглить - 
- официальная документация на английском 
- документация на русском
искать (python dict (официальная) документация)

удаление из словаря -
--
d1 = {'a': 1, 'b': 2}
print(d1)

del d1['a']
print(d1)
----
{'a': 1, 'b': 2}
{'b': 2}
------

несколько строк в строке - 
--
str1 = """
aaaaaaaaaaaaaaaaaaaa
bbbbbbbbbbbbbbb
ccccccccccc
"""

print(str1)
----
aaaaaaaaaaaaaaaaaaaa
bbbbbbbbbbbbbbb
ccccccccccc
------

как сложить 2 словаря - я думаю что можно так - 
--
d1 = {'a': 1, 'b': 2}
d2 = {'c': 3, 'd': 4, 'e': 5}

for i, j in d2.items():
    d1[i] = j

print(d1)
----
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
------


как проверить есть ли ключ в словаре -
--
dict1 = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}

list1 = list(dict1)

if 'c' in list1:
	print('Yes')
else:
	print('No')
----



ДЗ:
1. Создать несколько листов. Сложить их. В новый словарь выбрать только уникальные значения (можете в видосе посмотреть, как это делать)
--
list1 = [1, 2, 3, 4, 5, 6, 7]
list2 = [4, 5, 6, 7, 8]
list3 = [5, 6, 7, 8, 9, 10, 11]

list4 = list(set(list1 + list2 + list3))

print(list4)
----
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
------


2. Создать несколько словарей. Словари с базовыми типами, словари с листами, словари со словарями.
3. Подоставать значения из словарей через .get()
4. Положить один словарь в другой. Потом достать значения из вложеного словаря.
--
dict1 = {'a': 1, 'b': 2, 'c': 3}
dict2 = {
    'one': [1, 2, 3],
    'two': [4, 5, 6]
}
dict3 = {
    'one': {'a': 1, 'b': 2, 'c': 3},
    'two': {'d': 4, 'e': 5, 'f': 6, 'g': 7}
}

print(dict1.get('c'))
print(dict1.get('x'))

print(dict2.get('two'))
print(dict2.get('two')[1])

print(dict3.get('two'))
print(dict3.get('two').get('f'))
----
3
None
[4, 5, 6]
5
{'d': 4, 'e': 5, 'f': 6, 'g': 7}
6
----

5. Сделать лист с ключами словаря. Сделать лист со значениями словаря.
--
dict1 = dict()
dict1['a'] = 1
dict1['b'] = 2
dict1['c'] = 3
print(dict1)

list1 = list(dict1)
list2 = list(dict1.values())

print(list1)
print(list2)
----
{'a': 1, 'b': 2, 'c': 3}
['a', 'b', 'c']
[1, 2, 3]
------

6. В уже созданном словаре изменить значение элемента (перезаписать другим значением)
--
dict1 = {'a': 1, 'b': 2, 'c': 3}
print(dict1)

dict1['c'] = 5

print(dict1)
----
{'a': 1, 'b': 2, 'c': 3}
{'a': 1, 'b': 2, 'c': 5}
------

7. Всё вышеперечисленное повторить несколько раз.

Если будут вопросы по словарям - или смотрите в видео, или гуглите. 

******************************************************************

5 -
https://youtu.be/du5isBpUr1o?si=bpCcJoWU2OTygpTS
-
Python
условный оператор
оператор ветвления
Python if
-

Ctrl + Alt + L - форматирование кода в PyCharm 

***

Саша Ильин - курс в youtube - Python за 6 часов - 
https://youtu.be/wDmPgXhlDIg?si=OUVCjl-8APJDdrHr
и это ещё одна ссылка на то же -
https://www.youtube.com/watch?v=wDmPgXhlDIg

Роадмап Python бэкенд-разработчика почти без вложений денег: https://t.me/digital_ninjaa/135

Ссылки, используемые в курсе: 

1. Онлайн-интерпретатор: 
https://www.online-python.com/

2. Установка Python на компьютер: https://www.python.org/downloads/

3. PyCharm Community Edition: 
https://www.jetbrains.com/pycharm/download/?section=windows

4. Репозиторий с кодом курса: 
https://github.com/jjoskey/python_beginners_course

5. Документация к открытому API Binance: 
https://binance-docs.github.io/apidocs/spot/en/#symbol-price-ticker

6. Visual Crossing, бесплатный API погоды: 
https://www.visualcrossing.com/weather-api

7. JSON Formatter:
https://jsonformatter.curiousconcept.com/

8. Официальный бот от Telegram для регистрации других ботов: https//t.me/BotFather

00:00:00 - Интро
00:03:00 - Функция print
00:05:50 - Переменные
00:10:04 - Числа (int, float)
00:22:47 - Булевый тип (bool)
00:31:11 - Условные операторы
00:42:03 - Строки (str)
00:58:47 - Установка софта
00:59:25 - Установка на Windows
01:01:57 - Установка на macOS
01:04:46 - Списки (list)
01:19:59 - Индексы и слайсы
01:30:56 - Цикл for
01:44:02 - Функции
01:57:03 - Область видимости переменных
02:06:29 - Цикл while
02:27:24 - Кортежи (tuple)
02:31:13 - Словари (dict)
02:39:58 - *args, **kwargs
02:51:26 - json
02:55:41 - import
03:03:33 - Установка сторонних библиотек
03:04:05 - Библиотека requests
03:12:49 - Списочные включения
03:23:02 - Множества (set)
03:29:06 - Функции sorted и filter
03:39:04 - lambda функции
03:42:43 - Обработка исключений
03:48:02 - Классы
04:23:28 - Декораторы
04:40:14 - Простейший telegram bot
04:51:42 - Дата и время
04:57:52 - Работа с файлами
05:05:15 - Менеджер контекста
05:06:38 - Изменяемые и неизменяемые структуры данных
05:26:28 - Заключение

***

но мы в данном курсе по python пройдемся значительно быстрее 

bool-евый тип - True или False 

условный оператор (оператор ветвления, if) - 
ЕСЛИ - ИНАЧЕ ЕСЛИ - ИНАЧЕ ЕСЛИ - ИНАЧЕ 
if - else 
if - elif - else 
if - elif - elife - .... - else 



--
a = 10

if a < 0:
	print('Menshe 0')
elif a > 0:
	print('Bolshe 0')
else:
	print('Ravno 0')
----



операторы сравнения - 
==
!=
<
>
<=
>=
and
or
not 



--
a = 1

list1 = [1, 2, 3]

if a in list1:
	print('a inside list1')
----



--
a = 3

list1 = [1, 2, 3]

if len(list1) == a:
	print('a elements in list1')
----



ДЗ:

1. Использовать условный оператор - сравнить несколько чисел и вывести что-нибудь в print
--
a = 10
b = 10

if a > b:
    print('a > b')
elif b > a:
    print('b > a')
else:
    print('a == b')
----

2. Использовать условный оператор - и если число в переменной положительное - умножить его на 10, а если отрицательное - разделить.
--
num = 10

if num > 0:
    print(num * 10)
elif num < 0:
    print(num / 10)
else:
    print('num = 0')
----

3. Если число кратно 2м - то разделить его на 2 и вывести - иначе - умножить на 3. Как детектировать кратность числа в питоне - погуглите.
--
num = 5

if num % 2 == 0:
    print(num / 2)
else:
    print(num * 3)
----

4. Сделать какой-нибудь if внутри if.
--
num = 10

if num > 0:
    print('num > 0')
    if num == 10:
        print('num = 10')
else:
    print('num < 0')
----

5. взять 2 переменных. Если в каждой переменной лежит тип int - вывести их сумму.
--
num1 = 1
num2 = 2.0

if (type(num1) == int) and (type(num2) == int):
    print(num1 + num2)
else:
    print('type num1 or type num2 not int')
----

6. использовать оператор if с типом list - проверить наличие значения в списке.
--
list1 = [1, 2, 3]

x = 1

if x in list1:
    print(x)
else:
    print('x not in list')
----

А вообще можете ещё попридумывать задач и покодить.
if - это база - и вы его должны уметь писать прям на автомате - а это всё достигается большим количеством практики.

http://gitlab.digitalberd.com/Berd/data_egineering_lessons

******************************************************************

6 - (4 урок) -
https://youtu.be/s8ZIEl_7Wwc?si=NTX2pLlHncgJfKAs
-
+ прочитай все комментарии под роликом в youtube 
-
ВАЖНО! Про continue рассказал неправильно - он работает по-другому.
Ссылка на код урока: 
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson4.py
Урок 4.
Python
циклы
for
while
-


for ... in ... (перебор) -
--
lis1 = [1, 2, 3, 'hello']

for i in lis1:
	print(i)
	print(i * 10)
----


while (пока выполняется условие) - 
--
a = 1

while a < 10:
	print(a)
	a += 1
----


бесконечный цикл - 
--
import time 

while True:
	time.sleep(1)
	print('hello')
----


continue и break - 
--
li = [1, 2, 3, 4, 5, 6, 7, 8, 9]

for i in li:
    if i == 3:
        continue   # перевод на следующую итерацию цикла
    if i == 7:
        break   # выход из цикла 
    print(i)
----


можно делать цикл в цикле 


f форматирование строк -
--
a = 10 
b = 20

print(f'hello, {a} {b}')
----



Домашнее задание:

1. Написать цикл по листу.
--
list1 = [1, 2, 3, 'a', 'b', True, None]

for i in list1:
    print(i)
----

2. Написать цикл по листу со строками. Выводить значения, если длина строки элемента > 5 символов.
--
list_1 = ['aaaaaaaa', 'bbb', 'cccccccc', 'ddd', 
'eeeeeeeeeee', 'gg', 'hhhhhhhhh']

for i in list_1:
    if len(i) > 5:
        print(i)
----

3. Написать цикл по листу с листами. Внутри цикла по внешнему листу - сделать цикл по внутренним листикам. Просто выводить элементы.
--
list_1 = [[1, 2, 3], [1, 2], [3, 4, 5], [6, 7], 
[8, 8, 9], [8, 7, 6, 5]]

for i in list_1:
    for j in i:
        print(j)
----

4. Написать цикл по словарю (по ключам словаря). Выводить ключи и выводить значения.
--
d = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}

for i in d:
    print(i, d.get(i))
----

5. Вывести цифры от 1 до 10000 используя цикл while и break. Про continue я всё неправильно рассказал - continue лучше не используйте.
--
i = 1

while True:
    if i == 11:
        break
    print(i)
    i += 1
----

6. Создайте 2 словаря с различными ключами. Сделайте 3й словарь - чтобы там были значения и из 1го словаря и из второго - используя цикл по второму словарю.
--
d1 = {'a': 1, 'b': 2, 'c': 3}
d2 = {'d': 4, 'e': 5, 'x': 6, 'y': 7}

d3 = d1.copy()
print(d3)

for i in d2:
    d3[i] = d2.get(i)

print(d3)
----

******************************************************************

7 - (5 урок) -
https://youtu.be/da79Yro-GRw?si=-NPqBwMQkFrT8vIG
-
+ прочитай все комментарии под роликом в youtube 
-
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson5.py
-
Урок 5.
Python
def
функции
-

По поводу именования переменных - в книге "Чистый код" было хорошо разобрано. Коротко можно тут прочитать: https://jackofshadows.blogspot.com/2016/01/11.html

--
def func1():
	print('a')
	print('b')
	
def func2(element):
	print(element, element*2)
	
	
for i in range(3):
	func1()
	
for i in range(1, 3):
    func2(i)
----


в функцию можно передавать элементы по порядку, а можно присваивать конкретные значения - 
--
def func2(name, age):
    print('{0} - {1} - {0}'.format(name, age))


func2(name='Alex', age=42)
----


можно прописать значение по умолчанию - 
--
def func2(name, age, lastname='Smirnov'):
    print('{0} - {1} - {2}'.format(name, age, lastname))


func2(name='Alex', age=42, lastname='Petrov')
func2(name='Alex', age=42)
----
Alex - 42 - Petrov
Alex - 42 - Smirnov
------
- если при вызове функции lastname передан не будет, то будет использован параметр по умолчанию - 'Smirnov'


функция может ничего не возвращать а выполнять какое-то действие (в данном примере - print), а может возвращать результат через return -
--
def sum2(a, b):
	return a + b


x = sum2(a=5, b=10)
print(x)
----
15
------


--
def any_function(a, b):
	result1 = a + b 
	result2 = a - b
		return result1, result2 
		
var1, var2 = any_function(10, 8)
print(var1)
print(var2)
----
18 
2
------


можно указать какого типа должны быть переменные - \
--
def func123(a: int):
	return a*2 
	
	
print(func123(2))
print(func123('hello!'))
----
4
hello!hello!
------
- что-то не работает как задумывалось...


переопределение функции - 
--
def func123(a: int):
	return a*2 
	
	
def func123(a: str):
	return a 
	
	
print(func123(2))
print(func123('hello!'))
----
2
hello!
------
- то есть независимо от типа передаваемых данных используется нижняя функция 


в функцию можно передавать list и dict и вызывать внутри функции другую функцию -
--
def sum2(a, b):
	return a + b
	

def sum3(c):
	return sum2(c, c)
	
	
print(sum3(c=5))
----
- приучить себя передавать в функцию значение только таким образом 


одна функция - одно действие 


не писать цикл в цикле - а писать в цикле функцию которая уже запускает другой цикл 


когда происходит return - функция заканчивает свою работу - 
--
def loop1(end):
	for i in range(1, end+1):
	if i > 5:
		return None 
	print(i)
		
		
loop1(11)
----


функция внутри класса - называется метод 



Домашнее задание:
1. Написать функцию без параметров.
--
def fun():
    print('Fun')

fun()
----



2. Написать функцию с 1 параметром.
--
def fun(x):
    return x**2

a = fun(x=2)
print(a)
----



3. Написать функцию с 3 параметрами.
--
def fun(x, y, z):
    return x + y + z

a = fun(x=2, y=3, z=4)
print(a)
----



4. Написать функцию с 3 параметрами - и последнему параметру задать значение по умолчанию.
--
def fun(x, y, z=5):
    return x + y + z

a = fun(x=2, y=3)
print(a)
----



5. Функцию с 1 параметром вызвать внутри цикла.
--
def fun(x):
	return x**2 

for i in range(1, 4):
	print(fun(x=i))
----



6. Написать функцию с 1 параметром - и в этот параметр передать переменную типа list. Функция должна возвращать сумму всех элементов list, который в неё передали. Возвращать через return - а не просто через print выводить.
--
list1 = [1, 2, 3, 4, 5]

def summ(x):
    summm = 0
    for i in x:
        summm += i
    return summm

a = summ(x=list1)
print(a)
----



7. Вызвать одну функцию внутри другой.
--
def sum2(a, b):
    return a + b


def sum3(c):
    return sum2(a=c, b=c)

    
x = sum3(2)
print(x)
----



8. Прочитать в интернете, что такое сортировка пузырьком. Написать себе на листке алгоритм, после чего написать функцию, которая на вход получает список (list), сортирует его пузырьком, после чего возвращает отсортированный список.
Про сортировку пузырьком теория:
https://ru.wikipedia.org/wiki/Сортировка_пузырьком 

Обращаться к элементу списка можно через квадратные скобки, нумерация с 0
l1 = [1, 2, 3]
print(l1[0])
print(l1[1])
print(l1[2])
Когда будете писать сортировку пузырьком - вам так и надо будет делать.
Получить количество элементов в листе: len(l1)
Если с for не получится - можете использовать цикл while
--
# пузырьковая сортировка

def fun_sort(list1):
    while list1 != sorted(list1):
        for i in range(0, len(list1)-1):
            if list1[i] > list1[i + 1]:
                a = list1[i + 1]
                b = list1[i]
                list1[i] = a
                list1[i + 1] = b
            else:
                continue
    return list1


li1 = [8, 6, 7, 4, 5, 2, 3, 1]
print(fun_sort(list1=li1))
----

*****************************************************************

8 - (6 урок) -
https://youtu.be/IbqWC6OAmb0?si=p4yRztxNK6i2LC1_
-
+ прочитай все комментарии под роликом в youtube 
-
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson6.py
-
Курс "Инженерия данных с 0"
Урок 6.
Python
class
классы, наследование
Таймкоды:
0:00 - рассказываю, что такое классы.
15:00 - метод _init_
16:10 - метод _str_ - как вывести объект через print
18:00 - глобальные переменные и окружение
21:00 - разница между объектом и классом. Объект - это экземпляр класса
24:30 - наследование
26:00 - использование super
31:30 - пример полиморфизма
-


классы и объекты - в одной сущности храним данные и методы работы с ними 

- инкапсуляция 
- наследование 
- полиморфизм 

всегда все обращения к полям внутри объектов осуществляются через self 

метод __init__ вызывать вручную не нужно, он вызывается по умолчанию при создании объекта класса 

--
class Human:
    hands: int
    foots: int
    head: int
    eyes: int
    age: int
    sex: int
    name: str

    def __init__(self, v_name):
        self.name = v_name
        self.hands = 2
        self.foots = 2
        self.head = 1
        self.eyes = 2
        self.age = 33
        self.sex = 1
        self.name = v_name

    # при print(o_vasa) выведет имя - 'Vasa' и возраст - 33
    def __str__(self):
        #   return self.name + ' ' + str(self.age) ==
        #   return '{0} {1}'.format(self.name, str(self.age)) ==
        return f'{self.name} {self.age}'

    def mobilize(self):
        if self.sex == 1:
            self.hands = self.hands / 2
            self.foots = self.foots / 2
            self.eyes = self.eyes / 2

    def see_info(self):
        print(f'name = {str(self.name)}')
        print(f'hands = {str(self.hands)}')
        print(f'foots = {str(self.foots)}')
        print(f'head = {str(self.head)}')
        print(f'eyes = {str(self.eyes)}')
        print(f'age = {str(self.age)}')
        print(f'sex = {str(self.sex)}')


o_vova = Human('Vova')
o_vova.see_info()

o_vasa = Human('Vasa')
o_vasa.see_info()
o_vasa.mobilize()
o_vasa.see_info()

print(o_vasa)


#   наследование -
class Woman(Human):  # наследуем от класса Human
    def __init__(self, v_name='Sveta'):
        super().__init__(v_name)  # - берет self от класса Human
        self.sex = 0
        self.cicle = 20

    # полиморфизм - когда переопределили метод родительского класса -
    def see_info(self):
        super().see_info()
        print(f'cicle = {str(self.cicle)}')


lusa = Woman('Lusa')
lusa.see_info()
# можно отдельно вывести возраст lusa -
print(lusa.age)
# - но если бы класс был не с публичными полями, а с приватными,
# мы бы так не смогли сделать
----

объект - это конкретный экземпляр какого-то класса 



ДЗ:

1. Прочитайте про принципы ООП   https://tproger.ru/translations/oop-principles-cheatsheet
--
Главное
-
Инкапсулируйте все, что может изменяться;
Уделяйте больше внимания интерфейсам, а не их реализациям;
Каждый класс в вашем приложении должен иметь только одно назначение;
Классы — это их поведение и функциональность.

Базовые принципы ООП
-
Абстракция — отделение концепции от ее экземпляра;
Полиморфизм — реализация задач одной и той же идеи разными способами;
Наследование — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
Инкапсуляция — размещение одного объекта или класса внутри другого для разграничения доступа к ним.

Используйте следующее вместе с наследованием
-
Делегация — перепоручение задачи от внешнего объекта внутреннему;
Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;
Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.

Не повторяйся (Don’t repeat yourself — DRY)
-
Избегайте повторного написания кода, вынося в абстракции часто используемые задачи и данные. Каждая часть вашего кода или информации должна находиться в единственном числе в единственном доступном месте. Это один из принципов читаемого кода.

Принцип единственной обязанности
-
Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

Принцип открытости/закрытости
-
Программные сущности должны быть открыты для расширения, но закрыты для изменений.

Принцип подстановки Барбары Лисков
-
Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

Принцип разделения интерфейсов
-
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

Принцип инверсии зависимостей
-
Система должна конструироваться на основе абстракций “сверху вниз”: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.
----



2. Создайте несколько классов - например: человек и т.д.
--
class Humanoid:
    name: str
    age: int

    def __init__(self, name='Jon', age=42):
        self.name = name
        self.age = age

    def see_info(self):
        print(f'name - {self.name}')
        print(f'age - {self.age}')

class Dog:
    name: str
    ves: int

    def __init__(self, name, ves):
        self.name = name
        self.ves = ves

    def say(self):
        print('gav-gav')


jon = Humanoid()
rey = Humanoid('Ray', 42)

jon.see_info()
rey.see_info()

dog = Dog('Bobik', 15)
dog.say()
----


3. От класса человек отнаследуйте класс "ребёнок"
--
class Humanoid:
    name: str
    age: int

    def __init__(self, name='Jon', age=42):
        self.name = name
        self.age = age

    def say(self):
        print('Aaaaaa')

    def see_info(self):
        print(f'name - {self.name}')
        print(f'age - {self.age}')

class Kinder(Humanoid):

    def __init__(self):
        super().__init__(self)

    def say(self):
        print('Uaaaaa')


ken = Kinder()
ken.say()
----



4. Создайте класс "автобус". В автобусе должно содержаться несколько "детей" - например в list.
--
class Bus:
    name: str
    list_kids: list

    def __init__(self, name='Bus', list_kids=[]):
        self.name = name
        self.list_kids = list_kids

bus = Bus(name='Bus_1', list_kids=['Den', 'Roy', 'Jon'])
print(bus.list_kids)
----



Для класса автобус напишите методы добавления ребёнка в автобус, удаления ребёнка из автобуса. 

5. У каждого ребёнка сделайте хранение его текущего местоположения и методы для его изменения/отображения.
--
class Bus:
    name: str
    list_kids: list

    def __init__(self, name='Bus', list_kids=[]):
        self.name = name
        self.list_kids = list_kids

    def f_plus(self, kids_name):
        self.list_kids.append(kids_name)

    def f_minus(self, kids_name):
        self.list_kids.remove(kids_name)


bus = Bus(name='Bus_1', list_kids=['Den', 'Roy', 'Jon'])
print(bus.list_kids)

bus.f_plus('Doddy')
print(bus.list_kids)

bus.f_minus('Jon')
print(bus.list_kids)
----



У автобуса сделайте метод - при вызове которого будет меняться местоположение у всех детей, кто в нём находится на заданное (новое положение передавать в метод изменения положения)
--
- не пойму что нужно сделать и как ...


5. Проявите смекалку - и создайте ещё несколько классов, которые будут содержать переменные других классов и делать что-нибудь забавное.
--
- в задании 2 выше создал класс Dog и с ним уже делал 

*****************************************************************

9 - (7 урок) -
https://youtu.be/dHxtovxQcK8?si=jMa35LEAxfEe5QAt
-
+ прочитай все комментарии под роликом в youtube - +++
-
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson7.py
-
Курс "Инженерия данных с 0"
Урок 7.
Python
class
public, private
Таймкоды:
0:00 - объяснил базу про public, private
10:40 - геттеры и сеттеры
-

--
class Human:
	name: str 
	_password: str
	__age: int
	
	def __init__(self, v_name='Vasa'):
		self.name = v_name
		self._password = '12345'
		self.__age = 30 
		

o_vasa = Human()
print(o_vasa.name)
print(o_vasa._password)
print(o_vasa.__age)
----
- имя и пароль выводятся, а возраст не выводится, выдает ошибку, это специально продумано для безопасности 


всего 3 (три) уровня доступа - 
- public (публичный)     - age (без нижнего подчеркивания)
- protected (защищенный) - _age (одно нижнее подчеркивание)
- private (приватный)    - __age (два нижних подчеркивания )


одно нижнее подчеркивание - это намек на приватность данной переменной (что это поле лучше вне класса не использовать, то есть обращаться к нему только внутри класса, а снаружи не обращаться к нему через точку), операции с этим полем производить можно, но нужно быть аккуратнее - но лучше делать либо вообще без подчеркиваний либо с двумя подчеркиваниями, так как одно подчеркивание лишено смысла 



геттеры и сеттеры -
--
class Human:
	name: str 
	__age: int
	
	def __init__(self, v_name='Vasa'):
		self.name = v_name
		self.__age = 30 
	
	# геттер -
	def get_age(self):   
		return self.__age
		
	# сеттер -
	def set_age(self, v_age: int): 
		if type(v_age) == int:
			self.__age = v_age
		else:
			return 'Error type'
		# - либо так вместо - return 'Error type' - 
		# raise ValueError("Значение должно быть числом")
		

o_vasa = Human()

print(o_vasa.name)
print(o_vasa.get_age())

o_vasa.set_age(55)
print(o_vasa.get_age())
----
Vasa
30
55
------


если поле неприватное, то значение можно задать напрямую - 
--
o_vasa.name = 'Ivan'
----



ДЗ:
1. Посмотрите видео: 
https://youtu.be/RipfqbH0eqY?si=hEiPmUN-as2RH7O2
-(selfedu)
--
from accessify import private, protected


class Point:
    def __init__(self, x=0, y=0):
        self.__x = self.__y = 0
        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y

	#@private -  тогда убрать __ во всех __check_value
    @classmethod
    def __check_value(cls, x):
        return type(x) in (int, float)

    def set_coord(self, x, y):
        if self.__check_value(x) and self.__check_value(y):
            self.__x = x
            self.__y = y
        else:
            raise ValueError("Значение должно быть числом")

    def get_coord(self):
        return self.__x, self.__y


pt = Point(1, 2)
pt.set_coord(10, 20)
print(pt.get_coord())
print(dir(pt))
----
- модуль accessify - pip install accessify - но в 99% случаев достаточно просто двух нижних подчеркиваний 

можно обойти защиту так - 
--
pt._Point__check_value(5)
----



Во всех последующих заданиях используйте только приватные поля, геттеры и сеттеры с проверкой типа вводимых значений:

2. Создайте несколько классов - например: человек и т.д.
--
class Human:
    __name: str
    __age: int

    def __init__(self, v_name='', v_age=0):
        self.__name = v_name
        self.__age = v_age

    def m_set(self, v_name, v_age):
        if type(v_name) == str and type(v_age) == int:
            self.__name = v_name
            self.__age = v_age
        else:
            raise TypeError('Error entering types')

    def m_get(self):
        return self.__name, self.__age


ivan = Human()
ivan.m_set('Ivan', 45)
print(ivan.m_get())
----



3. От класса человек отнаследуйте класс "ребёнок"
--
class Human:
    __name: str
    __age: int

    def __init__(self, v_name='', v_age=0):
        self.__name = v_name
        self.__age = v_age

    def m_set(self, v_name, v_age):
        if type(v_name) == str and type(v_age) == int:
            self.__name = v_name
            self.__age = v_age
        else:
            raise TypeError('Error entering types')

    def m_get(self):
        return self.__name, self.__age


class Kid(Human):

    def __init__(self):
        super().__init__()


vova = Kid()
print(vova.m_get())
----



4. Создайте класс "автобус". В автобусе должно содержаться несколько "детей" - например в list.
Для класса автобус напишите методы добавления ребёнка в автобус, удаления ребёнка из автобуса. 
--
class Bus:

    def __init__(self, name='Bus', list_kids=[]):
        if type(name) == str and type(list_kids) == list:
            self.__name = name
            self.__list_kids = list_kids
        else:
            raise TypeError('Error entring types')

    def m_set(self, name, list_kids):
        if type(name) == str and type(list_kids) == list:
            self.__name = name
            self.__list_kids = list_kids

        else:
            raise TypeError('Error entering types')


    def m_get(self):
        return self.__name, self.__list_kids


    def f_plus(self, kids_name):
        self.__list_kids.append(kids_name)


    def f_minus(self, kids_name):
        self.__list_kids.remove(kids_name)


bus = Bus(name='Bus_1', list_kids=['Den', 'Roy', 'Jon'])
print(bus.m_get())

bus.f_plus('Doddy')
print(bus.m_get())

bus.f_minus('Jon')
print(bus.m_get())
----



5. У каждого ребёнка сделайте хранение его текущего местоположения и методы для его изменения/отображения.
У автобуса сделайте метод - при вызове которого будет меняться местоположение у всех детей, кто в нём находится на заданное (новое положение передавать в метод изменения положения)
- не пойму что нужно сделать и как ...

6. Проявите смекалку - и создайте ещё несколько классов, которые будут содержать переменные других классов и делать что-нибудь забавное.
- уже делал это в задании выше 

*****************************************************************

10 - (8 урок) -
https://youtu.be/UTFatU_R74s?si=1VsFNpSfplkPFKhY
-
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson8.py
-
Курс "Инженерия данных с 0"
Урок 8.
Python
Мастер-класс по работе с классами + учимся обрабатывать ошибки.
Таймкоды:
0:00 - Показываю, как работать с классами.
27:10 - Обработка ошибок
-
+ прочитай все комментарии под роликом в youtube - +++


--
class Human:
    _name: str
    __location: str

    def __init__(self, name='Ivan'):
        self._name = name
        self._location = 'Moscow'

    def get_name(self):
        return self._name

    def get_location(self):
        return self._name + ': ' + self._location

    def set_location(self, location):
        self._location = location


class Kid(Human):
    _age = 5

    def __init__(self, name='Ivan'):
        super().__init__(name)

    def set_age(self, age):
        self._age = age

    def get_age(self):
        return f'{self._name}: {str(self._age)}'


class Bus:
    __kids: list

    def __init__(self, kids: list):
        self.__kids = kids

    def add_kids(self, kids: list):
        self.__kids += kids

    def remove_kids(self, kids: list):
        for one_kid in kids:
            if one_kid in self.__kids:
                self.__kids.remove(one_kid)

    def print_all_kids_location(self):
        for one_kid in self.__kids:
            print(one_kid.get_location())

    def go_to_new_location(self, new_location):
        for one_kid in self.__kids:
            one_kid.set_location(new_location)


# one_human = Human()
# print(one_human.get_location())

# print(one_kid.get_location())
# print(one_kid.get_age())

kid1 = Kid('Jon')
kid2 = Kid('Dan')
kid3 = Kid('Vasa')

one_bus = Bus([kid1, kid2])
one_bus.print_all_kids_location()
print('-------------------')
one_bus.add_kids([kid3])
one_bus.print_all_kids_location()
print('-------------------')
one_bus.remove_kids([kid1, kid2])
one_bus.print_all_kids_location()
print('-------------------')
one_bus.go_to_new_location('Ufa')
one_bus.print_all_kids_location()
----


учимся обрабатывать ошибки - 
--
a = 1/0 
b = Null.get('d')

list1 = [1, 2, 3, 'hello', 5, 6, 7]

def list_division(li: list):
    result_list = list()
    for i in li:
        try:
            result_list.append(i / 2)
        except:
		# except ValueError:    - лучше писать так 
            print('Error')
	continue res_list


res = list_division(list1)
print(res)
----



моё решение без обработки ошибок - 
--
list1 = [1, 2, 3, 'hello', 5, 6, 7]

def list_division(li):
    res_list = list()
    for i in li:
        if type(i) == int or type(i) == float:
            res_list.append(i/2)
        else:
            continue
    return res_list


print(list_division(list1))
----



версия автора - 
--
list1 = [1, 2, 3, 'hello', 5, 6, 7]


def list_division(li: list):
    result_list = list()
    for i in li:
        try:
            result_list.append(i / 2)
        except Exception as e:
            print(e)
        finally:   # - это отрабатывает всегда
            print(i)

    return result_list


res = list_division(list1)
print(res)
----
- Exception - это ошибка в общем виде 


+ прочитать -
https://pythonchik.ru/osnovy/python-try-except?ysclid=lzbch95puu211444654 



ДЗ:

1. Почитать про обработку ошибок:
https://habr.com/ru/companies/wunderfund/articles/736526/
если в этой статье слишком непонятно - тут короче и максимально просто: 
https://metanit.com/python/tutorial/2.11.php

2. Посмотреть список самых популярных исключений (хотя бы 1 раз все прочитать): https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html

3. Создать классы: человек, рота, полк. В роте могут содержаться несколько человек, в полку - несколько рот.
Написать методы:
- добавления человека в роту, добавления роты в полк.
- удаления человека из роты или из полка (в этом случае, человек удалиться из роты). Метод на вход должен получать list с несколькими переменными типа Human - как я с автобусом делал.
- выводить информацию об одном человеке: имя, возраст.
- выводить информацию об всех людях в роте.
- выводить информацию об всех людях в полку.

4. Для всех методов из п.3 использовать обработку исключений. Можно не обрабатывать отдельные исключения - достаточно общего через просто Except.

Добиться, чтобы сработало исключение - и обработалось через except.

тут сам пробовал работать с классами по своему - 
--
class Hum:
    __name: str
    __age: int

    def __init__(self, name='', age=0):
        self.__name = name
        self.__age = age

    def sset(self, name, age):
        self.__name = name
        self.__age = age

    def gget(self):
        return f'name - {self.__name}, age - {self.__age}'


class Um(Hum):
    def __init__(self):
        super().__init__()



ch = Hum()
ch.sset('Jon', 22)
print(ch.gget())

ch2 = Um()
ch2.sset('Bob', 30)
print(ch2.gget())
----
name - Jon, age - 22
name - Bob, age - 30
------


тут сам пробовал работать с исключениями по своему - 
--
def de(a, b):
    try:
        return a/b
    except Exception as e:
        return e

print(de(10, 0))
----


на ДЗ от автора, всё сделал только не удаляется человек из роты если удаляешь его в полку, но удаляется если удаляешь его через метод для роты -
--
class Sol:
    _name: str
    _age: int

    def __init__(self):
        try:
            self._name = ''
            self._age = 0
        except Exception as e:
            print(e.__class__)

    def set_m(self, name, age):
        try:
            self._name = name
            self._age = age
        except Exception as e:
            print(e.__class__)

    def get_m(self):
        try:
            return self._name, self._age
        except Exception as e:
            print(e.__class__)


sol1 = Sol()
sol1.set_m('Jon', 23)
print(sol1.get_m())

sol2 = Sol()
sol2.set_m('Roy', 45)
print(sol2.get_m())
print('---')


class Rota:
    _sp1: list

    def __init__(self):
        self._sp1 = list()

    def set_m(self, sp):
        try:
            for i in sp:
                self._sp1.append(i.get_m())
        except Exception as e:
            print(e.__class__)

    def get_m(self):
        try:
            return self._sp1
        except Exception as e:
            print(e.__class__)

    def del_m(self, ch):
        try:
            if ch in self._sp1:
                self._sp1.remove(ch)
        except Exception as e:
            print(e.__class__)


rota1 = Rota()
rota2 = Rota()

rota1.set_m([sol2])
print(rota1.get_m())

rota2.set_m([sol1, sol2])
print(rota2.get_m())
print('---')


class Polk(Rota):
    _sp1: list

    def __init__(self):
        try:
            super().__init__()
            self._sp1 = list()
        except Exception as e:
            print(e.__class__)

    def set_m(self, sp):
        try:
            for i in sp:
                self._sp1 += i.get_m()
            self._sp1 = list(set(self._sp1))
        except Exception as e:
            print(e.__class__)


polk1 = Polk()
polk1.set_m([rota1, rota2])
print(polk1.get_m())
polk1.del_m(sol2.get_m())
print(polk1.get_m())
----



*****************************************************************

11 - (9 урок) -
https://youtu.be/g16YY7o5PIw?si=Zc1TLNxFceI29pFx
-
http://gitlab.digitalberd.com/Berd/data_egineering_lessons/-/blob/master/Lesson9.py
-
Курс "Инженерия данных с 0"
Урок 9.
pip install
import
Таймкоды:
0:00 - Импортируем тип datetime
6:10 - Устанавливаем pandas
9:20 - Запускаем файл через terminal
10:45 - Устанавливаем библиотеку при помощи pip через терминал
14:00 - Как использовать самописные библиотеке/пакеты
19:20 - Импортируем только необходимый класс
22:00 - Для чего нужен файл __init__.py в пакете.
23:20 - Импортируем различные классы и функции.
30:00 - Планы на будущие занятия. GIT
-
+ прочитай все комментарии под роликом в youtube - +++


в python много стандартных библиотек(устанавливаются с интерпретатором) и много сторонних библиотек

--
import datetime 

d_one = datetime.datetime.utcnow()

print(d_one)
print(type(d_one))
----
2024-08-03 16:05:09.138641
<class 'datetime.datetime'>
------

когда нужно использовать незнакомую библиотеку - нужно нагуглить её документацию -
pip django 
- выведет на сайт пипа и там будет библиотека и документация к ней 

посмотреть установленные в проект библиотеки -
PyCharm - File - Settings - Project:... - Python Interpreter 

там можно нажать + и через поиск по названию библиотеки найти её и установить(можно выбрать конкретную версию внизу справа - Specify version), но лучше вручную через pip в терминале -
--
pip install pandas 
----


если нужна конкретная версия - 
--
pip install pandas==1.0.0
----


основные команды pip для python - 
https://habr.com/ru/companies/productstar/articles/826732/


проверить версию pip -
--
pip --version
----


посмотреть установленные библиотеки - 
--
pip list 
----


запустить файл через терминал - 
--
python main.py 
----


на linux нужно указывать версию при запуске - 
pip3 ...
python3 ...

если библиотеки нет на сервере pip - такие библиотеки лучше не использовать 

можно написать свою библиотеку (модуль) -
File - New - Python Package - ввести название (например Utils)

Python понимает что это пакет так как внутри него есть файл - 
__init__.py 

теперь создадим в нем файл с кодом - utils1.py 
--
utils1.py
--
class Hum:
	age: int 
	name: str 
	
	
	def __init__(self, name='Ivan'):
		self.name = name 
		self.age = 20 
		
		
	def say_hello(self):
		print('Hello, world!')	
----

если что-то нужно без проблем импортировать - положи это в корень проекта, такой себе совет, но для новичков сойдет 

--
main.py
--
import datetime 
import pandas 

from Utils.utils1 import Hum 
#  from Utils.utils1 import Hum as h   - можно через псевдоним
#  from Utils import utils1 
#  import Utils.utils1 

on_hum = Hum()
#  on_hum = h()
#  on_hum = utils1.Hum()
#  on_hum = Utils.utils1.Hum()
on_hum.say_hello()
----
Hello, world! 


импортировать можно как класс так и функцию 


в чем отличие метода от функции - метод находится внутри класса, а функция нет 



ДЗ:

1. Импортировать datetime. Вывести на экран текущее время. Потом вывести, какое время было час назад (нагуглить, как часы из времени вычитать)
--
import datetime

d_time = datetime.datetime.utcnow()
d_time_moscow = datetime.datetime.today()
print(d_time)
print(d_time_moscow)
# - также вывел текущее время по Москве

d_minus_1_hour = d_time - datetime.timedelta(hours=1)
print(d_minus_1_hour)

d_minus_1_hour_moscow = d_time_moscow - datetime.timedelta(hours=1)
print(d_minus_1_hour_moscow)
----

2. Установить себе библиотеку pandas через терминал и pip. Можете в видосе посмотреть, как я это делал.
--
pip install pandas 
----

3. Из предыдущего задания - классы с людьми, ротами, полками - запихнуть в один пакет (можете в видосе посмотреть, как я пакет создавал) 
-
- создать папку Rota-polk 
- в этой папке создать пустой файл __init__.py 
- создать в этой папке файл polk_rota.py классами Sol, Rota, Polk -
--
from datetime import datetime


class Sol:
    _name: str
    _age: int
    _da: None

    def __init__(self):
        try:
            self._name = ''
            self._age = 0
            # self._date_age =
        except Exception as e:
            print(e)
            print(e.__class__)

    def set_s(self, name, age, date):
        try:
            if isinstance(date, datetime):
                self._name = name
                self._age = age
                self._da = date
            else:
                raise ValueError("date must be a datetime object")
        except Exception as e:
            print(e)
            print(e.__class__)

    def get_s(self):
        try:
            return self._name, self._age, self._da.strftime('%d-%m-%Y')
        except Exception as e:
            print(e)
            print(e.__class__)


class Rota:
    _sp: list

    def __init__(self):
        self._sp = list()

    def set_r(self, sp):
        try:
            for i in sp:
                self._sp.append(i.get_s())
        except Exception as e:
            print(e)
            print(e.__class__)

    def get_r(self):
        try:
            return self._sp
        except Exception as e:
            print(e)
            print(e.__class__)

    def del_r(self, ch):
        try:
            if ch in self._sp:
                self._sp.remove(ch)
        except Exception as e:
            print(e)
            print(e.__class__)


class Polk(Rota):
    _sp: list

    def __init__(self, sp=[]):
        try:
            self._sp = sp
        except Exception as e:
            print(e)
            print(e.__class__)

    def set_p(self, *sp):
        try:
            for i in sp:
                    self._sp += i


        except Exception as e:
            print(e)
            print(e.__class__)

    def get_p(self):
        try:
            return self._sp
        except Exception as e:
            print('polk get', e)
            print(e.__class__)

    def del_p(self, ch):
        try:
            if ch in self._sp:
                self._sp.remove(ch)
        except Exception as e:
            print('polk del ',e)
            print(e.__class__)
----


и файл main.py - 
--
from datetime import datetime
import Polk_rota.polk_rota as srp


oh1 = srp.Sol()
oh1.set_s('Jon', 23, datetime(2000, 1, 1))
print(oh1.get_s())

oh2 = srp.Sol()
oh2.set_s('Bob', 33, datetime(2001, 11, 2))
print(oh2.get_s())

oh3 = srp.Sol()
oh3.set_s('Rey', 40, datetime(2002, 10, 3))
print(oh3.get_s())

oh4 = srp.Sol()
oh4.set_s('Sam', 35, datetime(2003, 11, 4))
print(oh4.get_s())

rota1 = srp.Rota()
rota1.set_r([oh1, oh2])
r1 = rota1.get_r()
print(r1)

rota2 = srp.Rota()
rota2.set_r([oh3, oh4])
r2 = rota2.get_r()
print(r2)

print('Polk')
polk1 = srp.Polk()
polk1.set_p(r1, r2)
print(polk1.get_p())
polk1.del_p(oh1.get_s())
print(polk1.get_p())

rota1.del_r(oh1.get_s())
r1 = rota1.get_r()
print(r1)
----


4. Написать код добавляющий людей в роты, роты в полки - при том, что сами классы с ротами, людьми, полками импортировать из пакета.
- файл main.py выше 

5. Людям добавить дату рождения - типа datetime
- сделал в 2-х файлах выше 

*****************************************************************

12 - (10 урок) -
https://youtu.be/0DqD0n7ri8Y?si=gOAiy6hkbUti_OXr
-
https://github.com/berd90/data_engineering_lessons_github
-
Курс "Инженерия данных с 0"
Урок 10.
Python
GIT
Системы контроля версий.
Таймкоды:
0:00 - вопросы по предыдущему материалу - import from
3:25 - пара слов про Virtual ENV
8:25 - системы контроля версий - история
11:00 - сравнение систем контроля версий
11:05 - GitHub
13:00 - GitLab
15:05 - BitBucket
16:25 - self hosted - хорошо
20:50 - Private, public репозетории
22:00 - Создаём новый репозеторий
25:10 - Клонируем репозеторий к себе на компьютер
28:20 - Логинимся в GitHub
30:00 - Локальный и удалённый репозеторий
33:00 - Пушим в удалённый репозеторий
34:30 - Что такое Commit
36:50 - Для чего пушить коммиты в удалённый репозеторий.
38:00 - Начинаем работать с ветками
51:00 - Как работать в одном репозитории большой командой
-
+ прочитай все комментарии под роликом в youtube - +++


при импорте можно импортировать библиотеку или конкретный файл, или классы, функции, переменные из файла - 
--
import math
import pandas as pd 
import Polk_rota.polk_rota
from Polk_rota.polk_rota import Rota, Polk
from Utils.global_config import USER_NAME 


r1 = Rota()
print(r1.get_r())
----


автор рассказал про виртуальное окружение - venv или свое название - можно ставить свой версии интерпретаторов и библиотек независимо от глобальных установок, то есть на одной машине можно использовать разные версии интерпретатора и библиотек 

автор рассказал про Git, GitHub, GitLab 

лучше выкладывать проекты в GitLab, он надежнее, и на GitLab можно сделать закрытый репозиторий

для развертывания проекта в GitLab нужно минимум 2Gb оперативной памяти ему выделить, и он их будет постоянно занимать, то есть если 4Gb то фактически останется только 1 или 2, а остальное будет постоянно занимать сервер GitLab 

еще есть Bitbucket, он типа GitHub-а

автор говорит что облака не надежны 

автор рассказал как создать новый пустой репозиторий на GitHub 

когда делаешь на GitHub новый репозиторий - всегда делай README файл (ставь галочку)

установить Git на компьютер 

залогинится на GitHub 

репозиторий на GitHub и папка проекта в PyCharm не должны называться одинаково 

PyCharm - Git (в верхнем меню) - Clone - GitHub - залогинится на GitHub - выбрать репозиторий который нужно склонировать 

если не грузит - то в пункте выше можно загрузить по ссылке с GitHub 

создадим новый файл в новом проекте

красный - не добавлен 
зеленый - добавлен 
белый - закоммичен

добавить файл в репозиторий - Git - Selected file - Add

Git - Commit - фиксируем изменения 

Git - Push - отправляем изменения в удаленный репозиторий 

можно сделать несколько commit а потом push 

откатить изменения - на файле ПКМ - Git - Rollback 

самому изучить (вспомнить) - ветки в Git - как сливал main и deploy 

PyCharm - в нижнем правом углу название текущей ветки - там можно создать новую ветку и переключаться между ветками 

PR - сливает рабочую ветку с веткой main 

конфликт версий - как решить 

перед началом работы обновить ветку main - Git - Update Project 

рассказал про монолит и микросервисы 

Scrum, Agile - работа спринтами по 1-2 недели 

название репозитория в GitHub изменить нельзя 



ДЗ:
1. Зарегистрироваться на GitHub: https://github.com/
2. Создать новый репозиторий (обязательно посмотрите в видео, как это нормально сделать)
3. Склонировать репозиторий себе в PyCharm
4. Внести изменения в код.
5. Запушить изменения.
6. Посмотреть, что всё обновилось в репозетории на сайте GitHub.
7. Создать новую ветку.
8. Внести изменения в ветку и закоммитить -> запушить эти изменения
9. Убедиться, что в master ветке в удалённом репозитории изменений нет.
10. Создать Pull request на слияние второй ветки и master.
11. Смерджить изменения.
12. У себя на компьютере переключиться обратно на ветку master
13. У себя на компьютере обновить изменения в master ветке: GIT -> update project (merge)



Установить git из PyCharm:
1. File - Settings  - Version Control - Git
2. Нажимаем сверху Test, появится сверху надпись "Git not found"  "Install Git", нажимаем установить
3. После установки в поле Path указываем "C:\Users\%username%\AppData\Local\Programs\Git\bin\git.exe"  и нажимаем Test
    %username% - не всегда распознаёт, поэтому заменить на имя своего пользователя
4. Далее в верхнем меню нажать VCS - Enable Version Control Integration - Git - ok


нету вкладки GIT(он установлен на пк), чтоб сделать клон пошел в VSC в Get from version control. Оттуда создал клон проекта. Комитить пришлось по горячим клавишам (благо видно было какие горячие клавиши нажимать). Проблема появления вкладки GIT даже после прочтения документации остались загадкой. Дальше надо создать branch, делаю и ловлю ошибку на ошибке... У меня не хило так пригорело ибо ветку он в гит добавил, а main ветку он по кой то причине почистил. И вот после пары повторений, каким то чудом вкладка GIT появилась, да ля как оно работает... В других проектах она все так же отсутствует. 

*****************************************************************

13 - (11 урок) -
https://youtu.be/gLrMrd_780I?si=WFQgEu9ijMK0U9Dg
-
https://github.com/berd90/data_engineering_lessons_github/tree/main
- там найти 11 урок 
-
Курс "Инженерия данных с 0"
Урок 11.
Python
В каких форматах файлов удобно хранить данные в каких случаях.
YAML
JSON
CSV
Таймкоды:
0:00 - В каких форматах какие данные лучше хранить
0:40 - YAML
9:35 - JSON
19:12 - CSV, pandas
25:20 - вопрос по 10 уроку, GIT
29:40 - вопрос про индексы в CSV, pandas
34:25 - GitHub как изменить private publiс видимость репозитория
-
+ прочитай все комментарии под роликом в youtube - +++


в каких форматах хранят файлы - YAML, JSON, CSV 

YAML - для хранения конфигов, вложенные словари и списки 

расширения файлов - .yaml и .yml - это одно и то же 

чтобы работать с YAML нам нужно его установить через терминал - 
--
pip install pyyaml 
----


--
# pip install pyyaml - НЕ ЗАБУДЬ УСТАНОВИТЬ

import yaml 


# write 
l_connections = [
	{
		'user_name': 'etl_user',
		'password': '123'
	}, 
	{
		'user_name': 'test_user',
		'password': '456'
	}
]


# если не прописывать путь к файлу то он сохранится 
# в текущую папку -  
# with open(r'C:\data\store_file.yaml', 'w') as file:
with open(r'store_file.yaml', 'w') as file:
	documents = yaml.dump(l_connections, file)
	
	
###
# reading 
with open(r'store_file.yaml') as file:
	fruits_list = yaml.load(file, Loader=yaml.FullLoader)


print(fruits_list)
print(type(fruits_list))
----
[{'password': '123', 'user_name': 'etl_user'}, {'password': '456', 'user_name': 'test_user'}]
<class 'list'>
------



JSON - используется для передачи данных между backend и frontend 
--
import json


# data to be written -
dictionary = {
    'name': 'sajinkor',
    'rolno': 56,
    'cdpa': 8.6,
    'prometeus': '994758639'
}

# serializing json -
json_object = json.dumps(dictionary, indent=4)

# writing to sample.json
with open('sample.json', 'w') as outfile:
    outfile.write(json_object)

# то же самое но с использованием библиотеки json -
# with open('sample.json', 'w') as outfile:
# 	 json.dump(dictionary, outfile)

# reading
# opening json file -
with open('sample.json', 'r') as outfile:
    # reading from json file -
    json_object = json.load(outfile)

print(json_object)
print(type(json_object))
----
{'name': 'sajinkor', 'rolno': 56, 'cdpa': 8.6, 'prometeus': '994758639'}
<class 'dict'>
------

json тип data не воспринимает, всегда писать дату в виде строки(str) 



CSV формат - DE его любят - с этим форматом удобно работать через pandas 

--
import pandas as pd 


l_connections = [
	{
		'user_name': 'etl_user',
		'password': '123',
		'host': '127.0.0.1'
	}, 
	{
		'user_name': 'test_user',
		'password': '456',
		'host': '127.0.0.1'
	}
]


df1 = pd.DataFrame(l_connections)
print(df1)
print(type(df1))


# сохраним в csv файл -
df1.to_csv('from_pandas.csv')

# если не нужно выводить индексы, то так -
df1.to_csv('from_pandas.csv', index=False)

# прочитаем файл - 
df2 = pd.read_csv('from_pandas.csv')
print(df2)
print(type(df2))
----
   user_name password       host
0   etl_user      123  127.0.0.1
1  test_user      456  127.0.0.1
<class 'pandas.core.frame.DataFrame'>

   user_name  password       host
0   etl_user       123  127.0.0.1
1  test_user       456  127.0.0.1
<class 'pandas.core.frame.DataFrame'>
------

можно настроить чтобы в csv разделителем была не запятая, а точка с запятой 

на сервере linux работать с git с помощью команд 



CI/CD - что это? - 

CI/CD — это подход в разработке программного обеспечения, который помогает командам быстрее и качественнее выпускать новые версии своих приложений.

CI (Continuous Integration) — это непрерывная интеграция. Это процесс, при котором разработчики регулярно (несколько раз в день) объединяют свои изменения в общий код. Каждый раз, когда изменения добавляются, автоматически запускаются тесты, чтобы убедиться, что всё работает правильно. Это помогает находить и исправлять ошибки на ранних стадиях.

CD (Continuous Delivery или Continuous Deployment) — это непрерывная доставка или развертывание. В случае непрерывной доставки, после успешного тестирования, изменения автоматически подготавливаются для выпуска, но сами изменения могут быть выпущены вручную. В случае непрерывного развертывания, изменения автоматически выкладываются в продуктивную среду без ручного вмешательства, если все тесты пройдены.

Вместе CI/CD помогают командам быстрее реагировать на изменения, улучшать качество кода и снижать риски при выпуске новых версий.

*********

ДЗ:

1. Почитать про YAML формат: https://ru.wikipedia.org/wiki/YAML
+
2. Почитать про JSON формат: https://habr.com/ru/articles/554274/
+
3. Создать класс, в классе хранить лист словарей (как у меня в коде пример с подключениями - можете придумать что-нибудь своё, например в словарях данные людей будут или ещё что-нибудь)
--
class Humans:

    _hum: list

    def __init__(self, hum):
        self._hum = hum

li1 = [
    {'name': 'Jon', 'age': 24, 'city': 'London' },
    {'name': 'Bob', 'age': 45, 'city': 'Dallas'},
]

hum1 = Humans(li1)
print(hum1._hum)
----


4. Сделать 2 метода для работы с YAML - для сохранения в файл и для чтения из файла. Название фала должно передаваться в метод входным параметром.

5. Сделать 2 метода для работы с JSON - для сохранения в файл и для чтения из файла. Название фала должно передаваться в метод входным параметром.

6. В другом поле хранить Pandas DataFrame с данными. Написать ещё 2 метода - для сохранения данных в файл .csv и для чтения данных из .csv файла в датафрейм.

Так же написать для 4, 5, 6 пунктов методы, которые будут просто отображать данные, которые внутри объекта хранятся.

7. Попробовать при помощи объекта класса прочитать данные из YAML формата, а сохранить - в JSON.

8. Наоборот: прочитать данные из JSON, сохранить в YAML.
----
import yaml
import json
import pandas as pd


class Humans:
    _hum: list

    def __init__(self, hum):
        self._hum = hum

###

    def writh_yaml(self, file_name, znach):
        with open(f'{file_name}.yaml', 'w') as f:
            yaml.dump(znach, f)

    def read_yaml(self, file_name):
        with open(f'{file_name}.yaml') as f:
            return yaml.load(f, Loader=yaml.FullLoader)

###

    def writh_json(self, file_name, znach):
        with open(f'{file_name}.json', 'w') as f_1:
            json.dump(znach, f_1)

    def read_json(self, file_name):
        with open(f'{file_name}.json', 'r') as f_1:
            return json.load(f_1)

###

    def writh_csv(self, file_name, znach):
        df1 = pd.DataFrame(znach)
        df1.to_csv(f'{file_name}.csv')

    def read_csv(self, file_name):
        return pd.read_csv(f'{file_name}.csv')

###


li1 = [
    {'name': 'Jon', 'age': 24, 'city': 'London'},
    {'name': 'Bob', 'age': 45, 'city': 'Dallas'},
]

hum1 = Humans(li1)
#print(hum1._hum)

# create yaml file -
#hum1.writh_yaml('yyy001', li1)

# read yaml file and view yaml file -
#x = hum1.read_yaml('yyy001')
#print(x)



# create json file -
#hum1.writh_json('jjj001', li1)

# read json file and view json file -
# x = hum1.read_json('jjj001')
# print(x)



# create csv file -
#hum1.writh_csv('csv001', li1)

# read csv file and view csv file -
# x = hum1.read_csv('csv001')
# print(x)



# x = hum1.read_yaml('yyy001')
# hum1.writh_json('jjj002', x)

# x2 = hum1.read_json('jjj001')
# hum1.writh_yaml('yyy002', x2)
----


with обыгрывает open/close, т.е. принудительно закрывать файл/подключение не придется

*****************************************************************

14 - (12 урок) -
https://youtu.be/2pGLLj8aAI4?si=CofAObfAHJzf2KwZ
-
https://github.com/berd90/data_engineering_lessons_github/blob/main/Lesson12.py 
-
Курс "Инженерия данных с 0"
Урок 12.
Python
requests
REST API
GET
Таймкоды:
0:00 - дисклеймер
1:30 - начинаем с практики - смотрим как в браузере идут запросы
6:40 - что такое API
7:35 - сетевое взаимодействие между браузером и сервером
11:40 - ответ от сервера, пробуем requests на python
15:20 - пара слов, как работает бекенд
18:52 - получаем курсы валют
33:40 - вопросы после занятия
35:20 - откуда берутся данные, получаемые в результате запроса
40:50 - передача параметров через строку
43:24 - пожелания
45:15 - почему пока не лезем в API гугла
-
+ прочитай все комментарии под роликом в youtube - +++


Client (браузер) - REST API - DataBase

сейчас рассмотрим только эту часть - 
Client (браузер) - REST API - ...
- запросы:
get - получение в чистом виде 
post - обновление и/или получение
put - используются очень редко 
delete - удаление 

типы HTTP-запросов и философия REST - 
habr.com/ru/articles/50147/

сайт автора - 
robotfastapi.digitalberd.com/docs#/
- сейчас не работает 

API - это интерфейс для взаимодействия с сервером 

get - бывает без параметров а бывает с параметрами 


--
import requests 


#URL = f"https://www.googleapis.com/oauth2/v3/userinfo"
##print(URL)
##Блок Header - необходим, чтобы залогиниться 
#token = ""
#headers_param = {"Authorization": f"Bearer {token}"}
#r = requests.get(url=URL, headers=headers_param)
#result = r.json() 


URL = f'https://robotfastapi.digitalberd.com'
r = requests.get(url=URL)
result = r.json() 

if r.status_code == 200:
	print(result)
	print(type(result))
	print(r)
	print(r.text)
	print(r.status_code)
	print(result.get('data'))
else:
	print('was error')
----

полученный json можно распарсить как словарь (dict) -
--
print(result.get('data'))
----

гуглить - 
курсы валют открытое api (чтобы отдавал в json)

currencylayer.com/signup/
- нужны платежные данные или нет? 

или еще посмотреть здесь - 
https://habr.com/ru/articles/537784/

--
import requests  

# api автора - 
api_key = '1bbd0e4feae573037172783bf5a5ac2b'

curr = 'USD, GBP, EUR'
start_date = '2022-03-01'
end_date = '2022-04-01'

URL = f'http://api.currencylayer.com/change?access_key={api_key}&currencies={curr}&start_date={start_date}&end_date={end_date}'

r = requests.get(url=URL)
result = r.json()
print(result)

print(result.get('quotes').get('USDRUB'))
print(result.get('quotes').get('USDGBP'))
print(result.get('quotes').get('USDEUR'))
----

далее объясняет что такое IP-адрес и порт - 
IP-адрес - это адрес конкретного компьютера в сети 
порт - как переменная, куда данные записывает компьютер, и клиент так же может читать эти данные и т.д. 

то есть на сервере с одним IP-адресом может быть несколько сайтов (сервисов, работающих программ, приложений), и у каждого будет свой порт 

DNS - когда приходишь на него с текстового адреса - перенаправляет на IP-адрес и порт - примерно так - 
site.com > 234.432.0.1:8080

посмотреть как работает метод класса - CTRL + ПКМ по названию метода

еще можно по погоде сделать

api google - очень сложно настроить доступ  

*********

ДЗ:

1. Доделать предыдущее ДЗ - чтобы все пункты работали.

2. Попробовать зарегистрироваться на сайте с курсами валют. Возможно, стоит поискать другие похожие сайты, раз на этом так стало...

3. Вместо моего ключа подставить свой - код можно взять у меня в проекте - но лучше напрограммируйте вручную - чтобы запомнить, что делать надо.

4. Получить курс рубля к доллару и евро к доллару за каждый день ноября 2023 года - и записать в 1 csv файл в 3 колонки:
Дата - Валюта - Курс к доллару
--
import time
import requests
import pandas as pd


# api автора -
api_key = '1bbd0e4feae573037172783bf5a5ac2b'
curr = 'RUB, EUR'
li1 = []

for i in range(1, 31):
    time.sleep(5)
    if len(str(i)) > 1:
        dat = '2023-11-' + str(i)
    else:
        dat = '2023-11-0' + str(i)
    start_date = dat
    end_date = dat

    URL = f'http://api.currencylayer.com/change?access_key={api_key}&currencies={curr}&start_date={start_date}&end_date={end_date}'
    r = requests.get(url=URL)
    res = r.json()
    # print(res)

    di1 = {'data': res.get('start_date'), 'tiker': 'USDRUB', 'kurs': res.get('quotes').get('USDRUB').get('start_rate')}
    li1.append(di1)
	
    di2 = {'data': res.get('start_date'), 'tiker': 'USDEUR', 'kurs': res.get('quotes').get('USDEUR').get('start_rate')}
    li1.append(di2)


class Humans:
    _hum: list

    def __init__(self, hum):
        self._hum = hum

    def writh_csv(self, file_name, znach):
        df1 = pd.DataFrame(znach)
        df1.to_csv(f'{file_name}.csv')


hum1 = Humans([])

# create csv file -
hum1.writh_csv('csv001', li1)
----

*****************************************************************

15 - (13 урок) -
https://youtu.be/sa5XoChyAoI?si=L_JRJxHR2nnzHIgy
-
https://github.com/berd90/data_engineering_lessons_github/blob/main/Lesson13.py
-
Курс "Инженерия данных с 0"
Урок 13.
Python
requests
POST
Что даст изучение Python и SQL
Какие профессии открываются:
- аналитик данных
- инженер данных
- тестировщик
- девопс (нужно доучиваться)
- бекендер (нужно доучиваться)
- дата сайнтист (нужно доучиваться)
Таймкоды:
0:00 - Проверяем ДЗ
2:13 - Сколько запросов в секунду может переварить бекенд
4:00 - Подводим итоги по Python 
5:52 - POST запросы - как передавать данные
26:24 - Отладились
29:45 - Работаем с данными через Python
39:50 - Откуда я это всё знаю
-
+ прочитай все комментарии под роликом в youtube - +++

переменные окружения в linux - 
https://wiki.merionet.ru/articles/peremennye-okruzheniya-v-linux-kak-posmotret-ustanovit-i-sbrosit

--
import requests 
import json 


# set up the URL 
url = 'https://api.example.com/endpoint'

# set up the headers 
headers = {
	'Content-Type': 'application/json',
	'Authorization': 'Bearer your_token'
}

# set up the request body 
playload = {
	'name': 'John Doe',
	'email': 'johndoe@example.com',
	'age': 30
}
json_payload = json.dumps(payload)

# make the POST request 
response = requests.post(url, headers=headers, data=json_payload)

# check the response 
if response.status_code == 200:
	print('Request successful!')
	print(response.json())
else:
	print('Request failed!')
	print(response.text) 
----
- когда пишем post-запрос то данные передаем либо в блок headers либо в блок body (тут - data) -
--
...
response = requests.post(url, headers=headers, data=json_payload)
...
----

get-запрос - пишет всё в адресную строку (больше 4000 символов в адресную строку запихнуть не получится ни при каких условиях)

смотреть запрос - F12 - Network 

найти api с открытыми post-запросами - google - 
open api with post requests 

delet-запросы - как get-запросы - то есть параметры можно передавать прямо в строку 

работа с данными на python - 

- инженер данных - библиотека requests + AirFlow + работа с БД 

- аналитик данных - библиотека requests + AirFlow + работа с БД + matplotlib + pandas(из одной таблицы сделать один датафрейм, из второй сделать другой, смержить их и получить нужные данные и т.п.)

инженеры данных перекидывают данные из одной БД в другую - Clickhous - PostgreSQL - MySQL и т.п., получили курсы валют от api - тоже записали в БД, то есть инженер данных - это тот, кто данные подготавливает (чтобы данные были всегда доступны и очищенны)

очистка данных - в 99% случаев - это скрипты на SQL 

не зная SQL - инженером данных не стать 

в машинное обучение стоит вкатываться набив руку 1-2 года в инженерии данных или в аналитике данных 

на 2024 - БД Oracl - используется только в банках и в SAP 

сейчас BI-системы малофункциональны 

>>>

PySpark - библиотека python для работы с BigData, когда pandas не справляется 

PySpark — это API фреймворка Apache Spark с открытым исходным кодом на языке Python. Сам же фреймворк Apache Spark написан на Scala и Java

Pyspark. Анализ больших данных, когда Pandas не достаточно - 
https://habr.com/ru/articles/708468/

Руководство по PySpark для начинающих - 
https://pythonru.com/biblioteki/pyspark-dlja-nachinajushhih

Apache Spark и PySpark - 
https://bigdataschool.ru/wiki/pyspark

PySpark Учебник для начинающих: учитесь на ПРИМЕРАХ - 
https://www.guru99.com/ru/pyspark-tutorial.html

<<<

сейчас нет инженерии данных без AirFlow, сейчас на нем живет вся инженерия данных 

вывод - в будущем нужно работать с БАЗАМИ ДАННЫХ - это будет всегда востребовано 

в любой организации должен быть специалист по БД (1-3 минимум)

администраторы БД сейчас частично эволюционировали в devops(это то же самое, но с автоматизацией)

90% DS и ML - сейчас на python 

все хотят стать бэкендерами - но на python на бэкэндера очень большая конкуренция и устроиться практически нереально 

***

ДЗ - 

сделать полностью ДЗ после 12 урока.

Так это и есть задание после 12 урока - настроить выгрузку информации о курсах валют и о погоде - про погоду он же ничего не задавал...

названия валют и названия городов читать из yaml файлов.

- как на python написать вывод погоды через api ?

*****************************************************************

16 - (14 урок) -
https://youtu.be/sa5XoChyAoI?si=L_JRJxHR2nnzHIgy
-
https://github.com/berd90/data_engineering_lessons_github/blob/main/Lesson14.py
-
Курс "Инженерия данных с 0"
Урок 14.
Python
Код ревью большого домашнего задания
-
+ прочитай все комментарии под роликом в youtube - +++


в .venv при установке библиотек в виртуальное окружение лучше писать через команды в терминале


в корневой папке проекта создать файл - 
requirements.txt 
- в него мы будем писать все библиотеки, которые будем использовать
--
requirements.txt 
--
pandas==1.5.0
pyyaml 
----
- и можно указывать конкретную версию библиотеки 


через терминал выполнить - 
--
pip install -r /path/to/requirements.txt
----
или так -
--
pip install -r ./requirements.txt
----

в корневой папке проекта нужно создать папку - config - и уже в ней размещать все yaml-файлы

в названии директорий(папок) - пробелы НЕ ИСПОЛЬЗОВАТЬ, использовать нижнее подчеркивание 
 
ненужный код - не комментировать а удалять 

если папки из которых импортируешь, находятся на разных уровнях, то сделать так - 
--
import sys 
sys.path.append("..")

from config.global_config import API_KEY
...
----

когда происходит ошибка, то делать так - 
--
...
	except Exception as e:
		print(e)
...
----

назавние файлов - без заглавных букв с нижними подчеркиваниями 

названия классов - с заглавной буквы 

для логирования ошибок - использовать библиотеку logining (как то так называется, но не точно...)

***

ДЗ - 
переделать ДЗ после 12 урока - с учётом того, что я на 14-м рассказывал.

+

гуглить - 
как делать логининг в python 
>>>
В Python для логирования используется встроенный модуль logging, который предоставляет гибкие возможности для настройки и использования логов.

Основные шаги для настройки логирования

1. Импорт модуля:
Сначала необходимо импортировать модуль logging -
--
import logging
----

2. Настройка логирования:
Вы можете настроить уровень логирования, формат сообщений и другие параметры. Например, можно установить уровень логирования на DEBUG, чтобы получать все сообщения, начиная с уровня DEBUG и выше - 
--
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')
----
В этом примере:
- level=logging.DEBUG устанавливает уровень логирования.
- format задает формат сообщений, где %(asctime)s — время, %(levelname)s — уровень логирования, а %(message)s — само сообщение.

3. Использование логирования:
После настройки вы можете использовать различные уровни логирования для записи сообщений:
--
logging.debug("Это отладочное сообщение.")
logging.info("Это информационное сообщение.")
logging.warning("Это предупреждающее сообщение.")
logging.error("Это сообщение об ошибке.")
logging.critical("Это критическое сообщение.")
----

Вот полный пример, который демонстрирует, как использовать логирование в Python:
--
import logging

# Настройка логирования
logging.basicConfig(level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')
def divide(a, b):
    logging.debug(f"Делим {a} на {b}")
    try:
        result = a / b
    except ZeroDivisionError:
        logging.error("Ошибка: Деление на ноль!")
        return None
    else:
        logging.info(f"Результат деления: {result}")
        return result

# Примеры вызовов функции
divide(10, 2)
divide(10, 0)
----

Уровни логирования

Модуль logging поддерживает несколько уровней логирования, каждый из которых имеет свой приоритет:
- DEBUG: Подробная информация, обычно интересная только для разработки.
- INFO: Подтверждение того, что все работает как ожидалось.
- WARNING: Указание на то, что что-то неожиданное произошло, или на предстоящую проблему (например, 'недостаточно места на диске').
- ERROR: Сообщение об ошибке, которое не позволяет выполнить какую-либо функциональность.
- CRITICAL: Серьезная ошибка, которая может привести к завершению программы.

Если вы хотите записывать логи в файл, вы можете изменить настройки basicConfig:
--
logging.basicConfig(filename='app.log', 
                    filemode='w',  # 'w' для перезаписи, 'a' для добавления
                    level=logging.DEBUG,
                    format='%(asctime)s - %(levelname)s - %(message)s')
----
- Теперь все сообщения будут записываться в файл app.log.

Логирование — это мощный инструмент для отслеживания работы программы и диагностики проблем. Модуль logging в Python предоставляет множество возможностей для настройки и использования логов, что делает его удобным для разработчиков.
<<<

Сергей Немчинский - Как правильно учиться -

https://www.youtube.com/watch?v=BxJI0RdLeTE

https://www.youtube.com/watch?v=L53mVOnKQA0

https://www.youtube.com/watch?v=OxgYIkv54yk

https://www.youtube.com/watch?v=syCPAAxW6B8

https://www.youtube.com/watch?v=BdNHlOO6HgY

https://www.youtube.com/watch?v=ailO0WR7MKc

https://www.youtube.com/watch?v=y2wTpjZ60Tg


*****************************************************************

17 - (15 урок) -
https://youtu.be/pdQtjERP18A?si=JnXPsEltuNGjEDAn
-
Курс "Инженерия данных с 0"
Урок 15.
Заказываем VPS сервер на Linux, подключаемся к нему и переходим по директориям.
ссылки из урока:
https://www.putty.org/
https://ruvds.com/ru-rub
Таймкоды:
0:00 - что такое Linux
3:40 - почему серверный Linux так популярен
4:40 - как арендовать свой VPS
8:00 - подключаемся к Linux по ssh через putty
11:15 - начинаем работать с Linux
18:00 - самая база по Linux
20:50 - для чего инженеру данных нужен Linux
23:10 - что такое деплоить
25:40 - вопросы
-
+ прочитай все комментарии под роликом в youtube - +++



>>>
вопрос - какой тариф взять?
1 -
https://ruvds.com/ru-rub
- тут от 130 руб. в месяц
2 -
vdsina.com
https://vdsina.ru/pricing/standard
- тут есть от 69 руб. в месяц 
3 -
https://reg.ru
-
vlabr2158@
a........R
<<<



linux - это unix-подобная операционная система с текстовым интерфейсом (взаимодействие через командную строку, терминал), но есть и с графическим интерфейсом 

linux создал в 1991 году Линукс Торвальдс 

серверный linux - без графического интерфейса 

большинство сайтов находятся на серверах с linux 

https://ruvds.com/ru-rub

- зарегистрировался -
https://ruvds.com/ru-rub/my/orders
RU1693279
L - 
sojmoscow@g...
P - 
a........rs5!

выбрать такой план - 

- Москва 
- Ubuntu 20.04 >>> перевел на версию 22.04 eng - 05.09.2024
- 1 процессор 
- 1 гигабайт оперативной памяти 
- 20 Gb SSD 

300 р. (240 р. при оплате за год) - ИТОГО - 2 880 р. 
оплатил на год - 26.08.2024 до 24.08.2025
-
"""""""""""""""""""""""""""""""""""">>>
Подключиться к серверу Вы можете по SSH (удаленный доступ Secure Shell):

IP-адрес:	
194.87.248.6

Логин к серверу:	
root

Пароль к серверу:	
8oWzMgwJSn

Эти данные, а также инструменты для управления сервером доступны в Вашей панели управления в разделе Мои серверы - 
https://ruvds.com/my/servers
""""""""""""""""""""""""""""""""""""<<<


посмотреть версию linux на сервере - 
--
cat /etc/issue
----
или 
--
lsb_release -a
----



как обновить Ubuntu на сервере - 
https://www.8host.com/blog/kak-obnovit-server-do-ubuntu-22-04/



подключаться к серверу будем по протоколу SSH 

если на Windows - то через программу PuTTY -
https://www.putty.org/

установщик PuTTY в - телеграм - избранное - 27.08.2024 

- запустить PuTTY 
- вставить IP-адресс 
- принять сертификат (нажать Accept)
- в открывшемся терминале ввести логин(root) и пароль(взять на сайте)
-
"""""""""""""""""""""""""""""""""""">>>
194.87.248.6
root 
8oWzMgwJSn
- чтобы вставить пароль - один раз кликнуть ПКМ 
(CTRL+V - НЕ СРАБОТАЕТ)
""""""""""""""""""""""""""""""""""""<<<

Эта система была минимизирована путем удаления пакетов и содержимого, которые не требуются в системе, в которую пользователи не входят.
Чтобы восстановить это содержимое, вы можете выполнить команду 'unminimize'.



команды - 

ls 

cd ..

cd root 

cd / - перейти в корневую директорию 

cd /etc - перейти в директорию etc находясь в любом месте(папке) 

pwd - посмотреть где ты сейчас находишься 

ls -l 

ls -la 

mkdir name_papka - создание папки(директории) 

rm -rf name_papka - удаление папки(директории) 

cat file.txt - посмотреть содержимое файла  

cat -n file.txt - посмотреть содержимое файла с нумерацией строк 

head -3 file.txt - посмотреть первые 3 строки файла

tail -4 file.txt - посмотреть последние 4 строки файла

sed '2,3!d' file.txt - для вывода произвольного количества строк из файла применяется команда sed с указанием диапазона строк в формате: 'начало, конец !d'

ls -l | grep .png | head -3 - следующая цепочка команд (конвейер) найдёт среди множества файлов все файлы, в названии которых есть слово vdc с расширением .png и выведет на экран первые 3 файла 

cat test_test.txt | grep Мы - найдёт строку в тестовом текстовом файле test_test_.txt, содержащую слово «Мы» 

cat test_test.txt | grep "Мы открыли" - если нужно найти словосочетание с пробелами, то оно берется в кавычки

grep "Мы открыли" test_test.txt - грепнем строку "Мы открыли" в файле test_test.txt, несмотря на то, что grep обычно используется, как фильтр, команду можно использовать и самостоятельно. Для этого достаточно указать искомое значение и место для поиска: файл или директория

/home/pseudolukian# grep -r .txt - для поиска файлов в директории и вложенных директориях применяется ключ -r. Например, найдем всех файлы с расширением .txt в домашней директории пользователя и всех вложенных директориях

+ 

tail - отображает последнюю часть (по умолчанию 10 строк) одного или нескольких файлов или передаваемых данных. Его также можно использовать для отслеживания изменений файлов в реальном времени.
Одним из наиболее распространенных способов использования команды tail является просмотр и анализ журналов и других файлов, которые меняются со временем, обычно в сочетании с другими инструментами, такими как grep

head - выводит начальные строки файла, - это в некотором роде антагонист команды tail (она печатает в терминале последние строки). Поскольку ее синтаксис довольно прост, у пользователей, как правило, не возникает проблем с использованием этой команды

grep - в Unix/Linux это мощный инструмент, используемый для поиска текстовых шаблонов внутри файлов и манипулирования ими. Его название происходит от команды ed (редактор) g / re / p (глобальный поиск регулярного выражения и печать соответствующих строк), что отражает его основную функциональность. grep широко используется программистами, системными администраторами и пользователями благодаря своей эффективности и универсальности при обработке текстовых данных
--
grep [опции] шаблон [файл...]

grep "текст" файл.txt

grep -i "текст" файл.txt
# Флаг -i позволяет игнорировать регистр при поиске

grep "текст" файл1.txt файл2.txt
# Этот пример ищет "текст" в обоих файлах файл1.txt и файл2.txt

grep -n "текст" файл.txt
# Флаг -n выводит номера строк, в которых найдено совпадение

grep "тек.*" файл.txt
#Этот пример ищет строки, которые начинаются с "тек" и 
#могут содержать любые символы после

grep -w "текст" файл.txt
# Флаг -w ищет только целые слова, а не подстроки

dmesg | grep "ошибка"
#Этот пример ищет строки, содержащие "ошибка" в выводе 
#команды dmesg

grep -v "текст" файл.txt
# Флаг -v выводит все строки, которые не содержат "текст"

grep -E "текст1|текст2" файл.txt
#Флаг -E позволяет использовать расширенные регулярные 
#выражения, что позволяет искать строки, содержащие 
#либо "текст1", либо "текст2"

grep -r "текст" /путь/к/каталогу
#Флаг -r (или --recursive) позволяет искать текст рекурсивно во 
#всех файлах в указанном каталоге и его подкаталогах
----

>>> ЕЩЁ ПРО КОМАНДЫ В LINUX -

whoami 
- выведет имя пользователя

pwd 
- выведет путь где ты сейчас находишься 

sudo apt update 
sudo apt install neofetch 
neofetch
- установит и запустит пакет neofetch

ls 
- отобразит файлы в текущей папке 

ls -l 
- отобразит файлы в текущей папке в виде таблицы 

ls -a 
- отобразит скрытые файлы в текущей папке

ls -la 
отобразит файлы(в том числе и скрытые) в текущей папке в виде таблицы

mkdir name_directory 
- создать директорию(папку)

mkdir more\ 2015 
- создаст файл "more 2015" (с пробелом, пробел экранируют \)

cd 
- переход 

cd ..
- переход на уровень выше 

cd /
- переход в корневой каталог 

cd /etc
- переход в директорию etc 

cd -
- вернет туда где ты был до этого

touch file_name.txt 
- создаст файл file_name.txt

cat file_name.txt
- прочитает файл 

nano file_name.txt
- откроет файл в редакторе nano 

echo "abc" > file_name.txt
- перезаписывает файл заново 

echo "abc" >> file_name.txt
- добавляет в конец файла 

ls | grep ".img"
- найдет и выведет все файлы с расширением .img 

/dev/null 
- псевдоустройство, всё что туда попадает - удаляется 

history 
- посмотреть историю команд 

CTRL + U 
- очистить всё что ввели 

CTRL + W
- очистить одно последнее введенное слово  

clear (или CTRL + L)
- очистить терминал 

CTRL + C 
- экстренно прервать выполнение программы 

rm file_name.txt
- удалит файл

rm -rf name_directory 
- удалит директорию(папку) 

touch .file_name.txt 
- создать скрытый файл 

drwxr-xr-x (если в начале d - это директория(папка))
rwxr-xr-x

r - читать 
w - записывать 
x - исполнять 

chmode 777 file_name
- установит все права для всех 

chmode 000 file_name
- уберет все права для всех 

тут это работает так -
r = 4
w = 2 
x = 1

cp file_name1.txt file_name2.txt
- скопировать файл 

touch file1 
mv file1 file2
- создадим файл file1 и переименуем его в file2

tar -cvf archive.tar directory/
- создать архив 

tar -xvf archive.tar
- распаковать архив

find /path/to/search -name "filename"
- найти файл по имени

<<<

если при вводе - ls -l в выводе строк с информацией о файлах и папках - первая буква в строке - это d - то это директория(папка), а если это не d - то это файл 

далее в строке идет информация -  
о правах доступа 
пользователь к которому отностится файл 
группа к которой относится файл 
размер 
дата создания или последнего изменения 
название 

/etc - в этой папке находятся файлы конфигураций, которые мы будем настраивать позже (path, postgresql и т.п.)

зачем linux нужен DE - 
- все БД обычно разворачиваются на linux 
- нам linux нужен для настройки PostgreSQL 
- нам потом придется делать деплой в docker - для этого тоже нужно знать linux 
- AirFlow мы тоже будем развертывать на linux 

деплой - это загрузка файлов на сервер для непрерывной работы 

3 ролика автора про деплой - 
https://youtu.be/get_WZEnCig?si=_dNI_CBleOKPbl1F
https://youtu.be/2YlWZyJ9G8Y?si=FDeuZG5pwSq0E_XN
https://youtu.be/8QiuE4TrEf0?si=nQI-iZUAF9K0fIzJ

***

ДЗ:
1. Внимательно прочитать статью про историю Linux https://timeweb.com/ru/community/articles/kratkaya-istoriya-linux-1 
Это надо чтобы понимать о чём вообще речь.
+
2. Установить программу putty - 
https://www.putty.org/
+
3. Арендовать свой сервер (в видосе показывал как) -
https://ruvds.com/ru-rub 
- ну или в любом другом месте
ВАЖНЫЙ МОМЕНТ! в видео 20 версия Ubuntu Linux, вам нужно будет выбрать 22 версию (на момент выпуска видео её что-то не было). Это будет потом важно при установке Airflow.
По братски, для регистрации сервера воспользуйтесь моей партнёрской ссылкой: 
https://ruvds.com/pr5558    
Денег с неё мне не будет, но смогу халявный сервер арендовать - чтобы VPN в РФ поддерживать.
+
4. Подключиться к своему серверу с использованием putty
+
5. Прочитать статью по основным командам, до команды grep включительно -
https://1cloud.ru/blog/10_commands_linux
вам надо знать команды:
cd - перейти 
ls - посмотреть список файлов 
tail - отображает последние (по умолчанию - 10) записи
head - отображает первые записи
grep - поиск
- по минимуму попробовать слова в файле поискать

6. Попробовать использовать все команды, которые я написал выше.



вопрос - какой тариф взять?
1 -
https://ruvds.com/ru-rub
- тут от 130 руб. в месяц
2 -
vdsina.com
https://vdsina.ru/pricing/standard
- тут есть от 69 руб. в месяц 
3 -
https://reg.ru
-
vlabr2158@
a........R


*****************************************************************

18 - (16 урок) -
https://youtu.be/31tyL-LM0mQ?si=Vn8WrLMaDuox0u5b
-
Курс "Инженерия данных с 0"
Урок 16
SFTP, head, tail, syslog, apt-get
MobaXterm: 
https://mobaxterm.mobatek.net/download.html
Таймкоды:
0:00 - Сохраняем пользователя в putty
1:28 - SFTP, MobaXterm
5:35 - head
8:42 - apt-get
9:10 - monitorix
12:00 - root user
13:45 - редактируем файлы на сервере
16:00 - vim
17:55 - tail - смотрим логи
22:20 - почему putty лучше
24:00 - заключение
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

как сохранить подключение в putty - 
1) вместо IP-адреса в поле пишем - 
root@194.87.248.6
2) в поле Saved Sessions ввести своё название сессии(my_session)
3) нажать Save 
4) пароль вводить вручную 

еще можно заходить через SSH-ключ - но это пока не нужно 

SFTP-подключение - подключение к серверу как к файловому хранилищу, как FTP, но еще и безопасное 

скачать mobaxterm - 
https://mobaxterm.mobatek.net/download.html
я скачаль portable 
установщик - telegram - избранное - 28.08.2024 

чтобы сделать новое подключение - 
- Session(в левом верхнем углу) 
- SFTP(в верхней строке)
- ввести IP-адрес и username(root)
- OK 
- ввести пароль 
- OK 

таким образом можно закачивать на сервер и скачивать с сервера любые файлы 

при установке ПО и БД - придеться исправлять файлы конфигураций - это можно также делать либо через vim(но это тяжело для новичков) 

обновим пакетный менеджер linux - 
--
apt-get update 
----

установим программу для мониторинга сервера - 
--
apt-get install monitorix 
----

откроем monitorix в браузере - 
194.87.248.6:8080/monitorix

установим vim - 
--
apt-get install vim 
----

открыть через vim - 
--
vi monitorix.conf 
----

выйти из vim без сохранения - 
--
ESC - :q!
----

выйти из vim с сохранением изменений - 
--
ESC - :wq
----

Основы работы с редактором VIM - 
https://beget.com/ru/kb/how-to/other/osnovy-raboty-s-redaktorom-vim

я считаю что лучше в linux использовать редактор - nano 

выйти из nano - 
--
CTRL + X 
----

смотреть логи - они в папке var/log - файлы с расширением .log -
--
head -50 monitorix 
----
- посмотреть 50 верхних записей 

--
tail -50 monitorix 
----
- посмотреть 50 нижних записей 



194.87.248.6:8080/monitorix
- если нужно переписать на другой порт - 
194.87.248.6:5050/monitorix
-
Все параметры Monitorix можно настроить по следующему маршруту:
/etc/monitorix/monitorix.conf 
-
Из этого файла мы можем настроить параметры, относящиеся к сети, интерфейсам, дискам и т. Д. Когда мы редактируем любой из параметров, содержащихся в этом файле, мы должны перезапустить службу, чтобы изменения вступили в силу, для этого мы выполним следующую команду -
--
service monitorix restart 
----

как запустить и отсановить monitorix -
--
systemctl start monitorix

systemctl stop monitorix
----

чтобы monitorix каждый раз запускался при запуске компьютера - 
--
systemctl enable monitorix
----

Про ключи 2 статьи - кто хочет попробовать (крайне не рекомендую это делать):
1 - на вашем компе настроить - https://serverspace.ru/support/help/generaciya-ssh-kluchey/
2 - на линуксе -
https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server



На эмиграцию надо денег накопить и если диплома ВУЗа нет - то надо хотя бы 3 года опыта по специальности (на самом деле туда можно и слесарем переехать - не обязательно программистом...)

***

ДЗ:

1. Установить MobaXterm  https://mobaxterm.mobatek.net/download.html
+
2. Подключиться к серверу по SFTP.
+
3. Создать на вашем компьютере файл и перекинуть на сервер.
+
4. Отредактировать его на сервере и скопировать к себе на компьютер.
+
5. Запустить apt-get update
+
6. Установить monitorix. Можете по этой статье: https://habr.com/ru/articles/548372/
+
7. Открыть monitorix через браузер.
+
8. В конфиг файле поменять порт, через который он будет открываться (про настройки в статье прочитайте, которую я выше скинул), не забудьте перезапустить monitorix через systemctl.
+
9. Откройте monitorix на новом порту.
+



*****************************************************************

19 - (17 урок) -
https://youtu.be/wb3fphOjTh0?si=SsHVUbSxzmKurW2i
-
Курс "Инженерия данных с 0"
Урок 17.
код с урока: 
https://github.com/berd90/data_engineering_lessons_github/blob/main/Lesson17.py
Как установить pm2 и работать с ним:    
https://youtu.be/2YlWZyJ9G8Y?si=5SqcWXOpW9POy_Pl
Таймкоды:
0:00 - Запускаем python файл на сервере с Linux
4:25 - Остальные, не относящиеся к теме урока вопросы
-
+ прочитай все комментарии под роликом в youtube - +++



>>>
Когда группу вёл - то первые 10 занятий по питону тоже быстро прошли - а дальше всё медленнее и медленнее - т.к. темы сложнее и устали все. Тут главное не забить - и до конца пройти все 40 уроков...
Самая жесть будет - когда надо будет Airflow на Linux устанавливать - главное в этот момент неделю-две с этим потрахаться - а дальше проще будет!

--
main_test_001.py 
--
import time 


i = 0

while i < 4:
	print(i)
	i += 1
	time.sleep(1)
----

создадим на сервере в корне папку - python_test и поместим туда наш файл - main_test_001.py 

запустим этот файл -
--
python3 main_test_001.py 
----

остановить выполнение - 
--
CTRL + C 
----

перенести программу на python с погодой на сервер и запустить её там через chron ??? - этому автор еще не обучал...

>>>

сделаем так чтобы наш файл python был постоянно запущен через pm2 -

установить pip3 - 
--
apt-get install pip 
----

установить pandas - 
--
pip3 install pandas 
----

деплой - это поставка кода(на сервер) 

установить npm - 
--
apt-get install npm 
----

посмотрим версию npm - 
--
npm -v 
----

установить pm2 - 
--
apt-get install pm2 
----

- автор эту установку не закончил...

<<<

системный демон - это вместо диспетчера задач в Windows 

можно сделать демон который будет запускать любой скрипт - шелл скрипт на bash 

демоны можно настраивать и сделать так, чтобы они запускались при перезапуске системы 

настройки демонов находятся в папке - 
/usr/lib/systemd/

нода - запускает на сервере код JS и т.п.
а python работает и так 

***

ДЗ -

1. Переписать ваш проект с сохранением текущей погоды по городам таким образом, чтобы сохранял файлы в отдельную папку. Так же файл должен называться следующем образом: 2024-01-11 23:55:56.csv - где сначала идёт дата, потом время - когда сохраняем файл.

2. Перенести ваш проект на linux сервер - лучше создать для него отдельную папку.

3. Запустить 1 раз его на линуксовом сервере.

4. Сделать, чтобы код запускался и создавал файлы раз в час. Для этого использовать cron -
https://1cloud.ru/help/linux/kak-nastroit-planirovshchik-cron-na-crontab-linux

>>>

Привет. Подскажи как настроить планировщик cron в linux для запуска скрипта "script.py" для запуска каждый час. Напиши команды для linux которые помогут это сделать.
-
Чтобы настроить планировщик cron для запуска скрипта script.py каждый час, следуй этим шагам:
0) установить cron -
--
apt install cron
----
1) Открой терминал
2) Введи команду для редактирования crontab -
--
crontab -e
----
3) В открывшемся редакторе добавь следующую строку, чтобы запланировать выполнение скрипта каждый час -
--
0 * * * * /path/to/python /path/to/script.py

в моём случае -
*/3 * * * * /usr/bin/python3 /root/my_tests/main_test_001.py >> /root/my_tests/logfile01.log
(сделал тут так, чтобы каждые 3 минуты вывод записывался в log-файл "logfile01.log")
----
- замените /path/to/python на путь к интерпретатору Python (например, /usr/bin/python3), а /path/to/script.py на полный путь к вашему скрипту script.py

4) Сохрани изменения и выйди из редактора. В зависимости от редактора, который используется, это может быть Ctrl + X, затем Y и Enter для nano, или :wq для vi/vim.

Теперь ваш скрипт будет запускаться каждый час в начале часа. Чтобы убедиться, что cron работает, можно проверить логи или добавить вывод в файл, например -
--
0 * * * * /path/to/python /path/to/script.py >> /path/to/logfile.log
----
Это перенаправит стандартный вывод и ошибки в файл logfile.log

Терминал Linux - crontab: запуск задач по расписанию -
https://www.youtube.com/watch?v=52-eyCp56ew
-
посмотреть какие задачи назначены в cron для текущего пользователя - 
--
crontab -l
--

удаление файла расписания текущего пользователя -
--
crontab -r
----

работа с расписаниями конкретных пользователей. Доступно только суперпользователю -
--
crontab -u user
----

переодичность указывается так - */15 * * * * 
- будет выполнятся каждые 15 минут 

если нужно указать несколько значений - 0 0 5,20 * * 
- будет выполнятся в 0 часов 0 минут 5 и 20 числа ежемесячно 

диапазон минут, часов, дат устанавливается через дефис 

в google - crontab validate 
crontab.guru 

<<<

посмотреть пример от другого ученика - 
https://youtu.be/Vaq1twlf7_Q
+
https://www.youtube.com/watch?v=B6r9Znhi04o



*****************************************************************

20 - (18 урок) -
https://youtu.be/u3qdtULp68o?si=Dv-YnFQGzT1L6w_b
-
Курс "Инженерия данных с 0"
Урок 18.
Устанавливаем и настраиваем Postgresql
Таймкоды:
0:00 - Устанавливаем PostgreSQL
2:22 - Подключаемся с пользователя postgresql
4:00 - Создаём пользователя и базу данных
7:40 - Подключаемся через dBeaver
11:00 - Меняем конфигурацию PostgreSQL
22:30 - Создаём подключение в dBeaver
25:30 - Домашнее задание
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

когда мы меняем конфигурацию какого-либо приложения - обязательно нужно перезапускать его демона, иначе изменения не применятся 

установить PostgreSQL -
--
apt-get update
apt-get install postgresql
----

зайти с пользователя postgresql -
--
sudo -u postgres psql
----

запустить postgresql - 
--
psql 
----

первого пользователя и первую БД - всегда делать через терминал 

и теперь уже можно запускать команды SQL (но пока БД там нет) -
--
SELECT NOW();
----

теперь нужно создать БД и пользователя, и выдать пользователю права на эту БД 

создание БД - 
--
CREATE DATABASE Test1;
----

создание пользователя - 
--
CREATE USER test_user2 WITH PASSWORD 'qwerty123!@#';
----

выдадим пользователю права на эту БД - 
--
grant all privileges on DATABASE Test1 TO test_user2;
----

для подключения к БД сейчас есть 2 популярные программы - 
- DataGrip (платная)
- DBeaver (бесплатная) -
https://dbeaver.io/download/

если мы установили postgresql и ничего не настраивали, он будет открыт на стандартном порту 

DBeaver - вверху слева знак вилки - PostgreSQL - 

Host - IP-адрес своего сервера 
Database - test001 (обязательно с маленькой буквы)
Username - user001
Password - 1234567q
- эти данные не брать, взять свои, которые в тексте ДЗ ниже


но подключение не получается, так как сама БД не дает подключится к себе извне 


еще заметки по теме - 
- сразу задать пароль пользователю - 
sudo -u postgres psql -c "ALTER USER user2 PASSWORD 'qwe123asd';
- рестарт - 
sudo service postgresql restart
- посмотреть статус - 
service postgresql status
- посмотреть версию - 
sudo -u postgres psql -c "SELECT version()";
+
поменять пароль для пользователя по умолчанию - postgres - 
--
sudo -i -u postgres 
psql 
\password postgres
ввести пароль 
подтвердить пароль 
----
+
обновить пароль пользователя user на новый -
--
ALTER ROLE user_01 WITH PASSWORD '1234567q';
----


как настраивать также написано здесь - 
https://linuxize.com/post/how-to-install-postgresql-on-ubuntu-20-04/


сейчас все перешли с MySQL на PosgreSQL, MySQL используют для маленьких проектов, типа сайтов на WordPress, а у PostgreSQL лучше синтаксис (есть WITH и т.п.) и при увеличении БД можно развернуть кластер, то есть удобно масштабировать 

PostgreSQL - сейчас это лучшая бесплатная БД 

--
create table test_table (
	log_field VARCHAR(50)
)

select *
from test_table;
----

в БД основы всего - это типы данных, в зависимости от их правильного выбора зависит объем БД, а чем меньше данных мы храним - тем быстрее мы их забираем из памяти 

NoSQL - используется примерно в 5% случаев 

кликхаус - это отдельная история, его намного сложнее ставить на сервер 

PSpark - от 150_000 до 250_000...300_000 рост зарплаты 

по SQL - придется приложить много усилий и много писать запросов 

AirFlow - запросы SQL автоматизировать через Python, но база всё равно будет SQL-ная 

***

ДЗ - 

1. Установить PostgreSQL
--
apt-get update
apt-get install postgresql
----
+
2. Зайти с пользователя postgresql:
--
sudo -u postgres psql
----
или лучше так - 
--
sudo -i -u postgres
psql
----
+
3. Создать базу данных, пользователя, выдать права:
-
194.87.248.6
test001
user001
1234567q
-
--
CREATE DATABASE database_name;
CREATE USER test_user WITH PASSWORD 'qwerty123!@#';
grant all privileges on DATABASE database_name TO user_name;
----
+
4. Поправить конфиг (/etc/postgresql/14/main/):

в файле postgresql.conf поменять: 
listen_addresses = '*'
и убрать # перед listen_addresses

в файле pg_hba.conf внизу:
# Database administrative login by Unix domain socket
local   all     postgres         peer
host    all     Berd             0.0.0.0/0    scram-sha-256

# TYPE        DATABASE        USER        ADDRESS       METHOD

# "local" is for Unix domain socket connections only
local   all     all                          peer
# IPv4 local connections:
host    all     all     127.0.0.1/32         scram-sha-256
# IPv6 local connections:
host    all     all     ::1/128              scram-sha-256
# Allow replication connections from localhost, by a user with the
# replication privilege.
local   replication     all                              peer
host    replication     all      127.0.0.1/32    scram-sha-256
host    replication     all      ::1/128         scram-sha-256
host    all             all      0.0.0.0/0       scram-sha-256 
----
+
5. Перезапустить PostgreSQL:
systemctl restart postgresql
+
6. Подключиться к базе на сервере со своего компьютера, через dBeaver
+



*****************************************************************

21 - (19 урок) -
https://youtu.be/idHIyACmFSE?si=x0KJh6d2SPa8hCkN
-
Курс "Инженерия данных с 0"
Урок 19.
SQL
Введение в базы данных
Рассказываю как всё начиналось, как сейчас выглядят хранилища данных и в чём будет заключаться работа инженеров данных.
Таймкоды:
0:00 - С чего всё начиналось
2:00 - Как появились реляционные базы данных
5:30 - Строковые и колоночные СУБД. OLAP и OLTP
17:50 - Чем занимаются инженеры данных
18:05 - Интерактив
18:40 - Витрины данных
21:20 - Вопрос по dbeaver
23:25 - PostgreSQL
24:25 - Clickhouse и работа с данными
26:04 - OLAP кубы
29:15 - Что такое SQL
30:25 - Почему важна практика, даже если вы уже "знаете" SQL.
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

SQL - это язык скриптовых запросов (скрипт квери ленгвадж)

до того как придумали СУБД - данные хранили в файлах 

потом с ними стало неудобно работать - и придумали реляционные БД - реляционные это когда данные хранятся в виде таблиц (строк и столбцов) со связями между таблицами 

появились БД - Oracle, MySQL, PostgreSQL 

минус строковых БД в том, что нужно читать всю БД с жесткого диска, а это медленный процесс - например нужно найти все имена "Иван" в колонке имя, но мы не можем прочитать всё только из одной колонки и нам приходится читать все строки целиком 

индекс - по простому это отдельный столбец с именами "Иван" который указывает в каких строках основной таблицы хранятся эти имена, это удобно так как в этом случае не нужно читать все строки основной таблицы, а только нужные - на которые указывает столбец индексов 

строки лежат в страницах по 4 килобайта, и чтобы прочитать строку - читается не одна строка а блок строк (страницу) размером 4 килобайта, а это около 50-ти строк 

есть еще колонковые таблицы (КликХаус, Вертика, Тарантул, некоторые виды Хайва и т.п.), где можно прочиать по колонкам, и если в колонках находятся повторяющиеся значения, то таблица ужимается (то есть там прописано не 3 имени "Иван", а что имя "Иван" лежит в строках 3, 7, 12 этой колонки), но в колонковые таблички очень медленно идёт вставка, особенно если нужно вставлять по одной записи

строковые и табличные БД - это всё реляционные БД 

отличие строковых БД от колоночных - в том как это на физическом уровне лежит на жестком диске, и соответственно первые больше подходят для вставки данных а вторые для того чтобы к ним делать запросы на сервере и смотреть всякую аналитику 

PostgreSQL - это строковая БД 

для быстрой записи используются строковые БД, вставлять записи в строковые БД удобно, но анализировать (типа дайте нам все фамилии всех Иванов, или какой у нас процент Иванов от всех записей) в строковых таблицах данные неудобно, поскольку такие запросы будут очень медленно выполнятся, и нам надо писать такие запросы, чтобы наши данные оказались в колонковых базах данных 

мы можем перекидывать данные из строковых в колонковые БД двумя способами - 
- блоковой загрузкой (бачами) например ночью перекидывать данные полученные за день 
- потоковой загрузкой (впихиваем в Кафку и раз в минуту небольшими бачами записываем в БД) но это создает больше нагрузки на хранилище данных, но зато данные появляются там быстрее 

инженер данных занимается -
- перекладыванием данных из строковых хранилищ данных в колонковые (из OLTP в OLAP) то есть миграцией БД
- разработкой архитектур таблиц
- делает витрины данных 

мы уже научились брать данные из открытого API и запихивать их в .csv файл

позже мы научимся брать данные из открытого API и запихивать их в таблицу, брать из одной таблицы и запихивать в другую таблицу 

освоить базовый синтаксис SQL - займет примерно месяц 
первые 2-3 недели освоим типы данных и научимся писать запросы 
после каждого занятия будет урок по практике 

***

ДЗ - прочитать статьи:

1. https://clickhouse.com/docs/ru/faq/general/columnar-database
-
Что такое столбцовая (колоночная) база данных?
В столбцовой БД данные каждого столбца хранятся отдельно (независимо) от других столбцов. Такой принцип хранения позволяет при выполнении запроса считывать с диска данные только тех столбцов, которые непосредственно участвуют в этом запросе. Обратная сторона такого принципа хранения заключается в том, что выполнение операций над строками становится более затратным. ClickHouse — типичный пример столбцовой СУБД.

Ключевые преимущества столбцовой СУБД:
- выполнение запросов над отдельными столбцами таблицы, а не над всей таблицей сразу;
- агрегация запросов на больших объемах данных;
- сжатие данных в столбцах.

Для аналитических приложений столбцовые СУБД предпочтительнее, так как в них можно хранить много столбцов в таблице просто на всякий случай, и это не будет сказываться на скорости чтения данных. Столбцовые СУБД предназначены для обработки и хранения больших данных. Они прекрасно масштабируются при помощи распределенных кластеров на относительно недорогих серверах — для увеличения производительности. В ClickHouse для этого используются распределенные и реплицированные таблицы.
+
2. https://www.astera.com/ru/knowledge-center/oltp-and-olap/
-
OLTP против OLAP: две стороны одной медали данных?
+
3. https://habr.com/ru/articles/72389/
-
Data Mart vs Data Warehouse
Data Mart — витрина данных, в переводе.
Data Warehouse — хранилище данных.
оба эти термина могут переводится как Хранилище данных


*****************************************************************

22 - (20 урок) -
https://youtu.be/guItZy-KElo?si=4NXL2j8NAwsUmBot
-
Курс "Инженерия данных с 0"
Урок 20.
Код с урока - https://github.com/berd90/data_engineering_lessons_github/blob/main/SQL/Lesson20.sql
+
SQL
Создание таблиц PostgreSQL
Типы данных
- int, smallint, bigint
- float
- char, varchar, text
- date, timestamp
Таймкоды:
0:00 - Краткий обзор типов
3:15 - Создание таблицы
4:40 - Целочисленные типы
8:30 - Числа с плавающей запятой
9:45 - Символьные типы
14:45 - byte
15:10 - boolean
16:15 - Дата со временем и без
19:00 - Приведение типов данных - явное и неявное
20:00 - Остальные типы данных обзорно
20:20 - Не используйте тип UUID
22:20 - Создаём таблицу и вставляем данные
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

типы данных PostgreSQL - 
postgrespro.ru/docs/postgresql/9.4/datatype

в других БД базовые типы данных могут немного отличаться 

в ячейке памяти мы можем что-то хранить, либо ничего не хранить - тогда там будет храниться NULL, то есть НИЧЕГО

численные типы данных работают быстрее 

можно в БД хранить json 

можно перегнать в байты и хранить что угодно, хоть изображения, но лучше так не делать 

- целочисленные 
- числа с плавающей запятой 
- строковые типы данных
- дата/время 
- булеан 

откроем DBeaver

откроем в DBeaver в верхней строке кнопку SQL - open SQL console 

ключевые слова лучше писать в верхнем регистре 

если нужно разделить слова в названии - делать через нижнее подчеркивание (как в python) - count_users 

нужно всегда смотреть какие данные будут храниться в столбце таблицы и всегда использовать тип данных, который достаточен для этой цели и занимает минимальное число данных - не int а smallint

если допустимо отсутвтсвие значения, то пишем что допустим NULL (вот так) -
    hands_count smallint NULL,
либо если мы знаем что значение всегда будет отлично от нуля - 
    hands_count smallint not NULL,
можно также задать значение по умолчанию (дефолту, то есть если мы создали строку и не указали количество рук мобилизованного - то туда будет вставляться 2) -
    hands_count smallint null default 2,

основные числовые типы данных (для целых чисел, дробных чисел, чисел с автоувеличением) - 
- smallint (-32_768 - 32_767)
- integer (-2_147_483_648 - 2_147_483_648)
- bigint (-9223372036854775808 - 9223372036854775807)
- и другие, смотреть про все типы здесь -
https://postgrespro.ru/docs/postgresql/9.4/datatype-numeric

когда делаем таблицу, лучше сразу создать столбец id с типом данных serial (целое число с автоувеличением)

есть денежный тип данных - money (8 байт) - автор не рекомендует его использовать, так как он занимает много места 

символьные типы данных -
- varchar(n) - строка ограниченной переменной длины
- char(n) - строка фиксированной длины, дополненная пробелами
- text - строка неограниченной переменной длины

отличие char от varchar - 
char(50) - всегда в памяти будет занимать 50 символов, независимо от длинны заданной переменной 
- varchar(50) - если переменная будет из 5 букв, то в памяти будут храниться только эти 5 букв, и остальная память заниматься не будет 

на практике char никто не использует а используют varchar 

в text влезет текст любой длинны, но везде использовать text не нужно, не понятно как он будет работать с памятью и некоторые операторы работают только с varchar и char, а для text не работают (как пример - like '%Иван' по text не сработает)

двоичные типы данных - 
- bytea	- 1 или 4 байта плюс сама двоичная строка - двоичная строка переменной длины (используют для хранения к примеру изображений в БД, изображение запихивается в набор байтов и хранится)

логический тип - 
- boolean - 1 байт - истина или ложь 
Состояние "true" может задаваться следующими значениями:
TRUE
't'
'true'
'y'
'yes'
'on'
'1'
Для состояния "false" можно использовать следующие варианты:
FALSE
'f'
'false'
'n'
'no'
'off'
'0'
При этом пробелы в начале и конце строки игнорируются, и регистр так же не имеет значения. Предпочтительными (совместимыми с SQL) являются варианты TRUE и FALSE.

дата - 
- timestamp - если нужно хранить дату и время с часовым поясом/без часового пояса  
- data - только дата, без времени 
- time - только время 
-
https://postgrespro.ru/docs/postgresql/9.4/datatype-datetime

вывести текущее время - 
select NOW() 

и привести это сразу к типу date - 
select NOW()::date 
- это явное преобразование типов данных 

одни типы данных пожно преобразовывать в другие типы данных 

select NOW()::date::VARCHAR(7)
- преобразует в varchar и выведет только первые 7 символов 

также можно хранить в XML, JSON - но с ними потом очень тяжело обращаться 

uuid - хранит всякие циферки и символьные коды 
не использовать uuid вместо integer 
Тип данных uuid сохраняет универсальные уникальные идентификаторы (Universally Unique Identifiers, UUID), определённые в RFC 4122, ISO/IEC 9834-8:2005 и связанных стандартах. (В некоторых системах это называется GUID, глобальным уникальным идентификатором.) Этот идентификатор представляет собой 128-битное значение, генерируемое специальным алгоритмом, практически гарантирующим, что этим же алгоритмом оно не будет получено больше нигде в мире. Таким образом, эти идентификаторы будут уникальными и в распределённых системах, а не только в единственной базе данных, как значения генераторов последовательностей.
UUID записывается в виде последовательности шестнадцатеричных цифр в нижнем регистре, разделённых знаками минуса на несколько групп, в таком порядке: группа из 8 цифр, за ней три группы из 4 цифр и, наконец, группа из 12 цифр, что в сумме составляет 32 цифры и представляет 128 бит. Пример UUID в этом стандартном виде:
--
a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11
----
PostgreSQL также принимает альтернативные варианты: цифры в верхнем регистре, стандартную запись, заключённую в фигурные скобки, запись без минусов или с минусами, разделяющими любые группы из четырёх цифр. Например:
--
A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
{a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
a0eebc999c0b4ef8bb6d6bb9bd380a11
a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
{a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
----
- автор рекомендует не использовать этот тип данных, работать с ним только если он уже используется в системе, с которой ты работаешь 

создать таблицу - 
--
CREATE TABLE meat_1(
	id serial,
    hands_count smallint not null default 2,
	meat_name char(50),
	meat_family_name varchar(50),
	create_time timestamp default now(),
	modify_time timestamp default now(),
	birth_data date,
	primary key(id)
);
----

первичный ключ (primary key) - это столбец или набор столбцов, позволяющий нам однозначно идентифицировать строку в таблице (то есть это уникальное значение, может состоять как из одного так и из нескольких полей - например номер паспорта или фамилия, имя, отчество и дата рождения)

чтобы таблица появилась слева в DBeaver - ПКМ - Refresh

выбрать все данные из таблицы - 
--
SELECT *
FROM meat
LIMIT 20;
----

данные в таблицу можно вставлять скриптами (использовать только одинарные кавычки, двойные работать не будут) -
--
insert into meat_1 (meat_name, meat_family_name, birth_data)
values ('Ivan', 'Ivanov', '2020-01-01'::date)
----

а можно это делать с помощью интерфейса DBeaver - 
ПКМ по названию таблицы в панеле слева - Read data in SQL editor - затем навести курсор на значение таблицы и нажать ENTER - отредактировать как нужно - нажать ENTER  
и нажать Save в меню в строке под таблицей 

добавить строки - смотреть меню под таблицей где Refresh 

***

ДЗ:

1. Создать несколько таблиц (в каждой таблице должен быть сурогатный ключ id): 
- таблица пациентов
- таблица врачей
- таблица приёмов (врач, пациент, диагноз, дата приёма)
--
CREATE TABLE d_pasients(
	id serial,
	name varchar(50),
	first_name varchar(50),
	age smallint not null,
	birth_data date,
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);


CREATE TABLE d_doctors(
	id serial,
    stage smallint not null,
	name varchar(50),
	first_name varchar(50),
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);


CREATE TABLE f_visits(
	id serial,
	doctor varchar(50),
	name_pas varchar(50),
	first_name_pas varchar(50),
	diagnoz text,
	data_visit date,
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);
----
+
2. В каждую таблицу добавьте по 5 записей.
И заранее готовьтесь, что после следующего урока таблицы придётся удалять и создавать заново.
--
insert into d_pasients (name, first_name, age, birth_data)
values ('Ivan', 'Ivanov', 30, '1995-02-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Yan', 'Art', 40, '1985-03-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Ron', 'Fen', 50, '1975-04-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Hon', 'Parker', 20, '2005-05-06'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Ben', 'Gan', 60, '1965-07-08'::date)



insert into d_doctors (stage, name, first_name)
values (5, 'Dr', 'Hause')

insert into d_doctors (stage, name, first_name)
values (10, 'Dr', 'Moonk')

insert into d_doctors (stage, name, first_name)
values (12, 'Dr', 'Joli')

insert into d_doctors (stage, name, first_name)
values (15, 'Dr', 'Smith')

insert into d_doctors (stage, name, first_name)
values (25, 'Dr', 'Full')



insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Hause', 'Ivan', 'Ivanov', 'Osmotr', '2024-10-4'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Moonk', 'Yan', 'Art', 'Palpatsia s predvaritelnim osmotrom a dalee po programme lechenia', '2024-10-5'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Joli', 'Ron', 'Fen', 'Shizofreniya', '2024-10-5'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Smith', 'Hon', 'Parker', 'Prostuda', '2024-10-6'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Full', 'Ben', 'Gan', 'ORVI', '2024-10-7'::date)
----

посмотреть что получилось - 
--
select *
from visits;
----
+
3. Обязательно прочитайте статью: https://habr.com/ru/articles/756074/ (Наполняем до краев: влияние порядка столбцов в таблицах на размеры баз данных PostgresQL) - вывод из статьи - сначала нужно писать строки с большими размерами данных - 
--
int8        - 8
timestamptz - 8   
int4        - 4
int2        - 2
bool        - 1
text        - -1 (столбец переменного размера)
numeric     - -1 (столбец переменного размера)
----

*****************************************************************

23 - (21 урок) -
https://youtu.be/2Fo7wq6G83c?si=3q8NWYRrGagGKQJI
-
Курс "Инженерия данных с 0"
Урок 21.
SQL
Postgre
CREATE TABLE, UNIQUE, REFERENCES
Таблицы фактов и таблицы словарей.
Связь 1 ко многим, многие ко многим.
+
Код с урока: 
https://github.com/berd90/data_engineering_lessons_github/blob/main/SQL/Lesson21.sql
+
Таймкоды:
0:00 - Почему люди не могут выучиться на программиста
1:20 - Таблицы фактов и словари
3:30 - Практика создания таблиц
10:00 - Словари, в которых меняются значения
11:20 - Составной первичный ключ
15:15 - Создаём второй словарь
18:00 - Создаём таблицу фактов
22:00 - Чем отличается таблица фактов от таблицы словарей
23:40 - Внешние ключи - и почему их лучше не использовать
29:00 - Ограничения на колонке в таблице
33:00 - 1 ко многим, многие ко многим.
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

люди не становятся программистами так как не находят время на обучение и не делают ДЗ 

таблицы с врачами, городами и т.п. - это таблицы-словари (или таблицы-справочники), так как новые данные туда редко добавляются - при создании их имя обычно пишут с добавлением d_ - d_doctors 

таблици с приемами - это таблицы фактов (она гораздо чаще изменяется и в ней будет гораздо больше записей, чем в таблицах словарей), туда обязательно нужно добавлять поля с временем, когда этот факт произошел - при создании их имя обычно пишут с добавлением f_ - f_visits  

при создании таблицы первичный ключ может быть простой (одна колонка) - 
--
primary key(id),
----
а может быть и составной (из нескольких столбцов(колонок)) - 
--
primary key(first_name, second_name),
----

есть не только первичные ключи, но и внешние ключи, можно сделать поле(столбец) внешним ключом для таблицы - но автор предпочитает внешние ключи при создании таблиц не делать, так как не некоторых БД (типа Кликхауса) они не популярны, там их никто не делает, а в PostgreSQL это будет замедлять работу и приводить к ошибкам. Вывод - автор не рекомендует делать внешние ключи 

бывают таблицы-словари где дата ни на что не влияет, а бывают словари где на одну дату одно значение а на другую дату другое значение, в этом случае мы создаем 2 колонки - начало действия записи и конец действия записи, в колонке где конец действия прописываем значение по умолчанию, в колонке где начало записи - ставим чтобы вставлялось текущее время создания строки -
--
begin_date date now(),
end_date date default '2050-01-01',
----

внешний ключ в таблице для связи с таблицей d_doctors пишется так - 
--
...
id_doctor INT NOT NULL REFERENCES d_doctors (id),
...
----
- но если так сделать, то потом трудно будет вставлять туда данные и появляются ненужные запреты на удаление, и это отнимает много времени, и вызывает непредсказуемое поведение как и использование триггеров в таблицах(триггерры тоже лучше не использовать)

триггер - это когда сделано так, что при вставке значений в таблицу меняются данные в другой таблице 



ограничения (constraints) - 

цену товара можно ограничить положительными значениями так -
--
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);
----

Вы можете также присвоить ограничению отдельное имя. Это улучшит сообщения об ошибках и позволит вам ссылаться на это ограничение, когда вам понадобится изменить его. Сделать это можно так -
--
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CONSTRAINT positive_price CHECK (price > 0)
);
----
- чтобы создать именованное ограничение, напишите ключевое слово CONSTRAINT, а за ним идентификатор и собственно определение ограничения. (Если вы не определите имя ограничения таким образом, система выберет для него имя за вас.)

Ограничение-проверка может также ссылаться на несколько столбцов. Например, если вы храните обычную цену и цену со скидкой, так вы можете гарантировать, что цена со скидкой будет всегда меньше обычной:
--
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0),
    discounted_price numeric CHECK (discounted_price > 0),
    CHECK (price > discounted_price)
);
----
Первые два ограничения определяются похожим образом, но для третьего используется новый синтаксис. Оно не связано с определённым столбцом, а представлено отдельным элементом в списке. Определения столбцов и такие определения ограничений можно переставлять в произвольном порядке.
.....
- и далее - в документации по ссылке - 
postgrespro.ru/docs/postgresql/11/ddl-constraints


автор курса - нас интересуют два ограничения - NOT NULL и ограничение уникальности -

NOT NULL мы уже проходили - оно означает что в данном поле(столбце) запрещено хранить значение NULL 

ограничение уникальности - 
Ограничения уникальности гарантируют, что данные в определённом столбце или группе столбцов уникальны среди всех строк таблицы. Ограничение записывается так в виде ограничения столбца -
--
CREATE TABLE products (
    product_no integer UNIQUE,
    name text,
    price numeric
);
----

и так в виде ограничения таблицы -
--
CREATE TABLE products (
    product_no integer,
    name text,
    price numeric,
    UNIQUE (product_no)
);
----

Чтобы определить ограничение уникальности для группы столбцов, запишите его в виде ограничения таблицы, перечислив имена столбцов через запятую:
--
CREATE TABLE example (
    a integer,
    b integer,
    c integer,
    UNIQUE (a, c)
);
----
- такое ограничение указывает, что сочетание значений перечисленных столбцов должно быть уникально во всей таблице, тогда как значения каждого столбца по отдельности не должны быть (и обычно не будут) уникальными.

если мы создаем первичный ключ, то он уже накладывает ограничения уникальности на данные в этом столбце, но первичный ключ может быть только один, а ограничение уникальности может работать для нескольких столбцов(полей) в таблице 

если мы допустим добавили ограничение уникальности по полу, то мы в таблицу можем добавить только две записи - мужчину и женщину, а если мы попытаемся добавить третью запись то СУБД скажет что у нас уже есть значение с акой записью 

можно прописать ограничение уникальности для двух столбцов(полей) - 
--
...
UNIQUE (passport_number, family_name),
...
----

в таблицах может быть три вида логических связей - 
- один к одному (один человек и один автомат)
- один ко многим (одна рота и несколько человек)
- многие ко многим (врачи и пациенты) - связь делается через третью таблицу где есть оба id-шника 

***

ДЗ:

1. Придумать тематику базы данных, создать новую базу данных (пересмотрите, как мы это делали). Вам на неё надо будет выдать права на пользователей, но postgresql заново не надо будет настраивать - если вы уже можете к нему подключиться - нужно будет только в dbeaver добавить новое подключение.
+
2. В новой БД создать хотя бы 5 таблиц - из которых хотя бы 2 должны быть таблицами фактов. Чем больше таблиц создадите - тем лучше - хотя бы час-полтора этим позанимайтесь - вам сейчас очень важно очень много практики нарабатывать. Т.е. хотя бы по 1-2-3 часа в сутки на SQL писать - иначе тяжело будет идти.
+
3. Вставить хотя бы по 5 строк хотя бы в 5 таблиц - если успеете.
--
CREATE TABLE d_pasients(
	id serial,
	name varchar(50),
	first_name varchar(50),
	age smallint not null,
	birth_data date,
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);

CREATE TABLE d_doctors(
	id serial,
    stage smallint not null,
	name varchar(50),
	first_name varchar(50),
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);

CREATE TABLE f_visits(
	id serial,
	doctor varchar(50),
	name_pas varchar(50),
	first_name_pas varchar(50),
	diagnoz text,
	data_visit date,
	create_time timestamp default now(),
	modify_time timestamp default now(),
	primary key(id)
);

+

insert into d_pasients (name, first_name, age, birth_data)
values ('Ivan', 'Ivanov', 30, '1995-02-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Yan', 'Art', 40, '1985-03-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Ron', 'Fen', 50, '1975-04-03'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Hon', 'Parker', 20, '2005-05-06'::date)

insert into d_pasients (name, first_name, age, birth_data)
values ('Ben', 'Gan', 60, '1965-07-08'::date)

+

insert into d_doctors (stage, name, first_name)
values (5, 'Dr', 'Hause')

insert into d_doctors (stage, name, first_name)
values (10, 'Dr', 'Moonk')

insert into d_doctors (stage, name, first_name)
values (12, 'Dr', 'Joli')

insert into d_doctors (stage, name, first_name)
values (15, 'Dr', 'Smith')

insert into d_doctors (stage, name, first_name)
values (25, 'Dr', 'Full')

+

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Hause', 'Ivan', 'Ivanov', 'Osmotr', '2024-10-4'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Moonk', 'Yan', 'Art', 'Palpatsia s predvaritelnim osmotrom a dalee po programme lechenia', '2024-10-5'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Joli', 'Ron', 'Fen', 'Shizofreniya', '2024-10-5'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Smith', 'Hon', 'Parker', 'Prostuda', '2024-10-6'::date)

insert into f_visits (doctor, name_pas, first_name_pas, diagnoz, data_visit) 
values ('Full', 'Ben', 'Gan', 'ORVI', '2024-10-7'::date)

+

select *
from d_pasients;

select *
from d_doctors;

select *
from f_visits;
----
+
4. Почитать про связь 1 ко многим, многие ко многим:
https://habr.com/ru/articles/193284/
https://habr.com/ru/articles/193380/
+

*****************************************************************

24 - (22 урок) -
https://youtu.be/YOoWZ2QiQjk?si=uryNGBQOvE7NqiP2
-
Курс "Инженерия данных с 0"
Урок 22
SQL
Postgre
нормализация таблиц
SELECT
WHERE
+
Код с урока: https://github.com/berd90/data_engineering_lessons_github/blob/main/SQL/Lesson22.sql
+
Таймкоды:
0:00 - Права доступа для пользователей
8:00 - Почему таблицы и базы нужно всегда создавать скриптами, а не из интерфейса
9:52 - Как добавить/удалить колонку из таблицы
12:30 - Ещё раз про UNIQUE
13:35 - Немного про транзакции
15:05 - Про таблицы словарей и факты. Немного архитектуры.
22:35 - Про нормализацию и 3НФ
27:20 - Звезда и снежинка
29:10 - Витрины данных
35:30 - SQL очень редко и очень медленно меняется - для базовых типов версия СУБД практически никогда не важна
37:37 - Ещё про типы данных
40:00 - Как дополнять синтаксис
42:42 - SELECT, WHERE
45:05 - AND, OR, скобки
45:50 - LIKE
-
+ прочитай все комментарии под роликом в youtube - +++

>>>

создание пользователей, БД и привелегий - в любой БД можно создавать новых пользователей, если есть админский доступ к БД - создаешь пользователей и можно выдавать им привелегии(доступ - чтение, чтение и запись, чтение и удаление, создание новых таблиц в базе и т.п.) для доступа ко всем или только определенным БД, схемам - то есть какие угодно права 

в DBeaver где подключение к БД в следующей вкладке - PostgreSQL - поставить галочку в квадрате "Показать все базы данных"

если есть вопросы по dBeaver, настройкам IDE и т.п. - искать ответы в англоязычном google 

как через интерфейс IDE создавать новые БД? - накак, надо делать через SQL, скриптом, и автор будет учить создавать всё скриптами, это важно и впоследствии будет очень нужно для работы 

добавить колонку в таблицу doctors, если указываем not null то нужно указать дефолтное значение, и если в таблице очень много записей то это может выполнятся долго и может подвесить прод, лучше это делать ночью - 
--
alter table doctors add column new_column int not null default 0;

select *
from doctors;
----

в таблице фактов - факты - это когда что-то случилось (то есть факты происходят в какое-то время, а в таблицах )

16-00

4500


















ДЗ:

1. Прочитайте про 3 нормальную форму: https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B5%D1%82%D1%8C%D1%8F_%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%84%D0%BE%D1%80%D0%BC%D0%B0

2. Выделить минут 20-30 и обязательно почитать про звезду и снежинку: https://habr.com/ru/articles/441538/

3. Пописать запросы с SELECT и несколькими условиями - через AND, OR. Написать по 10 запросов с AND и 10 запросов с OR.

4. Пописать запросы с использованием LIKE. Не забывайте про символ %. Написать 10 запросов с LIKE.





























#############################################

ChatGPT - 
https://www.youtube.com/watch?v=voO12-fh-eU
-
chatgpt.com 
- c 4-ой версии может анализировать, распознавать и описывать изображения 


- 11-11



#############################################

FAST API - 
--
from fastapi import FastAPI 


app = FastAPI() 

# обработка главной страницы - 
@app.get("/")
def home():
	#   return "Hello"
	return {"data": "message"}
----

в терминале - 
--
uvicorn main:app --reload 
----
- тут --reload означает что при изменении в файле всё будет перегружатся (но на реальном сервере так не делать)

документация -
127.0.0.1:8000/docs 


5-15






































