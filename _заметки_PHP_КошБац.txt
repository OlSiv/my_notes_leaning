
плейлист -
https://www.youtube.com/playlist?list=PLFK_bY6XtOzIF9vdfNHTZ5ZFc9SHImoKm

https://www.youtube.com/@koshachya_batsyla/playlists

БАЗА ЗНАНИЙ (тыкайте, там бесплатного много и не только про пхп):
https://koshachia-batsyla.notion.site/39f3b9e25879493b80c4517a23d853c8

с 17.10.2024 - пойдут видео

Linux >>> VSCode >>> php_projects 

онлайн IDE для PHP - 
https://onlinephp.io



************************************

ЗАПУСК СЕРВЕРА PHP - 
- 
запустить Docker в Windows 

- выполнить в терминале - 
docker compose up -d

- сервер по адресу - 
http://localhost:8080/

- выключить - 
docker compose down



************************************

001_PHP С НУЛЯ ДО ОФФЕРА. Привет!
https://youtu.be/l3yv4OTsBbI?si=v3q9JxKUlsRpZZF6
+
PHP с нуля - даже бабушка разберется 
объяснять будет очень простыми словами 
учить будет много и до офера 
+ 
- язык PHP целиком (основы и углубленно)
- БД
- как работает интернет 
- что такое DNS 
- что такое БиСи, ООП и т.п. 
- 2 фреймворка - Симфони и Ларавел 
- редис, докер, энжинкс, очереди, ребит, кафка, пхп-юнит, пхп-стан, тестирование, безопасность 
- как работает память в PHP (платно)
- 50 вопросов по PHP (платно)
- видео для профи (платно)
- архитектурные вопросы 
- шаблоны проектирования 
- микросервисы и монолиты, их взаимодействие 
- джиерписи, протобафы, как туда воткнуть GO 
+
в день по одному видео 
+
эксклюзивные видео платно - но на структуру курса они не повлияют 

************************************

002_Программы для программиста, ставим PhpStrorm, Docker, запускаем проект.
https://youtu.be/NV7qRJ7NK7I?si=fnT3JV4-qcJAXfaX
+
как включить первую программу на php, какие приложения потребуются для разработки, как их включить и настроить 
+
как настроить VSCode для работы с php ???
+
jetbrains.com/ru-ru/phpstorm

Никогда раньше не пользовались PhpStorm?
Распечатайте справку по сочетаниям клавиш, чтобы работать максимально продуктивно -
https://resources.jetbrains.com/storage/products/phpstorm/docs/PhpStorm_ReferenceCard.pdf

Удобные и информативные обучающие материалы помогут начать работу -
https://www.jetbrains.com/ru-ru/phpstorm/resources/

Прочитайте документацию по PhpStorm -
https://www.jetbrains.com/help/phpstorm/getting-started.html
+
docker.com 
- рассматривать будем позже, пока с VPN скачать установщик и поставить, и перезагрузить компьютер  
+
скачать с GitHub репозиторий в zip-архиве и распаковать - 
github.com/Koshachiyabatsyla/bacyla 
+
включить сервер и запустить программу 
+
в проекте слева файлы проекта 
+
запустить docker - просто нажать на иконку и запустить 
+
в README.MD в проекте - есть уже готовые команды для управления сервером 
+
включить VPN, перейти в терминале в папку проекта и запустить docker - 
--
docker compose up -d
----
когда всё загрузится, по этому адресу будет поднят сервер - 
http://localhost:8080/
+
по данному адресу сейчас отображается файл нашего проекта -src/index.php 
+
как это всё выключить - 
--
docker compose down
----
+
лучше конечно работать не на Windows, а на Linux или MacOS 
+
больше пока ничего настраивать не нужно 

************************************

003_HTML, CSS, JavaScript простыми словами
https://youtu.be/oeXBbn3pNKE?si=FInyoauHyyxnjzm0
+
Базовые термины, которые будем использовать в курсе - 
1 - программа, код 
- программа - это набор инструкций, которые выполняет компьютер 
2 - интернет 
- интернет - это совокупность компьютеров которые соеденены между собой проводом 
3 - сервер 
- сервер - это особенный компьютер на котором хостится(находится) сайт
4 - браузер 
- браузер - это ПО для доступа к сайтам
- браузер(клиент) и сервер перекидывают друг другу текст (JSON и т.п.)
5 - HTML, CSS, JS, PHP 
- HTML - это язык разметки 
- CSS - отвечает за стили (задает шрифты, цвета, положение элементов на странице)
- JS - анимация, интерактивные элементы и т.п. 
- PHP - это бекэнд для связи с БД(проверяет информацию в БД, решает в каком виде нам её выдать), отвечает за логику(бизнес-логику)
+
бекэнд - регистрация, работа с паролями, хранение информации и т.п. 

************************************

004_Что такое СИНТАКСИС？ Открывающий и закрывающий теги 
https://youtu.be/DDVljTddS6w?si=SGW7p70MRZoppo_5
+
синтаксис - это набор условностей и правил, которые позволяют нам писать на ЯП 
+
синтаксис запомнить не сложно, так как он простой 
+
--
<?php

$x = 'Alex';
echo $x;

?>
----
+
<?php - это открывающий тег 
+
; - это конец команды 
+
?> - это закрывающий тег, но по новым правилам синтаксиса он не нужен, но он нужен когда внутрь кода HTML нужно вставить код PHP   
+
также нужно выучить не только команды, а и комбинации команд между собой 
+
обязательно повторять самому всё что автор делает на экране(формируется мышечная память)
+
кавычки можно ставить как одинарные так и двойные - ('...', "...")
+
либо экранировать кавычки обратным слешом(\)- 
--
echo 'OOO \'Roga And Co\''
----

************************************

005_Комментарии в PHP
https://youtu.be/w2y1fqWFeDw?si=QSL7dYSZcVTyfopN
+
комментарии - это заметки внутри кода 
они не влияют на работу программы 
+
--
<?php 

// - это однострочный комментарий 

/*
* это
* многострочный
* комментарий
*/

/**
* это
* тоже 
* многострочный
* комментарий
*/

echo 12345;
----
- комментарий /** - подсвечивается другим цветом и для чего он нужен мы разберем позже 

************************************

006_Константы в PHP
https://youtu.be/_pS3R5WV4Ok?si=kJ7FRXBP2fvJlWh1
+
--
<?php

const NAME = " a zdes text constanti";

echo "Hello!!!";
echo "<br>";
echo "<br>";
echo "Текст документа 1" . NAME;
echo "<br>";
echo "<br>";
echo "Текст документа 2" . NAME;
echo "<br>";
echo "<br>";
echo "Текст документа 3" . NAME;
echo "<br>";
echo "<br>";
echo "строка1" . "строка2";
echo "<br>";
echo "<br>";
echo PHP_VERSION;
echo "<br>";
echo "<br>";
define("USER", "Alex");
echo USER;
echo "<br>";
echo "<br>";
echo defined('USER');

?>
----
Hello!!!

Текст документа 1 a zdes text constanti

Текст документа 2 a zdes text constanti

Текст документа 3 a zdes text constanti

строка1строка2

8.3.13RC1

Alex

1
------
+
echo "<br>"; - это символ переноса строк 
+
конкатенация(склеивание строк) - через точку 
+
имя константы не может начинатся с цифры 
+
в имени константы нельзя использовать специальные символы 
+
имя константы принято писать заглавными буквами 
+
некоторые имена констант уже зарезервированы (типа PHP_VERSION)
+
еще есть магические константы (типа __LINE__) - они начинаются с двух подчеркиваний 
+
константа неизменяема(то есть ещё раз переприсвоить ей другое значение нельзя) 
+
значением константы могут быть как строки так и числа 
+
также завести константу можно через конструкцию define - 
--
define("USER", "Alex");
// - это то же самое что и -
const USER = "Alex";
----
+
define можно вызвать внутри цикла - 
--
if (true) {
    define("USER", "Alex");
}
----
- но использовать внутри условной конструкции const не получится 
+
есть метод defined() - который говорит нам существует ли константа, про которую мы его спрашиваем - 
--
echo defined('USER');
----
- возращает 1 или 0 (тип boolean)

************************************

007_Переменные в PHP
https://youtu.be/-u6t0LVzal0?si=Z0SrHJi_l2VVjBhs
+
rand(1, 10) - это метод или функция? - по началу это не важно 
+
--
<?php 

echo 'Сайт выдает вам и вашему другу случайные числа. Узнайте, кто лучший. <br><br>';
echo 'Ваше число -- ' . rand(1, 10) . '<br><br>';
echo 'Число вашего друга -- ' . rand(1, 10) . '<br><br>';
//
//echo 'Ваши числа отличаются друг от друга на ' . rand(1, 10) - rand(1, 10);
----
+
--
<?php 

$first = rand(1, 10);
$second = rand(1, 10);

echo 'Сайт выдает вам и вашему другу случайные числа. Узнайте, кто лучший. <br><br>';
echo 'Ваше число -- ' . $first . '<br><br>';
echo 'Число вашего друга -- ' . $second . '<br><br>';
//
echo 'Ваши числа отличаются друг от друга на ' . $first - $second;
----
+
переменная - как грузовик, который таскает ваши данные 
+
ты в переменную что-то кладешь и она что-то в себе содержит 
+
в отличие от константы в переменной можно перезаписывать значение - 
--
<?php

$x = 1;
$x = 10;
$x = 100;

echo $x;
----
+
переменная определяется символом $ в начале имени переменной 
+
одной переменной можно присвоить другую переменную - 
--
<?php

$a = 1;
$b = $a;
$a = 'hello';
echo $b;
----
1
------
- то есть переменная присваивается по значению (когда мы присваеваем переменной $b переменную $a, то это означает что переменная $b принимает значение переменной $a на данный момент (в данном случае - это 1))
+
а если нужно скопировать ссылку на данные - через & - 
--
<?php

$a = 1;
$b = &$a;
$a = 'hello';
echo $b;
----
hello
------
+
имя переменной не может начинаться с числа 
+
имя переменной не может начинаться со специальных символов (кроме символа нижнего подчеркивания - _ )
+
в имени переменной нельзя использовать зарезервированные слова (как пример - $this)
+
переменная-переменная - 
--
<?php

$a = 'b';
$$a = 123;
echo $b;
----
123
------
- когда мы ставим $$a - мы смотрим что хранится в переменной $a (в данном случае - это 'b') и создаём переменную с таким названием, и присваиваем ей значение 123 (получается - $b = 123;) - это нужно будет позже для работы с массивами чтобы динамически определять название каких-то элементов массива

************************************

008_Типы данных в PHP
https://youtu.be/cxo9VVLLSsc?si=qwtGRM61baFh-pI9
+
документация по типам данных - 
php.net/manual/en/language.types.type-system.php
- документацию лучше читать на английском, потому что если спросят что такое enums, то ты не сможешь ответить, так как читал про перечисления 
+
тип данных - это описание вида данных + инструменты для работы с ними
+
--
asfjktrff - это какие то буквы 
123 523 8756 3452567 - это какие то числа 
- а какие инструменты для работы с числами ты знаешь? 
- я знаю: +, -, и т.п.
1 + 2
3 - 4
----
+
языки со статической типизацией проверяют тип переменной в момент компиляции, а с динамической это происходит на ходу
пример -
- php  : $k = 1;
- java : int k = 1;
+
плюсы динамической типизации - 
- быстрее писать код 
минусы динамической типизации - 
- работа с памятью
- сложно делать высоконагруженные сервисы
- некоторые вопросы безопасности
+
--
# Типы данных 

# null type / null НЕ РАВНО нулю
# так как ноль - это уже данные
# а null - это отсутствие данных
--
$x = null;
----

#array type (массивы, пакет с пакетами)
--
$e = [7, 'Hello', 'Bye', null, 3.111, [1,2,54,6], -7];
----

#Scalar types:

#bool type -- true, false 
--
$a = true;
----

#int type - 1, 2, -4, 555 
--
$b = 2;
----

#float type - 1.2, 0.99, -15.03 
--
$c = 3.11;
----

#string type -- 'asaqwertyuio123'
--
$d = 'asaqwertyuio123';
----
+
узнать какого типа у нас переменная - 
--
$a = true;
$b = 2;
$c = 3.11;
$d = 'asaqwertyuio123';
$e = [7, 'Hello', 'Bye', null, 3.111, [1,2,54,6], -7];
$x = null;

echo gettype($a);
echo gettype($b);
echo gettype($c);
echo gettype($d);
echo gettype($e);
echo gettype($x);

# или -
print_r(var_dump($a));
print_r(var_dump($b));
print_r(var_dump($c));
print_r(var_dump($d));
print_r(var_dump($e));
print_r(var_dump($x));
----
booleanintegerdoublestringarrayNULLbool(true)
int(2)
float(3.11)
string(15) "asaqwertyuio123"
array(7) {
.....
}
NULL
------
+
через echo нельзя вывести массив - 
--
echo $e;
---- 
- будет ошибка
+
массив можно вывести так -
--
print_r($e);
----	
или так - 
--
var_dump($e);
----
+
приведение типов данных -
--
$m = '123';
echo gettype($m);
echo gettype((int)$m);
echo gettype($m);
----
stringintegerstring
------
+
как работает функция - 
--
$a = 1;
$b = '7';
var_dump($a, $b);
echo '<br>';

function summ($a, $b)
{
    var_dump($a, $b);
    echo '<br>';
    return $a + $b;
}

echo summ($a, $b);
----
- тут явно указывается какого типа переменные передаются в функцию и приведение типов происходит автоматически (когда складываем число со строкой, но только если в строке число)
+
но можно запретить автоматическое преведение типов, вверху файла нужно прописать так - 
--
<?php 

declare(strict_types=1);

......
----
- скорее всего в реальной работе ты это будешь использовать везде 

************************************

009_Тип данных Boolean в PHP
https://youtu.be/fHu_NKpraV4?si=bbfY7PqwNGUD3Ixo
+
boolean (bool) - логический тип - true или false 
+
значение можно писать TRUE, True, true - и будет работать 
+
--
<?php 

// bool

$isReady = false;

echo $isReady

if ($isReady) {
    echo 'Yes';
} else {
    echo 'No';
}
----
- если присвоить $isReady разные значения - цифры, строки, массивы и тд. -
+
false = 0
false = -0
false = 0.0
false = -0.0
false = null
false = []
false = ''
false = '0'
а всё остальное - будет true

************************************

010_Тип данных Integer в PHP
https://youtu.be/d2xRys9pCL4?si=Qv6Vpljiq9P0Gl22
+
--
<?php 

// integer 

$a = (int)'-234';  // приведение типа str к int
$b = (int)'abcde';
$c = (int)'567.99';
$d = (int)true;

var_dump($a);
var_dump($b);
var_dump($c);
var_dump($d);
----
int(-234)
int(0)
int(567)
int(1)
------
+
существует максимальное число в int - 9223372036854775807 -
--
<?php 

$x = PHP_INT_MAX;

var_dump($x);

$x = 92233720368547758070000000000000;

var_dump($x);
----
int(9223372036854775807)
float(9.223372036854776E+31)
------
- можно задать и больше, но тогда тип уже будет не int а float
+
можно записывать так -
--
<?php 

$x = 100_000_000;

var_dump($x);
----
int(100000000)
------
+
запись числа в бинарном(двоичном) формате и 16-тиричном формате -
--
<?php 

$x = 0b010101;
$y = 0x2A;

var_dump($x);
var_dump($y);
----
int(21)
int(42)
------

************************************

011_Тип данных float в PHP
https://youtu.be/NDx0OM4KuNU?si=oJKCVzuxWDaLjMBH
+
--
<?php 

// float 

$x = 30.1;

var_dump($x);
----
+
можно записывать так - $x = 30_000.123;
+
или так - 
--
<?php 

// float 

$x = 3312.1e4;

var_dump($x);
----
float(33121000)
------
+
Но с float есть некоторые странности:
+
представим что в переменную $a нам нужно положить выражение (0.1 + 0.3) * 10 и всё это ещё и округлить - 
--
<?php 

$a = floor((0.1 + 0.7) * 10);

var_dump($a);
----
float(7)
------
+
--
<?php 

$a = 0.23;
$b = 1 - 0.77;

if ($a === $b) {
    echo 'Ravni';
} else {
    echo 'Ne ravni';
}
----
Ne ravni
------
- когда работаешь с float нельзя сравнивать значения и точно полагаться на вычисления, так как это проблема с плавающей точкой 
+
еще во float можно запихнуть значения NAN(когда во время вычислений получилось что-то странное) и INF(бесконечность) - 
--
<?php 

$a = NAN;
$b = INF;

var_dump($a);
var_dump($b);
----
float(NAN)
float(INF)
------
+
--
<?php 

// максимальное значение типа float - 
$x = PHP_FLOAT_MAX;
$y = $x * 10;

var_dump($x);
var_dump($y);
----
float(1.7976931348623157E+308)
float(INF)
------
- если мы увеличим максимальное возможное число и попытаемся его сохранить, то PHP нам скажет что это бесконечность 

************************************

012_Тип данных string в PHP
https://youtu.be/5cebKVbBT2M?si=HGdghhgVlMpCHxxr
+
строка - это последовательность символов 
+
<?php 

// string 

$firstName = 'Vasya';
$firstName2 = ' Vasya';
$firstName3 = '                                Vasya';
$lastName = 'Pypkin';



var_dump($firstName);
var_dump($firstName2);
var_dump($firstName3);
----
string(5) "Vasya"
string(6) " Vasya"
string(37) "                                Vasya"
------
+
две переменные можно использовать внутри двойных кавычек, но с одинарными так не получится -
--
<?php 

// string 

$firstName = 'Vasya';
$lastName = 'Pypkin';

$fullName = "$firstName $lastName";
// - либо так, это то же самое - 
$fullName = "{$firstName} {$lastName}";

var_dump($fullName);
----
string(12) "Vasya Pypkin"
------
+
еще конкатенацию (склеивание строк) можно сделать через точку - 
--
$fullName = $firstName.' '.$lastName;
----
+
символ строки можно получить через индекс - 
--
<?php 

$firstName = 'Vasya';

echo $firstName[0] . '<br>';
echo $firstName[1] . '<br>';
echo $firstName[2] . '<br>';
echo $firstName[-1] . '<br>';
----
V<br>a<br>s<br>a<br>
------
+
если при обращении указан несуществующий индекс, то код сработает, но возникнет странная ситуация - 
--
<?php 

$firstName = 'Vasya';

echo $firstName;
$firstName[0] = '!';
echo $firstName;
// - тут всё сработает как нужно 

$firstName[30] = 'A';

var_dump($firstName);
----
Vasya!asyastring(31) "!asya                         A"
------
+
ещё есть альтернативные методы написания строк, эти два способа используются для динамического построения HTML, в проектах встречаются редко - 
--
--
<?php 

$firstName = 'Vasya';

// Nowdoc
$a = <<<'TEXT'
asdfg
 tydh 
uufjthg
          itufhgbvn
TEXT;

// Heredoc 
$a = <<<TEXT 
aaaaaa
   ddddddd
  cccccc
ttt $firstName
TEXT;
----
- если TEXT вверху без кавычек, то можно в тексте указывать переменные, и в указанных случаях сохраняется фрматирование 

************************************

013_Все про массивы в PHP
https://youtu.be/oZBR-u3QG7o?si=bI27RJ9W3V_GSGaV
+
--
<?php

// массивы 

$player1 = 'Vasia'; 
$player2 = 'Kolia'; 
$player3 = 'Alex'; 

// создание массива - 
$players = ['Vasia', 'Kolia', 'Alex'];
$players = array('Vasia', 'Kolia', 'Alex');

// вывод на экран -
echo '<pre>';
print_r($players);
echo '</pre>';

// доступ к элементу - 
echo $players[0];

// проверяем существует ли - 
var_dump(isset($players[0]));

// считаем - 
echo count($players);

// добавить в конец массива новый элемент - 
--
echo '<pre>';
print_r($players);
echo '</pre>';

$players[] = 'Abcdefghi';

echo '<pre>';
print_r($players);
echo '</pre>';
----

// добавить несколько значений в конец массива через array_push -
--
echo '<pre>';
print_r($players);
echo '</pre>';

array_push($players, 'Sasha', 'Max');

echo '<pre>';
print_r($players);
echo '</pre>';
----

// удалить с конца массива последний элемент через array_pop - 
--
echo '<pre>';
print_r($players);
echo '</pre>';

var_dump(array_pop($players));
$x = var_dump(array_pop($players));
echo $x;

echo '<pre>';
print_r($players);
echo '</pre>';
----
- и также переменной можно присвоить последний элемент удаленный из массива 

// удалить из начала массива с помощью array_shift -
--
echo '<pre>';
print_r($players);
echo '</pre>';

array_shift($players);

echo '<pre>';
print_r($players);
echo '</pre>';
----
- соответственно после удаления индексы пересчитываются, индексы пересчитываются не всегда, но в случае с array_shift они пересчитываются 

// многомерные массивы -
--
$players = [
           ['A', 'B', 'C'],
           ['D', 'E', 'F'],
           ['G', 'H', 'I'],
];

echo '<pre>';
print_r($players);
echo '</pre>';

echo $players[2][0];
----
- номер массива и номер элемента в нужном массиве 

// ассоциативные массивы, когда в качестве индекса стоит не цифра а что-то другое (похоже на словарь в python) - 
--
$playersStatus = [
    'Vasia' => 'online', 
	'Fedia' => 'offline'
];

echo '<pre>';
print_r($playersStatus);
echo '</pre>';

echo $playersStatus['Vasia'];
echo $playersStatus['Fedia'];
----
- обращаться можно не по индексу а по имени(ключу)

пример многомерного массива для игры - 
--
$players = [
    'Alex' => [
	    'Nickname' => 'Simple', 
		'Status' => 'Online',
		'Matches' => [
		    ['type' => 'rating', 'result' => 'loss'],
		    ['type' => 'rating', 'result' => 'loss'],
		    ['type' => 'rating', 'result' => 'win'],
		],
		'Hero' => 'Rudgers',
    ],
    'Jon' => [...],
	'Pen' => [...],
];


// обращение к элементам массива - 
print_r($players['Alex']['Nickname']);
print_r($players['Alex']['Matches'][2]['result']);
----

// индексация и некоторые ньюансы в ней - 
--
$players = [
    0 => 'A',
	1 => 'B',
	1 => 'C'
];

echo '<pre>';
print_r($players);
echo '</pre>';
----
<pre>Array
(
    [0] => A
    [1] => C
)
</pre>
------
- если ключи дублируются, то выведется только первый элемент 

// тут сработает приведение типов - 
--
$players = [
    1 => 'A',
	'1' => 'B',
	true => 'C'
];

echo '<pre>';
print_r($players);
echo '</pre>';
----
<pre>Array
(
    [1] => C
)
</pre>
------

// странность с индексацией в PHP - 1, 2, 220, 221 - 
--
$array = ['a', 'b', 220 => 'c', 'd'];

echo '<pre>';
print_r($array);
echo '</pre>';
----
<pre>Array
(
    [0] => a
    [1] => b
    [220] => c
    [221] => d
)
</pre>
------

array_shift - убирает первый элемент и переиндексирует массив - 
--
$array = ['a', 'b', 220 => 'c', 'd'];

echo '<pre>';
print_r($array);
echo '</pre>';

array_shift($array);

echo '<pre>';
print_r($array);
echo '</pre>';
----
<pre>Array
(
    [0] => a
    [1] => b
    [220] => c
    [221] => d
)
</pre><pre>Array
(
    [0] => b
    [1] => c
    [2] => d
)
</pre>
------

если с помощью unset удалить по ключу 220 элемент массива, то индекс 221 не переиндексируется - 
--
$array = ['a', 'b', 220 => 'c', 'd'];

echo '<pre>';
print_r($array);
echo '</pre>';

unset($array[220]);

echo '<pre>';
print_r($array);
echo '</pre>';
----
<pre>Array
(
    [0] => a
    [1] => b
    [220] => c
    [221] => d
)
</pre><pre>Array
(
    [0] => a
    [1] => b
    [221] => d
)
</pre>
------

// приведение к типам - 
--
$a = 123486473;
var_dump((array)$a);
----
array(1) {
  [0]=>
  int(123486473)
}
------
- создался массив с одним элементом - переменной $a 

если переменная - это типа пакет, куда можно положить значение, то массив - это пакет с пакетами, список где что-то лежит, не важно какого типа, в одном массиве могут быть разные типы данных 

вывести на экран массив через echo не получится, для вывода используются var_dump() либо print_r 

при использовании print_r для наглядности лучше обернуть в тег <pre> ... </pre>

нумерация в массиве начинается не с 1 а с 0

в отличие от строк обращение к последнему элементу массива через индекс [-1] не сработает 

проверить существует ли элемент массива по индексу элемента -
var_dump(isset($players[0]));

************************************

014_Все про null в PHP
https://youtu.be/N8HuSmrTpbc?si=CRoqJS9fuC_pgnp0
+
null - это не какое-то значение, это отсутствие любой информации (не путать с нулем, ноль - это тоже информация)
+
можно записывать и так и так - 
--
$x = null;
$y = NULL;
----
+
--
<?php 

// null 

$x = null;

var_dump($x);
----
+
любая переменная является null если её не существует 
+
unset() - разрушает переменную и оставляет в ней null - 
--
<?php

$x = 123;
var_dump($x);

unset($x);
var_dump($x);
----
int(123)

Warning: Undefined variable $x in /home/user/scripts/code.php on line 7
NULL
------
+
проверить является ли переменная null можно с помощью is_null() -
--
<?php

$x = null;
$y = 123;

var_dump(is_null($x));
var_dump(is_null($y));
----
bool(true)
bool(false)
------
+
в PHP можно сравнивать что угодно, есть строгое === и нестрогое == сравнения (при нестрогом осуществляется преобразование типов, то есть "1" и 1 будут равны, а при строгом не будут) - 
--
<?php 

$x = NULL;
$y = 0;

var_dump($x === $y);
echo "<br>";
var_dump($x == $y);
----
bool(false)
<br>bool(true)
------

************************************

015_Настройка PHP Storm 
https://youtu.be/_wHiNCARPWA?si=NsCGOC8L_h7Hj9Uu
+
горячие клавишы PHP Storm - 
распечатать листок с сочетаниями горячих клавиш и положить на рабочее место 
автор сам так делал когда учил linux bash 
+
ссылка на лист - 
https://resources.jetbrains.com/storage/products/phpstorm/docs/PhpStorm_ReferenceCard.pdf
+
еще погуглить по запросу - 
phpstorm cheat sheets 
+
потом нужно настроить среду разработки 
+
те плагины которые необходимы php storm будет сам предлагать - внизу справа будут всплывать уведомления с предложениями установить плагины 
+
Settings - Appearance - там посмотреть что там есть 
+
Settings - Appearance - Plugins - посмотреть что есть в плагинах и как они устанавливаются

************************************

016_Операторы в PHP 
https://youtu.be/T63g6x09Ilk?si=w_jWVjkvtlAzyP4W
+
--
<?php  

// операторы 

// числовые * ** + - / %, модуль 
// приведение, inf(fdiv)

$x = 10;
$y = 2;

var_dump($x + $y);
var_dump($x - $y);
var_dump($x * $y);

var_dump($x / $y);
var_dump($x / 3);
var_dump($x / 2.0);
----
int(12)
int(8)
int(20)
int(5)
float(3.3333333333333335)
------
+
// при делении на ноль будет ошибка 
+
inf(fdiv) - что это такое -
+
inf — это представление бесконечности в PHP.
В PHP inf — это специальная константа, которая представляет бесконечность. Она используется, когда результат вычисления выходит за пределы представимых чисел. Например, если мы делим число на ноль, то результат будет бесконечность.
Пример использования inf -
--
<?php
// Делим 1 на 0
$result = 1 / 0;

if (is_infinite($result)) {
    echo "Результат деления 1 на 0: " . $result . " (это бесконечность)\n";
} else {
    echo "Результат: " . $result . "\n";
}
----
- В этом примере, когда мы делим 1 на 0, результат будет INF, и мы можем проверить это с помощью функции is_infinite()
+
fdiv — это функция, которая позволяет безопасно делить числа, возвращая INF в случае деления на ноль.
Функция fdiv в PHP используется для безопасного деления двух чисел. Она возвращает результат деления, а если делитель равен нулю, то вместо ошибки возвращает INF или -INF, в зависимости от знака делимого.
Пример использования fdiv -
--
<?php
// Используем fdiv для деления
$result1 = fdiv(1, 0); // Делим 1 на 0
$result2 = fdiv(1, 2); // Делим 1 на 2

echo "Результат 1 / 0: " . $result1 . "\n"; // Это будет INF
echo "Результат 1 / 2: " . $result2 . "\n"; // Это будет 0.5
----
- В этом примере, когда мы используем fdiv(1, 0), результат будет INF, а fdiv(1, 2) вернет 0.5
+
в гугл - документация - php operator 
+
--
<?php

$x = 10;
$y = 2;

var_dump($x % $y);
var_dump($x % 3);



// присваивание = += -= /= %= *= = 

$x = 1;

$x = $x + 5;
$x += 5;
$x -= 10;
$x = $y = 2;   // - тут обе переменные станут равны 2
$x = (%y = 3) - 2;   // - так лучше не делать 
----
- знак = означает что то что находится слева засунет в себя то, что находится справа 
+
--
// сравнение == === != !== <> < > <= => <=> 
// ?? и ? - рассмотрим позже 

$x = 1;
$y = '1';

var_dump($x == $y);   // нестрогое сравнение 
var_dump($x === $y);   // строгое сравнение

var_dump($x != $y);    // нестрого не равны 
var_dump($x <> $y);    // нестрого не равны 
var_dump($x !== $y);   // строго не равны 
----
bool(true)
bool(false)

bool(false)
bool(false)
bool(true)
------
- при нестрогом сравнении данные будут приведены к одному типу и потом уже будут сравниваться 
+
если возможно  - всегда использовать строгое сравнение - ===
+
оператор "спейшел" - <=> - 
--
$a = 1;
$b = 3;

//$a = $b = 5;
//$a = 10;
//$b = 3;

var_dump($a <=> $b);
----
int(-1)
// если переменные равны - выдаст 0 
// если переменная слева больше чем переменная справа - выдаст 1

************************************



























