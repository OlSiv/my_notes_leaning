
Armani - java + kotlin + android - 
https://github.com/johnnysc
https://github.com/JohnnySC/Lectures

java compile online -
online-java.com

************************************

Java - 1 - 

--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
----
Hello World!
------

************************************

Java - 2 - 

название класса должно совпадать с именем файла

создаем файл с расширением .java и имя этого файла должно совпадать с именем класса который в нем написан

мы пишем имя класса с заглавной буквы

первой линией кода должно быть обьявление класса

в файле под названием Main.java ожидается первой линией кода объявление class Main

На самом деле наше разделение на линии условное. Мы можем написать весь наш код на одной линии, но не особо удобно читать. Поэтому мы и переносим код на другую линию. 

сначала компилятор ищет класс с тем же названием что и имя файла, после чего ищет мейн метод (метод и функция это одно и то же и означает код, который что-то реально делает)

Первое слово System. Заметьте, что оно написано с заглавной буквы. И как мы уже сегодня поняли – с заглавной буквы называются классы. Значит, в языке java есть некий класс с именем System. После идет точка. Что же она делает? Она дает доступ к другим классам. Сложно? Вовсе нет. Мы говорили, что в файле может быть больше 1 класса. В данном случае где-то внутри джавы есть классы, которые дают возможность выводить в консоль(на экран) что-то. Итак, после идет out. Чисто логически можно догадаться, что это нечто, что дает 
конкретный доступ к выводу. После уже идет сама функция/метод println. Мы уже говорили про исполняемую функцию. Ее отличие от всех других функций в том, что она исполняется когда мы жмем на кнопку Run и хотим выполнить наш код. т.е. где-то там в языке есть метод, который выводит на экран строку и называется println. После идут круглые скобки. Посмотрите на нашу мейн функцию. Там то же самое – имя функции и после идут круглые скобки. Все что внутри этих круглых скобок называется аргумент. В нашем случае, у функции println аргументом является строка. Точно так же как и с фигурными парными 
скобками, у нас должны быть парные круглые скобки и конечно же двойные кавычки. 

************************************

Java - 3 -

1. Исполняемая функция и исполнение функций
2. Истинное предназначение функций, аргументы

рассмотрим функции (они же методы)

Мы уже выяснили, что менять в исполняемой функции ничего нельзя (мы про public static void main(String[] args) {}). И мы знаем, что класс начинается с имени и фигурной ). И мы знаем, что класс начинается с имени и фигурной скобки и заканчивается закрывающейся фигурной скобкой. В данном случае между линиями 2 и 6 может быть что угодно. Например… исполняемая функция

Мы уже говорили, что код будет выполняться только в методе мейн, потому что 
только он исполняется. т.е. все остальное будет просто лежать там мертвым грузом. Но как мы можем сделать так, чтобы другие функции тоже выполнялись? Давайте подумаем логически. Если мы точно знаем, что выполняется мейн метод, т.е. все что там будет написано будет исполняться, то и следовательно нужно как-то вызвать методы там, по аналогии с System.out.println() -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
    void show() {
        System.out.println("Alex");
    }
}
----
Hello World!
------

я не убрал ключевое слово void, но вы можете это сделать и увидете ошибку о том, что функция должна иметь возвращаемый тип. Что это такое мы поговорим позже, когда пройдем типы. А для старта просто считайте что void означает функция, которая что-то делает. Теперь, давайте по аналогии с System.out.println вызовем нашу функцию -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        show();
    }
    void show() {
        System.out.println("Alex");
    }
}
----
-  получаем ошибку. В ней говорится, что мы не можем вызывать (т.е. 
использовать) нестатичную функцию внутри статичной. Т.е. если говорить простыми словами, так как наша мейн функция имеет в себе ключевое слово static, то и все другие функции должны быть так же static (это очень простое обьяснение которое не должно вас сейчас грузить, а дать минимальное понимание для того чтобы уметь использовать его по назначению, позже мы подробно остановимся на этом слове). Следовательно, нам нужно добавить в обьявеление нашего метода слово static по аналогии с мейн -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        show();
    }

    static void show() {
        System.out.println("Alex");
    }
}
----
Hello World!
Alex
------

наш компилятор читает код сверху вниз, так? Да, это так. Сначала он ищет наш мейн метод. Когда находит линию 3, то он идет внутрь, то есть читает линию 4. Там у нас вывод Hello World. Мы видим в консоли  это. А что же дальше? Дальше он идет на линию 5 и там видит вызов функции show(). После 
этого компилятор ищет наш метод show и находит его на линии 8 и так как компилятор выполняет все, что написано внутри метода мейн, то он и должен выполнить вызов функции show(). Следовательно читает код на линии 9 и выводит вторую строку. Теперь мы можем добавить еще код в метод show и он тоже будет исполняться до тех пор пока мы вызываем его в методе мейн. Вроде несложно, правда? Ведь мы могли бы не создавать метод show и просто выводить на экран 2 строки друг за другом, нет никакой разницы между этим кодом и кодом, где мы написали новую функцию show. Ведь результат не поменялся, мы имеем 2 строки в консоли. Тогда зачем мы создали наш метод show? Согласен, особого толку в нем нет, кроме того, что мы показали как можно создавать новые функции и вызывать их в мейн методе

Что мы видим? Мы видим что 2 раза вызывется длинная функция System.out.println(). Т.е. если бы нам нужно было вывести не 2 
строки на экран, а 20, то мы бы писали 20 раз System.out.println? Это было бы в тягость, согласны? Так в чем же истинное предназначение функций? А в том, чтобы не только бездумно выполнять код, а упрощать жизнь разработчику/программисту. И давайте зададим себе такой вопрос – а мы не могли написать такой метод, который бы помог нам не писать это длинное System.out.println()? И здесь мы познакомимся подробнее с такой вещью как 
аргумент функции. Если посмотреть внимательно, то в мейне есть аргумент функции – String[] args. String это класс строки. Квадратные скобки означают массив, но о них мы поговорим чуть позже. И args просто имя аргумента мейн функции, просто сокращение от аргументы. Ранее мы написали метод show() и внутри круглых скобок ничего не было. т.е. мы вызывали наш метод show и не передавали в него никакие аргументы. Потому что наш метод 
делал лишь одно действие – выводил на экран строку

Теперь, можем ли мы написать такой метод, который бы выводил на экран строку, которую мы передадим в аргументе -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        print("Hello World!");
        print("O-la-la");
    }

    static void print(String text) {
        System.out.println(text);
    }
}
----
Hello World!
O-la-la
------
- но если а main в функцию print не передать аргумент, то будет ошибка,  если мы не передадим никакую строку в метод print, то он не будет знать что делать в этом случае. Так как его единственная задача вывести на экран эту строку. Кстати, не путайте пожалйста System.out.println и print. Первое это системный метод вывода на экран, а второе наш вспомогательный метод, который упрощает нам жизнь

что мы называем строкой. Строка (String) в языке Java это  все, что обрамлено с 2 сторон двойными кавычками

Если в строку ничего не передавать - то это будет пустая строка - "". Когда между двойными кавычками просто ничего нет. Попробуйте переместить вызов функции print на линии 6 между 4 и 5 и вы увидете на экране пустую строку между первой и второй. Кстати, так как пустая строка имеет право на 
существование, то мы часто будем проверять на пустоту любую строку перед тем как ее использовать. Зачем? А чтобы не возникало таких ситуаций, когда мы в консоль пишем пустоту. Ведь зачем лишний раз выполнять то, что не имеет значения?

************************************

Java - 4 -

=







































