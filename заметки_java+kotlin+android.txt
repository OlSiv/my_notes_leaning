
Armani - java + kotlin + android - 
https://github.com/johnnysc
https://github.com/JohnnySC/Lectures

java compile online -
online-java.com

************************************

Java - 1 - 

--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
----
Hello World!
------

************************************

Java - 2 - 

название класса должно совпадать с именем файла

создаем файл с расширением .java и имя этого файла должно совпадать с именем класса который в нем написан

мы пишем имя класса с заглавной буквы

первой линией кода должно быть обьявление класса

в файле под названием Main.java ожидается первой линией кода объявление class Main

На самом деле наше разделение на линии условное. Мы можем написать весь наш код на одной линии, но не особо удобно читать. Поэтому мы и переносим код на другую линию. 

сначала компилятор ищет класс с тем же названием что и имя файла, после чего ищет мейн метод (метод и функция это одно и то же и означает код, который что-то реально делает)

Первое слово System. Заметьте, что оно написано с заглавной буквы. И как мы уже сегодня поняли – с заглавной буквы называются классы. Значит, в языке java есть некий класс с именем System. После идет точка. Что же она делает? Она дает доступ к другим классам. Сложно? Вовсе нет. Мы говорили, что в файле может быть больше 1 класса. В данном случае где-то внутри джавы есть классы, которые дают возможность выводить в консоль(на экран) что-то. Итак, после идет out. Чисто логически можно догадаться, что это нечто, что дает 
конкретный доступ к выводу. После уже идет сама функция/метод println. Мы уже говорили про исполняемую функцию. Ее отличие от всех других функций в том, что она исполняется когда мы жмем на кнопку Run и хотим выполнить наш код. т.е. где-то там в языке есть метод, который выводит на экран строку и называется println. После идут круглые скобки. Посмотрите на нашу мейн функцию. Там то же самое – имя функции и после идут круглые скобки. Все что внутри этих круглых скобок называется аргумент. В нашем случае, у функции println аргументом является строка. Точно так же как и с фигурными парными 
скобками, у нас должны быть парные круглые скобки и конечно же двойные кавычки. 

************************************

Java - 3 -

1. Исполняемая функция и исполнение функций
2. Истинное предназначение функций, аргументы

рассмотрим функции (они же методы)

Мы уже выяснили, что менять в исполняемой функции ничего нельзя (мы про public static void main(String[] args) {}). И мы знаем, что класс начинается с имени и фигурной ). И мы знаем, что класс начинается с имени и фигурной скобки и заканчивается закрывающейся фигурной скобкой. В данном случае между линиями 2 и 6 может быть что угодно. Например… исполняемая функция

Мы уже говорили, что код будет выполняться только в методе мейн, потому что 
только он исполняется. т.е. все остальное будет просто лежать там мертвым грузом. Но как мы можем сделать так, чтобы другие функции тоже выполнялись? Давайте подумаем логически. Если мы точно знаем, что выполняется мейн метод, т.е. все что там будет написано будет исполняться, то и следовательно нужно как-то вызвать методы там, по аналогии с System.out.println() -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
    void show() {
        System.out.println("Alex");
    }
}
----
Hello World!
------

я не убрал ключевое слово void, но вы можете это сделать и увидете ошибку о том, что функция должна иметь возвращаемый тип. Что это такое мы поговорим позже, когда пройдем типы. А для старта просто считайте что void означает функция, которая что-то делает. Теперь, давайте по аналогии с System.out.println вызовем нашу функцию -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        show();
    }
    void show() {
        System.out.println("Alex");
    }
}
----
-  получаем ошибку. В ней говорится, что мы не можем вызывать (т.е. 
использовать) нестатичную функцию внутри статичной. Т.е. если говорить простыми словами, так как наша мейн функция имеет в себе ключевое слово static, то и все другие функции должны быть так же static (это очень простое обьяснение которое не должно вас сейчас грузить, а дать минимальное понимание для того чтобы уметь использовать его по назначению, позже мы подробно остановимся на этом слове). Следовательно, нам нужно добавить в обьявеление нашего метода слово static по аналогии с мейн -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        show();
    }

    static void show() {
        System.out.println("Alex");
    }
}
----
Hello World!
Alex
------

наш компилятор читает код сверху вниз, так? Да, это так. Сначала он ищет наш мейн метод. Когда находит линию 3, то он идет внутрь, то есть читает линию 4. Там у нас вывод Hello World. Мы видим в консоли  это. А что же дальше? Дальше он идет на линию 5 и там видит вызов функции show(). После 
этого компилятор ищет наш метод show и находит его на линии 8 и так как компилятор выполняет все, что написано внутри метода мейн, то он и должен выполнить вызов функции show(). Следовательно читает код на линии 9 и выводит вторую строку. Теперь мы можем добавить еще код в метод show и он тоже будет исполняться до тех пор пока мы вызываем его в методе мейн. Вроде несложно, правда? Ведь мы могли бы не создавать метод show и просто выводить на экран 2 строки друг за другом, нет никакой разницы между этим кодом и кодом, где мы написали новую функцию show. Ведь результат не поменялся, мы имеем 2 строки в консоли. Тогда зачем мы создали наш метод show? Согласен, особого толку в нем нет, кроме того, что мы показали как можно создавать новые функции и вызывать их в мейн методе

Что мы видим? Мы видим что 2 раза вызывется длинная функция System.out.println(). Т.е. если бы нам нужно было вывести не 2 
строки на экран, а 20, то мы бы писали 20 раз System.out.println? Это было бы в тягость, согласны? Так в чем же истинное предназначение функций? А в том, чтобы не только бездумно выполнять код, а упрощать жизнь разработчику/программисту. И давайте зададим себе такой вопрос – а мы не могли написать такой метод, который бы помог нам не писать это длинное System.out.println()? И здесь мы познакомимся подробнее с такой вещью как 
аргумент функции. Если посмотреть внимательно, то в мейне есть аргумент функции – String[] args. String это класс строки. Квадратные скобки означают массив, но о них мы поговорим чуть позже. И args просто имя аргумента мейн функции, просто сокращение от аргументы. Ранее мы написали метод show() и внутри круглых скобок ничего не было. т.е. мы вызывали наш метод show и не передавали в него никакие аргументы. Потому что наш метод 
делал лишь одно действие – выводил на экран строку

Теперь, можем ли мы написать такой метод, который бы выводил на экран строку, которую мы передадим в аргументе -
--
Main.java 
--
public class Main {
    public static void main(String[] args) {
        print("Hello World!");
        print("O-la-la");
    }

    static void print(String text) {
        System.out.println(text);
    }
}
----
Hello World!
O-la-la
------
- но если а main в функцию print не передать аргумент, то будет ошибка,  если мы не передадим никакую строку в метод print, то он не будет знать что делать в этом случае. Так как его единственная задача вывести на экран эту строку. Кстати, не путайте пожалйста System.out.println и print. Первое это системный метод вывода на экран, а второе наш вспомогательный метод, который упрощает нам жизнь

что мы называем строкой. Строка (String) в языке Java это  все, что обрамлено с 2 сторон двойными кавычками

Если в строку ничего не передавать - то это будет пустая строка - "". Когда между двойными кавычками просто ничего нет. Попробуйте переместить вызов функции print на линии 6 между 4 и 5 и вы увидете на экране пустую строку между первой и второй. Кстати, так как пустая строка имеет право на 
существование, то мы часто будем проверять на пустоту любую строку перед тем как ее использовать. Зачем? А чтобы не возникало таких ситуаций, когда мы в консоль пишем пустоту. Ведь зачем лишний раз выполнять то, что не имеет значения?

************************************

Java - 4 -

Строки и числа

Классы строк и чисел

Содержание
1. Переходим от веб-сайта к продвинутой среде разработки
2. Складываем строки, введение в числа
3. Складываем числа

вбейте в гугл intellij idea, скачайте и установите бесплатную версию Community Edition

создайте проект и в папке src создайте java class

Давайте поставим курсор на втором слове и нажмем Enter и посмотрим что будет -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        System.out.println("Hello" +
                "world");
    }
}
----
Helloworld
------
- Строка Hello World разделилась на 2 и соединяется знаком +. Это называется конкатенация.

Где же это могло быть полезно? А например в том случае, когда вы пишете очень длинную строку. Или же вы хотите визуально разделить 2 строки

В коде мы можем разделить 1 строку на 5 или 500 штук по 1 букве, но это не значит что в консоли будет больше 1 линии. Знак + в коде лишь для удобочитаемости.

Но мы помним, что если написать 
--
    System.out.println("Hello World!");
    System.out.println("Это моя первая программа на Джава!");
----
- то увидим в консоли 2 строки, одна под другой.

Почему же так? Ведь и там и там 2 строки, строка же это любые символы между двумя двойными кавычками, не? Да, но дело в том, что функция системного класса out.println делает то, что выдает на экран строку в аргументе 
функции и… переносит курсор (каретку… ну фигню эту которая мерцает как в ворде) на следующую линию. И здесь было бы логично задать такой вопрос: ок, а можно как-нибудь не писать 2 раза System.out.println, а юзать его 1 раз и разделить как-нибудь строку на 2? Как будто если бы существовал символ для разделения строки. Вот именно! Такое существует -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        System.out.println("Hello\n" +
                "world");
    }
}
----
Hello
world
------
- в конец первой строки добавили - \n

строки нельзя складывать, отнимать, умножать друг с другом, строки с числами складывать можно 

--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        System.out.println(2 + 2);
    }
}
----
4
------

Integer.valueOf("42") - этот метод позволяет преобразовать строку в число -
-- 
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        System.out.println(Integer.valueOf("42") + 8);
    }
}
----
50
------

String.valueOf(777) - метод, преобразующий число в строку 

представим, что нам нужно в нашей программе складывать 2 числа вместе и выводить их в консоль. Тогда бы нам нужно было бы писать длинное System.out.println, но мы уже научились писать собственные функции, которые упростят нам жизнь. В прошлый раз мы написали функцию, которая принимала бы аргументом 1 строку и ее просто выдавала бы на экран. А можем ли мы сейчас написать функцию, которая бы принимала аргументом 2 числа, и выводила их сумму на экран? Ведь было бы странно, если бы функции принимали лишь 1 
аргумент на вход, не так ли? И если для строки мы пишем тип String, то для числа, как мы уже знаем, есть класс Integer. Ну что ж, пробуем? (Вы можете попробовать сами и после уже свериться с лекцией -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        showSum(5, 15);
    }
    private static void showSum(Integer num1, int num2) {
        System.out.println(num1 + num2);
    }
}
----
20
------
- можно писать как Integer так и int 

Обсудим подробнее код метода showSum. Во-первых вам нужно знать еще одно правило код стайла Джава – принято писать имена методов нижним camelCase. Это когда первое пишем строчной буквой, а второе слово начинается с заглавной буквы, как горб у верблюда (отсюда и название). Далее идут 2 аргумента – Integer number1, Integer number2. Да, как можно было догадаться, если у вас метод принимает более 1 аргумента, то их нужно разделить запятыми. Что касается чисел в названиях аргументов – то да, их можно использовать, но не начинать ими имя аргумента, т.е. не надо делать так – 1number или 2Number

порядок аргументов в Джава важен, т.е. когда вы вызываете метод showSum с аргументами 3 и 4, то компилятор присваивает значение 3 аргументу number1, а 4 аргументу number2. Подумайте как это можно проверить и проверьте это -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        ShowSum(5, 15);
        ShowSum(100, 200);
    }
    private static void ShowSum(Integer Num1, int Num2) {
        System.out.println(Num1);
        System.out.println(Num2);
        System.out.println(Num1 + Num2);
    }
}
----
5
15
20
100
200
300
------
- ключевое слово private мы обсудим попозже, вы можете его не писать совсем

Му узнали из урока - 
для строки есть класс String, а для чисел есть Integer. В котором есть метод преобразования строки в число. К числам можно применить простые арифметические операторы (кстати, вот вам домашнее задание, напишите методы по аналогии с суммой чисел для остальных действий – вычитания, умножения и деления), а строки можно добавлять друг к другу. Так же вы узнали, что кроме класса Integer можно использовать примитив int. И вы должны понимать, что все возможные методы над числами можно найти в классе Integer. А int лишь для обьявление типа числа в аргументах (и не только и об этом будет следующая лекция) 

ДЗ - 
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        ShowSum(10, 5);
        ShowDelen(10, 5);
        ShowUm(10, 5);
        ShowVich(10, 5);
    }
    static void ShowSum(int Num1, int Num2) {
        System.out.println(Num1 + Num2);
    }
    static void ShowDelen(int Num1, int Num2) {
        System.out.println(Num1 / Num2);
    }
    static void ShowUm(int Num1, int Num2) {
        System.out.println(Num1 * Num2);
    }
    static void ShowVich(int Num1, int Num2) {
        System.out.println(Num1 - Num2);
    }
}
----

************************************

Java - 5 -

Типы функций и переменные

Как одно работает со вторым

Содержание -
1. Передаем результат функции в аргумент другой функции
2. Переменные, создание и переименование

void - это означает, что данный метод не будет ничего возвращать 

сделаем часть д/з из предыдущей лекции. Напишем метод, который покажет нам разницу 2 чисел на экран -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        ShowSum(10, 5);
        ShowDiff(10, 5);
    }
    private static void print(int Num3) {
        System.out.println(Num3);
    }
    private static void ShowSum(int Num1, int Num2) {
        print(Num1 + Num2);
    }
    private static void ShowDiff(int Num1, int Num2) {
        print(Num1 - Num2);
    }
}
----

Как видете, числа могут быть и отрицательными, именно поэтому 3 - (-4) будет 7. Все как и в школе, никакой магии. Но наши функции делают 1 действие и выводят результат на экран. А что если нам понадобится сначала произвести одно действие, после второе и уже потом вывести на экран результат? Например рассмотрим такое математическое выражение - 
(a+b)*(c-d)

Согласитесь, мы не можем писать по 100 методов для всех случаев. Нам понадобится всего 3.  Первый метод просто сложит 2 числа, второй метод найдет разницу 2 чисел и уже третий метод перемножит их. И уже потом можно вывести результат на экран. Вообще постарайтесь запомнить простое правило – метод должен делать лишь 1 действие. В нашем случае метод showSum делает как будто бы 1 действие, но на самом деле 2  - ведь сначала он складывает 
числа и уже потом показывает результат на экран. Не надо так. Давайте упростим

Было бы классно, если бы метод смог принять 2 числа и вернуть результат, без показа его непосредственного результата на экран. Настало время вернуться к ключевому слову void. Оно дословно означает пустота. Т.е. метод у которого перед именем написано void (e.g. void showSum) не будет ничего возвращать в место вызова, или же скажем так возвращать пустоту. Что означает вернуть что-то в место вызова? Чуть ниже поймем. А сейчас давайте 
пока перепишем метод showSum так, чтобы он принимал 2 числа и возвращал сумму -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        ShowSum(10, 5);
        print(sum(10, 5));
    }
    private static void ShowSum(int Num1, int Num2) {
        print(Num1 + Num2);
    }
    private static int sum(int Num1, int Num2) {
        return Num1 + Num2;
    }
    private static void print(int Num3) {
        System.out.println(Num3);
    }
}
----
15
15
------
-  Давайте посмотрим на код на линии 10. Мы обьявили функцию int sum(int number1, number2), посмотрите внимательно, теперь вместо void у нас int. Т.е. теперь вместо пустоты наш метод вернет в место вызова число. И давайте посмотрим на код на линии 5. По сути он делает то же самое что и код на линии 4. Просто метод showSum сначала складывает 2 числа и передает результат в аргумент функции print внутри себя, а на линии 5 мы видим следующее -
print(sum(3,4))

По сути происходит следующее -
print(sum(3,4)) → sum(3,4) → print(7)

Запомните, если ваш метод принимает аргумент, а вместо него есть вызов другой функции, то сначала компилятор должен выполнить вызов внутренней функции и только после уже первой.

надеюсь вы заметили ключевое слово return на линии 11. Это и значит – вернуть значение

Можете оставить эту лекцию на время пока сами не напишете код, после вернуться  и проверить правильность -
--
JohnnProj001.java
--
public class JohnnProj001 {
    public static void main(String[] args) {
        print(umn(sum(10, 5), diff(100, 50)));
    }
    private static int sum(int Num1, int Num2) {
        return Num1 + Num2;
    }
    private static int diff(int Num1, int Num2) {
        return Num1 - Num2;
    }
    private static int umn(int Num1, int Num2) {
        return Num1 * Num2;
    }
    private static void print(int Num3) {
        System.out.println(Num3);
    }
}
----
750
------

воспользуемся мощными преимуществами нашей среды разработки. На линии 3 выделите sum(3, 4) как выделяете текст. Нажимаем правый клик мышкой на выделенном участке, в открывшемся меню ищем Refactor, там уже ищем Extract и первая строка Variable (или в новой версии - Refactor - Introduce_Variable). Или же есть горячая клавиша Ctrl+Alt+V. 
И вуаля, мы получаем следующее: результат действия (суммы двух чисел) сохраняется в переменную (сразу можно дать имя этой переменной). Наша среда разработки умная и она видит, что результатом сложения чисел будет число и сразу же создает переменную правильного типа, т.е. int -
--
public class JohnnProj001 {
    public static void main(String[] args) {
        int sum = sum(10, 5);
        print(umn(sum, diff(100, 50)));
    }
...
----

Если вас смущает то, что у нас и имя функции sum и имя переменной sum, то можете дать переменной другое имя. Но не спешите просто набирать с клавиатуры другое имя. Как видете эта переменная используется уже на линии 5. И если вы поменяете имя переменной на линии 4, а на линии 5 не поменяете, то у вас сразу же среда разработки высветит ошибку и  компилятор не исполнит программу. Как же тогда переименовать переменную правильно? 
Точно так же ставим курсор на переменную sum, нажимаем на правый клик, ищем Refactor → Rename или же горячая клавиша Alt+Shift+F6	

Так что постарайтесь сразу запомнить как правильно и безопасно менять имя переменной 

--
public class JohnnProj001 {
    public static void main(String[] args) {
        int sum1 = sum(10, 5);
        int diff1 = diff(100, 50);
        final int umn1 = umn(sum1, diff1);
        print(umn1);
    }
...
----
- вы наверно заметили что среда разработки при выделении переменной дает 
возможность не только дать ей имя, но и сделать ее final. Обьясню это в следующих лекциях

ДЗ - 
--
public class JohnnProj001 {
    public static void main(String[] args) {
        String name1 = "Hello";
        String name2 = "World";
        String name3 = slojen(name1, name2);
        print(name3);
    }
    private static String slojen(String n1, String n2) {
        return n1 + "\n" + n2;
    }
    private static void print(String Num3) {
        System.out.println(Num3);
    }
}
----
Hello
World
------

************************************

Java - 6 -

Переменные: как использовать

Первичная и повторная инициализация переменной

Содержание -
1. Повторное использование и повторная инициализация переменных
2. Запрет на повторную инициализацию переменной

значения переменных можно переприсваивать, а также присваивать переменной значение другой переменной -
--
int num1 = 5;
int num2 = num1;
int num1 = 10;
----

если вы меняете содержимое ящиков, то предыдущий предмет нужно положить в мусорное ведро, для особо интересующихся погуглите - Java Garbage Collecor

Настало время вам рассказать про ключевое слово final если оно написано перед обьявлением переменной, так же как и в Microsoft Word подчеркиваются неправильные слова. Если поставить курсор на эту переменную на линии 10, то можно увидеть подсказку – Cannot assign a value to final variable 
"player1". Что в принципе и высветится если вы нажмете на Run. Т.е. ключевое слово final перед именем переменной означает, что ее нельзя повторно инициализировать. Т.е. менять значение которое находится там. Класть в ящик другой предмет. Считайте что у вас нет прав менять содержимое ящика. Достали предмет, показали на столе (в консоли) и все. Надо класть обратно или выкинуть. Дело в том, что слово final можно писать не только перед именем переменной, но мы пока не будем говорить об этом сейчас, а тогда когда придет время (Забегая вперед его можно писать перед именем класса и методом)

Вообще мы называем переменные, которые обьявлены final константами (подробнее в следующей лекции), т.е. постоянными.

ДЗ - 
--
public class JohnnProj001 {
    public static void main(String[] args) {
        final String name = "John";
        String food1 = "Apple";
        print(res(name, food1));
        food1 = "Banana";
        print(res(name, food1));
        food1 = "Qiwi";
        print(res(name, food1));
    }
    private static String res(String n1, String n2) {
        return n1 + " сьел " + n2 + " и счастлив";
    }
    private static void print(String Num3) {
        System.out.println(Num3);
    }
}
----
John сьел Apple и счастлив
John сьел Banana и счастлив
John сьел Qiwi и счастлив
------

************************************

Java - 7 -

Область видимости переменной

Где доступна переменная. Еще 2 типа

Содержание -
1. Переменные внутри метода и вне
2. Еще 2 типа переменных 

--
public class JohnnProj001 {

    private static final String NAME = "John";

    public static void main(String[] args) {
        String food1 = "Apple";
        print(res(food1));
        food1 = "Banana";
        print(res(food1));
        food1 = "Qiwi";
        print(res(food1));
    }

    private static String res(String n1) {
        return NAME + " сьел " + n1 + " и счастлив";
    }

    private static void print(String Num3) {
        System.out.println(Num3);
    }
}
----
- Мы просто взяли и подняли обьявление и инициализацию имени над методом мейн. И опять же, чтобы суметь использовать его в статик методах, нужно чтобы оно было статик. И посмотрите теперь на вызов метода res и на него самого. Мы используем имя в методе не передавая его в аргументы. В этом и вся суть области видимости переменной. Если она обьявлена внутри метода (например мейн), то она видна и доступна только внутри этого метода, т.е. до закрывающей фигурной скобки. А если она обьявлена вне методов, то и 
доступа в любых других методах этого класса. То же самое и про аргументы, но это слишком ясно чтобы обьяснять (food1 доступен только внутри метода res).

Вообще постарайтесь запомнить private static final String (int) это константа и ее нужно  писать капс локом – только заглавными буквами. Такой вот джава код-стайл. Но если у вас не final переменная, т.е. не константа, то и писать ее капсом не нужно. 

int, float и double - 
можно поменять одно из двух чисел на десятичную и все. т.е. в джава есть такая штука как переход к большему. Если ты складываешь десятичное число и целое, то ты получаешь десятичное. 

В float нам нужно писать букву f в конце числа, в double не нужно 

--
public class JohnnProj001 {

    public static void main(String[] args) {
        int a = 10;
        float b = 4.5f;
        double c = 1.2345;
        showDiv1(a, b);
        showDiv2(b, c);

    }
    private static void showDiv1(int n1, float n2) {
        System.out.println(n1/n2);
    }
    private static void showDiv2(float n1, double n2) {
        System.out.println(n1/n2);
    }
}
----
2.2222223
3.6452004860267317
------
- вы заметили результат деления 5 на 3 для первого случая и второго? В первом случае float после точки 7 цифр всего, а у double побольше точности. Но и цена этой точности конечно же есть. Если вы используете double, то вы запрашиваете в 2 раза больше места у вашего железа для этих целей. Так что в иной раз будьте внимательны к тому, какой тип переменной вы используете. 

Какие значения может принимать int, float, double? Для этого и существуют такие классы как Integer, Float, Double. Помните метод, который превращал 
строку (String) в число? Integer.parseInt(String text). Конечно же такие же методы есть и для преобразования десятичного числа -
--
public class JohnnProj001 {

    public static void main(String[] args) {
        showDiv(10, Double.parseDouble("4.25"));
        showDiv(5, Float.parseFloat("3.27"));
    }
    private static void showDiv(int n1, float n2) {
        System.out.println(n1 / n2);
    }
    private static void showDiv(float n1, double n2) {
        System.out.println(n1 / n2);
    }
}
----
2.3529411764705883
1.529052
------
- тут у нас 2 метода showDivide, но у них разные типы второго аргумента, а 
значит они имеют право на существование (это называется перегрузка методов). 

Какие же максимальные и минимальные значения у int,float, double? -
--
public class JohnnProj001 {

    public static void main(String[] args) {
        print("Min of Int is: " + Integer.MIN_VALUE);
        print("Max of Int is: " + Integer.MAX_VALUE);
        print("Min of Float is: " + Float.MIN_VALUE);
        print("Max of Float is: " + Float.MAX_VALUE);
        print("Min of Double is: " + Double.MIN_VALUE);
        print("Max of Double is: " + Double.MAX_VALUE);
    }

    private static void print(String vall) {
        System.out.println(vall);
    }
}
----
Min of Int is: -2147483648
Max of Int is: 2147483647
Min of Float is: 1.4E-45
Max of Float is: 3.4028235E38
Min of Double is: 4.9E-324
Max of Double is: 1.7976931348623157E308
------
- Если вы работаете с числами в пределах 2 миллиардов, то вам можно взять int. Если же у вас числа побольше, то берите float. Если уж совсем огромные, то double. Что делать в случае если титанические числа? Для этого есть свои классы, но оставляю это вам на самостоятельное гугление. 
-
В Java нет примитивного типа данных, который был бы больше double. Тип double занимает 8 байт (64 бита) и предназначен для представления чисел с плавающей точкой двойной точности. Если вам нужно хранить очень большие или очень маленькие числа, или числа с большей точностью, чем может обеспечить double, следует использовать класс java.math.BigDecimal. BigDecimal не является примитивным типом данных, он предназначен для работы с числами произвольной точности, но при этом требует больше памяти и ресурсов. 
В Java есть следующие примитивные числовые типы:
- byte: 1 байт, диапазон значений от -128 до 127.
- short: 2 байта, диапазон значений от -32768 до 32767.
- int: 4 байта, диапазон значений от -2147483648 до 2147483647.
- long: 8 байт, диапазон значений от -9223372036854775808 до 9223372036854775807. 
- float: 4 байта, диапазон значений от -3.4E+38 до 3.4E+38. 
- double: 8 байт, диапазон значений от -1.7E+308 до 1.7E+308. 
- char: 2 байта, представляет один символ Unicode.
- boolean: 1 байт, может принимать значения true или false.
double и float являются типами данных с плавающей точкой, а byte, short, int и long - целочисленными типами. BigDecimal позволяет работать с числами, которые выходят за рамки этих диапазонов и имеют более высокую точность. 

Теперь вернемся к нашей программе, которая производит действия с числами. Давайте напишем перегруженные методы для того, чтобы они работали как с int, так и для float и double. А еще удалите метод print(String) и напишите вместе него 3 других, для разных типов чисел. Ведь если ты не выводишь на экран строку, то тебе и не нужен этот метод, правильно?
--
public class JohnnProj001 {

    public static void main(String[] args) {
        int a = 10;
        float b = 4.5f;
        double c = 1.2345;
        print(showDiv(a, b));
        print(showDiv(b, c));
    }

    private static float showDiv(int n1, float n2) {
        return n1 / n2;
    }

    private static double showDiv(float n1, double n2) {
        return n1 / n2;
    }

    private static void print(int zn1) {
        System.out.println(zn1);
    }

    private static void print(float zn1) {
        System.out.println(zn1);
    }

    private static void print(double zn1) {
        System.out.println(zn1);
    }
}
----

************************************

Java - 8 -

long count = 3456L (после значения - L)

Давайте посмотрим внимательно на максимальные значения int и float. Вам не кажется, что разница между ними огромная? Сами посудите, 2 миллиарда с лишним и 3.4*10^38. Да, если вы не знали, то E38 означает 38 нулей. Это же огромное число. Зачем же мне использовать этот float если мне нужно сохранить всего лишь 3 миллиарда? И ответ на этот вопрос тоже есть. Представляю вашему вниманию еще один тип чисел – Long. Точно так
 же как и с float, это примитив, у которого есть класс. 
А вообще мы бы могли легко проверить это на деле. Давайте создадим int переменную и попробуем в нее сохранить 3 миллиарда. 
Как видим среда разработки подчеркнула наше число и выход из этой ситуации просто поменять int на long. Но как видим что-то пошло не так и ошибка осталась. Почему же? Дело все в том же, ведь как помните, для float мы добавляли букву f в конце чтобы различать тип float от типа double. Точно так же и с long. Нам нужно различать int и long и логично предположить что нужно написать букву l в конце. Попробуйте. И вы узнаете, что оказывается нужна заглавная буква L. Почему же так? А все потому что строчная l очень 
похожа на цифру 1 и чтобы не путать их, решено было использовать заглавную. 

Если нам нужно число больше чем 2 миллиарда то мы не можем использовать int. А что если нам нужна переменная для маленьких чисел? Типа меньше 100. Зачем использовать int? Представьте, что вы кладете в ящик стола маленькую флешку или пуговицу. И ничего кроме нее вы не можете положить туда. 
Согласитесь, нерациональное использование хранилища. И кто-то подумает, ну тогда нам нужно хранилище поменьше для таких вещей и будет совершенно прав. В языке Java специально для маленьких чисел есть тип byte.

Если вы понимаете, что вам нужно хранить максимум число 127, то вам лучше взять тип byte. Ведь он в памяти занимает куда меньше места, чем тот же int. Но давайте поговорим про настоящее использование типа byte в жизни. Рано или поздно вы столкнетесь с такой задачей – прочитать или записать данные. Представьте, что у вас ванна наполнена водой и вам нужно ее оттуда перелить в раковину например. 

Естественно, сделать это сразу не получится. И вы конечно же берете какой-нибудь маленький ковшик и с его помощью переливаете воду из ванны в раковину. Хотя согласен, вылить в раковину это больше похоже на удаление, чем перемещение, но все же. Итак, вы берете ковшик (byte) и опустошаете огромный кусок информации. С одной стороны вы опустошаете огромный кусок информации. С одной стороны вы делаете множество подходов пока не закончите, но с другой стороны вы используете очень мало ресурсов. 1 байт занимает в памяти очень мало места. Можете сами погуглить кстати. 
И опять же встает вопрос, секунду, а что насчет чисел чуть больше 127, но меньше 2 миллиардов? Неужели ничего нет. Конечно же есть. Short. Но скажу вам честно, я очень редко видел использование этого типа данных. Если byte используется для перекачки данных из одного места в другое, а float часто используется в Android (ну как часто, иногда), то использование short я наверно не вспомню за жизнь. Потому что зачастую используются int и double. И да, long для дат в Android. Int для любых чисел целого типа и double для всех чисел с десятичной частью. Но зачем вам знать про эти типы? Возможно вам когда-нибудь встретится short и вы будете знать что это такое.

стр4







































