
https://s1.sharewood.co/threads/stepik-pogruzhenie-v-data-science-i-mashinnoe-obuchenie-2024.453551/

https://cloud.mail.ru/public/y6Cb/g7KcxQq2o

telegram - my_coding - 19.04.2025 

+
[Слёрм] Data Scientist (2024)
-
https://s1.sharewood.co/threads/sljorm-data-scientist-2024.467972
-
https://cloud.mail.ru/public/41FL/QzGVXBhLB

==============================================

1 - 1.1 -

Команды для установки библиотек в Python:
1. pip install numpy
2. pip install pandas
3. pip install colorama
4. pip install requests
5. pip install mysql
6. pip install matplotlib
7. pip install jupyterlab
8. pip install notebook

Библиотеки в PyPI:
1. https://pypi.org/project/Pillow/
2. https://pypi.org/project/matplotlib/
3. https://pypi.org/project/notebook/
4. https://pypi.org/project/pandas/
5. https://pypi.org/project/matplotlib/
6. https://pypi.org/project/jupyterlab/

==============================================

1 - 1.2 -

Инструменты для анализа данных в Data Science включают:

1. Python: Язык программирования, широко используемый в Data Science
благодаря его гибкости, богатому экосистеме библиотек и фреймворков,
таких как NumPy, Pandas, Scikit-learn, TensorFlow, Keras и других.

2. R: Язык программирования и среда для статистического анализа данных. Он
предлагает широкий спектр библиотек для статистического моделирования,
визуализации данных и машинного обучения, таких как ggplot2, dplyr, caret и
других.

3. SQL: Язык структурированных запросов, используемый для работы с 
реляционными базами данных. SQL позволяет извлекать, преобразовывать и
анализировать данные из баз данных.

4. Tableau: Инструмент визуализации данных, который позволяет создавать
интерактивные дашборды и отчеты для визуализации данных и их анализа.

5. Apache Spark: Распределенная платформа для обработки больших данных,
которая предлагает библиотеки для машинного обучения (MLlib), графового
анализа (GraphX) и потоковой обработки данных (Spark Streaming).

6. Jupyter Notebook: Интерактивная среда разработки, которая позволяет
комбинировать код, текст и визуализации в одном документе. Она широко
используется в Data Science для разработки и документирования
аналитических процессов

==============================================

1 - 1.3 -

# это комментарий
или
CTRL + /
или 
'''
........
'''
или 
"""
........
"""
- и в теле функции это докстринг 

В Python docstring игнорируются. Они не могут быть выполнены. Однако, когда вы добавляете docstring к модулю, функции и так далее, то данная строка становится специальным атрибутом, к которому можно получить доступ через __doc__ -
--
class Dog:
    """
    Это класс собаки.
    """

    def bark(self):
        """
        Собака лает из метода!
        """
        return True

animal = Dog()
print(animal.__doc__)
print(animal.bark.__doc__)
----
    Это класс собаки.
    

        Собака лает из метода!
------

PEP8 

Существует множество инструментов, которые можно использовать
для написания отличного кода -

pycodestyle — Проверяет, если ваш код соответствует
стандарту PEP8
https://pypi.org/project/pycodestyle/

Pylint — Инструмент для углубленного статического
тестирования кода, который находит общие проблемы в коде
https://www.pylint.org/

PyFlakes — Еще один инструмент для статического
тестирования кода
https://pypi.org/project/pyflakes/

flake8 — Обертка для PyFlakes, pycodestyle и McCabe
https://pypi.org/project/flake8/

Black — Форматировщик кода, который в основном следует
стандарту PEP8
https://black.readthedocs.io/en/stable/

Pylint, PyFlakes и flake8 кажутся мне наиболее полезными.
Black пригодится, если вы работаете в команде и хотите, чтобы
код каждого сотрудника был написан в одном формате.

Можете добавить Black в свой список инструментов форматирования
кода.

Более продвинутые IDE для Python делают определенные проверки в
режиме реального времени.

Например, PyCharm автоматически проверяет многие проблемы,
которые фиксируют эти инструменты.

WingIDE и VS Code также обеспечивают некоторую проверку кода.
Можете просто попробовать различные IDE и посмотреть, что
подойдет вам лучше всего.

==============================================

1 - 1.4 -

официальная документация python - 
1. Windows: 
https://www.python.org/downloads/windows/
2. MacOS: 
https://www.python.org/downloads/macos/
3. Other Platforms: 
https://www.python.org/download/other/

==============================================

2 - 2.1 - Установка и настройки интерпретатора Python 

https://www.python.org/downloads/

версия - от 3.10 

IDE - VSCode или PyCharm 

далее показывает как установить VSCode и PyCharm

PyCharm - 
у Вас появится следующее окно, в котором можно создать новый проект или открыть существующий

Когда установите IDE и запустите его у вас появится окошко где нужно нажать кнопку New Project

Тут нужно будет выбрать кнопку создания нового окружения. Оно изолирует ваш интерпретатор проекта от главного интерпретатора. Это полезно для тех случаев, когда вы не хотите засорять память компьютера лишними библиотеками – всё будет храниться в папке проекта

После создания проекта нажмите правой кнопкой мыши на серую папку и создайте файл Python и назовите его main.py

В нём вы будете писать свою первую программу. Запустить её можно либо по зеленой кнопке, либо через терминал, если ввести в нём python main.py

--
import hashlib

hash_object = hashlib.sha256(b'hello world')
hex_dig = hash_object.hexdigest()
print(hex_dig)
----

далее показывает код для кеширования с примерами 

==============================================

2 - 2.2 - Знакомство с консолью. Условные конструкции 

эта функция будет отличать повествовательные предложения от
вопросительных:
--
def get_type_of_sentence(sentence):
    last_char = sentence[-1]
    if last_char == '?':
        return 'question'
    return 'normal'

print(get_type_of_sentence('Hodor')) # => normal
print(get_type_of_sentence('Hodor?')) # => question
----

Теперь изменим функцию из предыдущего примера так, чтобы она
возвращала не просто тип предложения, а целую строку Sentence is
normal или Sentence is question :
--
def get_type_of_sentence(sentence):
    last_char = sentence[-1]

    if last_char == '?':
        sentence_type = 'question'
    else:
        sentence_type = 'normal'

    return "Sentence is " + sentence_type

print(get_type_of_sentence('Hodor')) # => 'Sentence is normal'
print(get_type_of_sentence('Hodor?')) # => 'Sentence is question'
----

далее на примерах объясняет концепцию - 
if - elif - elif - ... -else 

Тернарный оператор — единственный оператор в Python, который требует три операнда:
--
def abs(number):
    return number if number >= 0 else -number
----

Питон работает с двумя категориями данных – встроенными типами (они
поддерживаются по умолчанию) и специализированными (для операций с ними
нужно подключение определенного модуля).

К специализированным типам данных относятся, например, datetime (дата и время) и deque (двухсторонняя очередь).

Все встроенные типы данных в Python можно разделить на следующие группы:
- Числовые – целые, вещественные, комплексные числа.
Примечание: для максимально точных расчетов с десятичными числами в
Python используют модуль decimal (тип данных Decimal), а для операций с
рациональными числами (дробями) – модуль fractions (тип
данных Fraction).
- Булевы – логические значения True (истина) и False (ложь).
- Строковые – последовательности символов в кодировке Unicode.
- NoneType – нейтральное пустое значение, аналогичное null в других языках
программирования.
- Последовательности – списки, кортежи, диапазоны.
- Словари – структура данных типа «ключ: значение».
- Множества – контейнеры, содержащие уникальные значения.
Подразделяются на изменяемые set и
неизменяемые frozenset множества.
- Байтовые типы – bytes (байты), bytearray (изменяемая байтовая
строка), memoryview (предоставление доступа к внутренним данным
объекта).

Словарь создается с использованием фигурных скобок {} и содержит пары ключ-
значение, разделенные двоеточием.
Вот пример создания словаря:
--
my_dict = {
    "name": "John",
    "age": 30,
    "city": "New York"
}
----
В этом примере у нас есть словарь с тремя ключами: name , age и city , и их
соответствующими значениями

Для доступа к значению по ключу используется квадратные скобки [] -
--
name = my_dict["name"]
print(name)
----
John
------

Если ключ отсутствует в словаре, Python выбросит исключение KeyError .
Чтобы избежать этого, можно использовать метод get() , который
вернет None или указанное значение по умолчанию, если ключ отсутствует:
--
name = my_dict.get("name")
print(name)
----
John
------

--
country = my_dict.get("country")
print(country)
----
None
------

--
country = my_dict.get("country", "USA")
print(country)
----
USA
------

Чтобы добавить новую пару ключ-значение или изменить существующую,
используйте следующий синтаксис:
--
my_dict["country"] = "USA"
print(my_dict)

# Вывод: {'name': 'John', 'age': 30, 'city': 'New York', 'country':
'USA'}

my_dict["age"] = 31
print(my_dict)

# Вывод: {'name': 'John', 'age': 31, 'city': 'New York', 'country':
'USA'}
----
- В результате добавляется новая пара ключ-значение или обновляется
существующая.

Для удаления элемента из словаря используйте оператор del -
--
del my_dict["city"]
print(my_dict)

# Вывод: {'name': 'John', 'age': 31, 'country': 'USA'}
----
- Если указанный ключ отсутствует, Python выбросит исключение KeyError .
Чтобы безопасно удалить элемент, используйте метод pop() -
--
city = my_dict.pop("city", None)
print(city) 

# Вывод: None
----

Операторы:
математические -
+
-
*
/
//
%
**
сравнения -
<
>
<=
>=
==
!=
логические -
and
or
not 

Побитовые операторы работают с операндами как со строками из 0 и 1.
Они действуют бит за битом, как и говорит название.
Например, 2 в двоичной системе счисления — 10 , а 7 — 111

В таблице ниже: x = 10 ( 00001010 в двоичной системе счисления) и y = 4
( 00000100 в двоичной системе счисления)

Оператор          Действие                Пример
&                 Побитовое И             x & y = 0 ( 00000000 )
|                 Побитовое ИЛИ           x | y = 14 ( 00001110 )
~                 Побитовое НЕ            ~x = -11 ( 11110101 )
^                 Побитовое XOR           x ^ y = 14 ( 00001110 )
>>                Побитовый сдвиг вправо  x >> 2 = 2 ( 00000010 )
<<                Побитовый сдвиг влево   x << 2 = 40 ( 00101000 )

Операторы присваивания используются для назначения переменной некоторого
значения

a = 5 — простой оператор присваивания, который приравнивает значение 5
справа переменной а слева

В Python множество составных операторов, подобных a += 5 — он прибавляет 5
к переменной a и позже присваивает ей получившееся значение. Этот оператор
равносилен записи a = a + 5

is и is not — операторы тождественности в Python.
Они проверяют, находятся ли два значения (или две переменные) по одному
адресу в памяти. То, что две переменные равны еще не значит, что они идентичны

in и not in — операторы принадлежности в Python. Они проверяют, есть ли
значение или переменная в последовательности (строке, списке, кортеже,
множестве или словаре). Иначе говоря, проверяют вхождение элемента в коллекцию. В словаре можно проверить только присутствие ключа, не значения

Функции выполняются интерпретатором только в момент вызова.
При этом у функции — своя область видимости, т.е. находящиеся в ней переменные доступны только в рамках этой функции, и после выполнения функции сразу уничтожаются -
--
def function1 (input_x, input_y=5):
    print (input_x, input_y)
    return input_x + input_y

sum = function1 (2)
----
При этом при передаче дефолтных значений переменные с дефолтными значениями
приема должны располагаться в самом конце списка приема, именно поэтому
function X (x=5, y) — вызовет ошибку

Python — объекту-ориентированный язык программирования. Функция — это тоже объект.
Функции могут читать объявленные глобальные переменные, но не могут их
переписать. Исключение — если внутри функции перед изменением глобальной
переменной её вызвать как global var, что нарушает безопасность кода.
Глобальные переменные принято писать большими буквами. Функции могут быть запущены и в одну строку -
#1й вариант:
--
def sum (a, b):
    c = a + b
    return c
----
#2й вариант:
--
sum = lambda a, b: a + b
----

Списки и Справочники
1. list.append(‘z’) — добавить к концу списка
2. list.insert(X, ‘z’) — добавить в нужное место списка (X=0 — в начало
списка)
3. list.pop[0] — удаление значения с индексом 0
4. list.remove(‘value’) — удаление первого встречающегося слева
значения ‘value’
5. dict.update({x: ‘x’}) — обновить ключ и значение справочника
6. dict.pop(x) — удаление ключа
7. dict.get(x) — взять значение справочника без получения ошибки в случае
не существования ключа
8. dict.keys() — получение всех ключей
9. dict.values() — получение всех значений
10. dict.items() — получение всех ключей и значений - for key, value in
s.items():

Множества (set)
Создан для математических операций над множествами объектов.
В множество нельзя добавить повторяющиеся значения — все значения множества
всегда уникальны. При этом элементы внутри множества хранятся в неупорядоченном виде, и какой порядок будет внутри — программисту неизвестно -
--
set = {x1,x2,…}
type(s)
dir (set)
----
- s1 — s2 | Можно вычитать одно множество из другого
- s1.union (s2) | Объединение множеств
- s1 and s2 | s1 or s2 | И т.д. — можно делать логические операции

Функция – это структура, которую вы определяете. Вам нужно решить, будут ли в ней аргументы, или нет. Вы можете добавить как аргументы ключевых слов, так и готовые по умолчанию. Функция – это блок кода, который начинается с ключевого слова def, названия функции и двоеточия

Ключевое слово def в начале функции сообщает интерпретатору о том, что
следующий за ним код — есть её определение. Всё вместе — это объявление
функции

Аргументы часто путают с параметрами:
- Параметр — это переменная, которой будет присваиваться входящее в
функцию значение
- Аргумент — само это значение, которое передается в функцию при её вызове

Ключевая особенность функций — возможность возвращать значение. Для этого используется слово return

Главная фишка возвращаемых значений в том, что их можно использовать в
дальнейшем коде: присваивать переменным, совершать с ними разные операции и
передавать как аргументы в другие функции

Объявляя функцию, нужно следовать определенным правилам:
- Объявление происходит с помощью ключевого слова def , за ним идёт имя
функции и круглые скобки ().
- Аргументы, передаваемые в функцию, должны находится в круглых скобках.
Там же можно определить их значения по умолчанию, указав их после знака
равно.
- Перед основным содержимым желательно включить строку документации
(docstring), которая обычно описывает назначение и основные принципы
работы функции.
- Тело функции начинается после знака двоеточия. Важно не забыть об
отступах.
- Чтобы выйти из функции в Python, используют оператор return
[значение] . Если оператор опущен, будет возвращено значение None

Синтаксис объявления
Параметры (аргументы) нужно передавать в том порядке, в котором они
определены в круглых скобках.
--
def Имя(аргументы):
    "Документация"
    Тело (инструкции)
    return [значение]
----

Пример кода
Функция складывает два числа, переданные в качестве аргументов. Если один или оба аргумента не были переданы, используются значения по умолчанию
--
def print_sum(a = 2, b = 2):
    sum = a + b
    print(sum)
    return # вернёт None
----

Важность функций:

1. Абстракция

Человек бежит, машина едет, корабль плывёт, а самолёт летит. Всё это — объекты реального мира, которые выполняют однотипные действия. В данном случае, они перемещаются во времени и пространстве. Мы можем абстрагироваться от их природы, и рассматривать эти объекты с точки зрения того, какое расстояние они преодолели, и сколько времени на это ушло.
Мы можем написать функцию, которая вычисляет скорость в каждом конкретном
случае. Нам не важно, кто совершает движение: и для человека и для самолёта
средняя скорость будет рассчитываться одинаково.
--
def calculate_speed(distance, time):
    return distance / time
----
Это простой пример и простая функция, но абстракции могут быть куда более
сложными. И именно тогда раскрывается настоящая сила функций. Вместо того
чтобы решать задачу для каждого конкретного случая, проще написать функцию,
которая находит решение для целого ряда однотипных, в рамках применяемой
абстракции, объектов. В случае сложных и длинных вычислений, это повлечёт за собой значительное сокращение объёмов кода, а значит и времени на его написание

2. Возможность повторного использования

Функции были созданы ради возможности их многократного применения. Код без
функций превратился бы в огромное нечитаемое полотно, на порядки
превышающее по длине аналогичную программу с их использованием.
Например, при работе с массивами чисел, вам нужно часто их сортировать. Вместо того чтобы реализовать простой алгоритм сортировки (или использовать
встроенную функцию), вам пришлось бы каждый раз перепечатывать тело этой или похожей функции:
--
# пузырьковая сортировка
def bubble_sort(nums):
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                swapped = True
----
Всего 10 таких сортировок, и привет, лишние 60 строк кода

3. Модульность

Разбитие больших и сложных процессов на простые составляющие — важная часть, как кодинга, так и реальной жизни. В повседневности мы занимаемся этим неосознанно. Когда убираемся в квартире, мы пылесосим, моем полы и окна, очищаем поверхности от пыли и наводим блеск на всё блестящее. Всё это — составляющие одного большого процесса под названием "уборка", но каждую из них также можно разбить на более простые подпроцессы.
В программировании модульность строится на использовании функций. Для каждой подзадачи — своя функция. Такая компоновка в разы улучшает читабельность кода и уменьшает сложность его дальнейшей поддержки.
Допустим, мы работаем с базой данных. Нам нужна программа, которая считывает значения из базы, обрабатывает их, выводит результат на экран, а затем записывает его обратно в базу.
Без применения модульности получится сплошная последовательность инструкций:
# Database operation program
# Код для чтения данных из базы
# ...
# ...
# Код для выполнения операций над данными
# ...
# ...
# Код для вывода результата
# ...
# ...
# Код для записи данных в базу
# ...
# ...
Но если вынести каждую операцию в отдельную функцию, то текст главной
программы получится маленьким и аккуратным - 
--
def read_from_db():
# Код для чтения данных из базы
# ...
# ...
# ...
def operate_with_data():
# Код для выполнения операций над данными
# ...
# ...
# ...
def print_result():
# Код для вывода результата
# ...
# ...
# ...
def write_to_db():
# Код для записи данных в базу
# ...
# ...
# ...
# код основной программы
# Database operation program
read_from_db()
operate_with_data()
print_result()
write_to_db()
----
- Это и называется модульностью

Вызов функции в коде всегда должен быть ниже её объявления, так как интерпретатор читает код построчно сверху вниз 

В Python переменная, объявленная вне функции или в глобальной области
видимости, называется глобальной переменной. К глобальной переменной можно
получить доступ как внутри, так и вне функции.
Давайте посмотрим на примере, как в Python создается глобальная переменная.
Пример 1. Создаем глобальную переменную -
--
x = "глобальная переменная"

def foo():
    print("x внутри функции:", x)

foo()
print("x вне функции:", x)
----
- в приведенной выше программе мы создали глобальную переменную x и задали
функцию foo() , которая выводит на экран значение x . В коде программы мы
вызвали функцию foo() , которая напечатала значение x внутри функции. Как вы видите, оно совпадает со значением x вне функции.
А что если нужно изменить значение x внутри функции?
--
x = "глобальная переменная"

def foo():
    x = x * 2

print(x)
foo()
----
UnboundLocalError: local variable 'x' referenced before assignment
------
- Python выдает ошибку, потому что он обрабатывает x как локальную переменную, но x при этом не определена внутри функции foo(). Чтобы исправить эту ошибку, нам понадобится ключевое слово global

Переменная, объявленная внутри тела функции или в локальной области
видимости, называется локальной переменной.
Пример 2. Доступ к локальной переменной вне области видимости
--
def foo():
    y = "локальная переменная"

foo()
print(y)
----
NameError: name 'y' is not defined
------
- Python выдает ошибку, потому что мы пытаемся получить доступ к локальной
переменной y в глобальной области видимости. Так делать нельзя: локальная
переменная y «существует» только внутри функции foo()

Давайте рассмотрим пример, который демонстрирует, как в Python создаются
локальные переменные. Мы создаем локальные переменные, когда, например, объявляем переменные внутри функции -
--
def foo():
    y = "локальная переменная"
    print(y)

foo()
----
локальная переменная
------

Как использовать глобальные и локальные переменные в одной программе.
--
x = "глобальная переменная"

def foo():
    global x
    y = "локальная переменная"
    x = x * 2
    print(x)
    print(y)

foo()
----
глобальная переменная глобальная переменная
локальная переменная
------
- в приведенной выше программе мы объявили глобальную переменную x и
локальную переменную y внутри функции foo(). Затем мы использовали
оператор умножения, чтобы изменить глобальную переменную x, и вывели на
экран значения переменных x и y. После вызова функции foo() значение x становится равным "глобальная переменная глобальная переменная" , потому что внутри функции строка "глобальная переменная" умножается на два. Затем
функция foo() выводит на экран новое значение x и значение
переменной y — "локальная переменная"

Глобальная и локальная переменные с одинаковым именем -
--
x = 5

def foo():
    x = 10
    print("локальная переменная x:", x)

foo()
print("глобальная переменная x:", x)
----
локальная переменная x: 10
глобальная переменная x: 5
------
- в приведенной выше программе мы использовали одно и то же имя x как для
глобальной переменной, так и для локальной переменной. Python выводит разные значения переменных x, потому что локальная переменная объявлена внутри функции foo(), а другая — вне ее, то есть в глобальной области видимости. Когда мы печатаем переменную x внутри функции foo(), на экран выводится сообщение "локальная переменная x: 10". Это называется локальной областью видимости переменной. Когда мы печатаем переменную x за пределами foo(), на экран выводится сообщение "глобальная переменная x: 5". Это называется глобальной областью видимости переменной

Возврат значений
С помощью оператора return из функции можно вернуть одно или несколько
значений. Возвращаемым объектом может быть: число, строка, None.
Чтобы вернуть несколько значений, нужно написать их через запятую. Python
позволяет вернуть из функции список или другой контейнер: достаточно указать после ключевого слова return имя контейнера. Вот пример когда возвращается список:
--
def x(n):
    a = [1, 3]
    a = a * n
    return a

print(x(2))
----
[1, 3, 1, 3]
------
- это пример того, как функция в Python 3 возвращает несколько значений. Так как переменные перечислены через запятую, то они образуют список. Эти значения можно присвоить сразу нескольким переменным, как это показано в следующем примере:
--
def example():
    language = "python"
    version = 3
    flag = True
    return language, version, flag

language, version, flag = example()
print(language, version, flag)
----
python 3 True
------

Иногда разработчики оставляют реализацию на потом, и чтобы объявленная
функция не генерировала ошибки из-за отсутствия тела, в качестве заглушки
используется ключевое слово pass:
--
def empty():
    pass
----

Базовые принципы ООП -
- Абстракция — отделение концепции от ее экземпляра;
- Полиморфизм — реализация задач одной и той же идеи разными
способами;
- Наследование — способность объекта или класса базироваться на другом
объекте или классе. Это главный механизм для повторного
использования кода. Наследственное отношение классов четко
определяет их иерархию;
- Инкапсуляция — размещение одного объекта или класса внутри другого
для разграничения доступа к ним.

1 - Используйте следующее вместе с наследованием -
- Делегация — перепоручение задачи от внешнего объекта внутреннему;
- Композиция — включение объектом-контейнером объекта-содержимого и
управление его поведением; последний не может существовать вне первого;
- Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.

2 - Не повторяйся (Don’t repeat yourself — DRY) -
Избегайте повторного написания кода, вынося в абстракции часто
используемые задачи и данные. Каждая часть вашего кода или информации
должна находиться в единственном числе в единственном доступном месте.
Это один из принципов читаемого кода -

3 - Принцип единственной обязанности -
Для каждого класса должно быть определено единственное назначение. Все
ресурсы, необходимые для его осуществления, должны быть инкапсулированы в
этот класс и подчинены только этой задаче.

4 - Принцип открытости/закрытости -
Программные сущности должны быть открыты для расширения, но закрыты для
изменений.

5 - Принцип подстановки Барбары Лисков -
Методы, использующие некий тип, должны иметь возможность использовать
его подтипы, не зная об этом.

6 - Принцип разделения интерфейсов -
Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы
реализующие их классы не были вынуждены определять методы, которые
непосредственно в них не используются.

7 - Принцип инверсии зависимостей -
Система должна конструироваться на основе абстракций «сверху вниз»: не
абстракции должны формироваться на основе деталей, а детали должны
формироваться на основе абстракций.

Объектно-ориентированное программирование – это подход, при котором
вся программа рассматривается как набор взаимодействующих друг с другом
объектов. При этом нам важно знать их характеристики. У каждого объекта в системе есть свойства и поведение, как и у любого реального объекта.

Например, рассмотрим объект «машина». У него есть свойства (цвет, вес,
стоимость) и поведение (машина может ехать, сигналить, потреблять топливо).

Такой подход помогает строить сложные системы более просто и естественно
благодаря тому, что вся предметная область разбивается на объекты и каждый
из них слабо связан с другими объектами.

Слабая связанность возникает вследствие соблюдения трех принципов:
инкапсуляции, наследования и полиморфизма.

1 - Инкапсуляция – сокрытие поведения объекта внутри него. Объекту
«водитель» не нужно знать, что происходит в объекте «машина», чтобы она
ехала. Это ключевой принцип ООП.

2 - Наследование. Есть объекты «человек» и «водитель». У них есть явно что-
то общее. Наследование позволяет выделить это общее в один объект (в
данном случае более общим будет человек), а водителя — определить как
человека, но с дополнительными свойствами и/или поведением.
Например, у водителя есть водительские права, а у человека их может не
быть.

3 - Полиморфизм – это переопределение поведения. Можно снова
рассмотреть «человека» и «водителя», но теперь добавить «пешехода».
Человек умеет как-то передвигаться, но как именно, зависит от того,
водитель он или пешеход. То есть у пешехода и водителя схожее
поведение, но реализованное по-разному: один перемещается ногами,
другой – на машине.

ООП позволяет упростить сложные объекты, составляя их из более маленьких и
простых, поэтому над программой могут работать сотни разработчиков, каждый из которых занят своим блоком.

Большинство современных языков программирования — объектно-ориентированные, и, однажды поняв суть, вы сможете освоить сразу несколько языков.

Файл — это всего лишь набор данных, сохраненный в виде последовательности битов на компьютере.

Информация хранится в куче данных (структура данных) и имеет название «имя файла» (filename).

В Python существует два типа файлов:
1. Текстовые
2. Бинарные

Текстовые файлы -
Это файлы с человекочитаемым содержимым. В них хранятся
последовательности символов, которые понимает человек. Блокнот и
другие стандартные редакторы умеют читать и редактировать этот
тип файлов. Текст может храниться в двух форматах: ( .txt ) — простой текст и ( .rtf ) — «формат обогащенного текста».

Бинарные файлы -
В бинарных файлах данные отображаются в закодированной форме (с
использованием только нулей (0) и единиц (1) вместо простых
символов). В большинстве случаев это просто последовательности
битов. Они хранятся в формате .bin 

Любую операцию с файлом можно разбить на три крупных этапа:
1. Открытие файла
2. Выполнение операции (запись, чтение)
3. Закрытие файла

Открытие файла
Метод open()
В Python есть встроенная функция open() . С ее помощью можно
открыть любой файл на компьютере. Технически Python создает на
его основе объект. Синтаксис следующий:
--
f = open(file_name, access_mode)
----
Где -
- file_name = имя открываемого файла
- access_mode = режим открытия файла. Он может быть: для
чтения, записи и т. д. По умолчанию используется режим
чтения ( r ), если другое не указано. Далее полный список
режимов открытия файла -
--
r - Только для чтения.

w - Только для записи. Создаст новый файл, если не найдет с указанным именем.

rb - Только для чтения (бинарный).

wb - Только для записи (бинарный). Создаст новый файл, если не найдет с указанным именем.

r+ - Для чтения и записи.

rb+ - Для чтения и записи (бинарный).

w+ - Для чтения и записи. Создаст новый файл для записи, если не найдет с указанным именем.

wb+ - Для чтения и записи (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.

a - Откроет для добавления нового содержимого. Создаст новый файл для записи, если не найдет с указанным именем.

a+ - Откроет для добавления нового содержимого. Создаст новый файл для чтения записи, если не найдет с указанным именем.

ab - Откроет для добавления нового содержимого (бинарный). Создаст новый файл для записи, если не найдет с указанным именем.

ab+ - Откроет для добавления нового содержимого (бинарный).
Создаст новый файл для чтения записи, если не найдет с указанным
именем.
----

--
f = open('example.txt','r') 
# открыть файл из рабочей директории в режиме чтения

fp = open('C:/xyz.txt','r') 
# открыть файл из любого каталога
----
В этом примере f — переменная-указатель на файл example.txt .
Следующий код используется для вывода содержимого файла и
информации о нем.
--
>>> print(*f) # выводим содержимое файла
This is a text file.
>>> print(f) # выводим объект
<_io.TextIOWrapper name='example.txt' mode='r' encoding='cp1252'>
----
Стоит обратить внимание, что в Windows стандартной кодировкой
является cp1252 , а в Linux — utf-08 .

Закрытие файла - Метод close() -
После открытия файла в Python его нужно закрыть. Таким образом
освобождаются ресурсы и убирается мусор. Python автоматически
закрывает файл, когда объект присваивается другому файлу.

Существуют следующие способы:

Способ №1
Проще всего после открытия файла закрыть его, используя
метод close().
--
f = open('example.txt','r')
# работа с файлом
f.close()
----

После закрытия этот файл нельзя будет использовать до тех пор,
пока заново его не открыть.

Способ №2
Также можно написать try/finally , которое гарантирует, что если
после открытия файла операции с ним приводят к исключениям, он
закроется автоматически. Без него программа завершается некорректно -
--
f = open('example.txt','r')
try:
# работа с файлом
finally: f.close()
----
Файл нужно открыть до инструкции try , потому что если
инструкция open сама по себе вызовет ошибку, то файл не будет
открываться для последующего закрытия. Этот метод гарантирует, что если операции над файлом вызовут исключения, то он закроется до того как программа остановится.

Способ №3
Инструкция with - Еще один подход — использовать инструкцию with , которая упрощает обработку исключений с помощью инкапсуляции начальных операций, а также задач по закрытию и очистке. В таком случае инструкция close не нужна, потому
что with автоматически закроет файл.
Вот как это реализовать в коде -
--
with open('example.txt') as f:
# работа с файлом
----

Чтение и запись файлов в Python

В Python файлы можно читать или записывать информацию в них с
помощью соответствующих режимов.

Функция read() -
Функция read() используется для чтения содержимого файла после
открытия его в режиме чтения ( r ). Синтаксис -
--
file.read(size)
----
Где -
- file = объект файла
- size = количество символов, которые нужно прочитать. Если
не указать, то файл прочитается целиком.
Пример:
--
>>> f = open('example.txt','r')
>>> f.read(7) # чтение 7 символов из example.txt
'This is '
----
Интерпретатор прочитал 7 символов файла и если снова
использовать функцию read() , то чтение начнется с 8-го символа.
--
>>> f.read(7) # чтение следующих 7 символов
' a text'
----

Функция readline() -
Функция readline() используется для построчного чтения  содержимого файла. Она используется для крупных файлов. С ее
помощью можно получать доступ к любой строке в любой момент.
Пример:
Создадим файл test.txt с нескольким строками:
This is line1.
This is line2.
This is line3.
Посмотрим, как функция readline() работает в test.txt -
--
>>> x = open('test.txt','r')
>>> x.readline() # прочитать первую строку
This is line1.
>>> x.readline(2) # прочитать вторую строку
This is line2.
>>> x.readlines() # прочитать все строки
['This is line1.','This is line2.','This is line3.']
----
- Обратите внимание, как в последнем случае строки отделены друг
от друга.

Функция write() -
Функция write() используется для записи в файлы Python, открытые
в режиме записи. Если пытаться открыть файл, которого не существует, в этом режиме, тогда будет создан новый. Синтаксис -
--
file.write(string)
----

Пример:
Предположим, файла xyz.txt не существует.
Он будет создан при попытке открыть его в режиме чтения.
--
>>> f = open('xyz.txt','w') 
# открытие в режиме записи

>>> f.write('Hello \n World') 
# запись Hello World в файл
Hello
World
>>> f.close() # закрытие файла
----

7
































