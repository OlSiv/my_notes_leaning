
https://s1.sharewood.co/threads/stepik-pogruzhenie-v-data-science-i-mashinnoe-obuchenie-2024.453551/

https://cloud.mail.ru/public/y6Cb/g7KcxQq2o

telegram - my_coding - 19.04.2025 

==============================================

1 - 1.1 -

Команды для установки библиотек в Python:
1. pip install numpy
2. pip install pandas
3. pip install colorama
4. pip install requests
5. pip install mysql
6. pip install matplotlib
7. pip install jupyterlab
8. pip install notebook

Библиотеки в PyPI:
1. https://pypi.org/project/Pillow/
2. https://pypi.org/project/matplotlib/
3. https://pypi.org/project/notebook/
4. https://pypi.org/project/pandas/
5. https://pypi.org/project/matplotlib/
6. https://pypi.org/project/jupyterlab/

==============================================

1 - 1.2 -

Инструменты для анализа данных в Data Science включают:

1. Python: Язык программирования, широко используемый в Data Science
благодаря его гибкости, богатому экосистеме библиотек и фреймворков,
таких как NumPy, Pandas, Scikit-learn, TensorFlow, Keras и других.

2. R: Язык программирования и среда для статистического анализа данных. Он
предлагает широкий спектр библиотек для статистического моделирования,
визуализации данных и машинного обучения, таких как ggplot2, dplyr, caret и
других.

3. SQL: Язык структурированных запросов, используемый для работы с 
реляционными базами данных. SQL позволяет извлекать, преобразовывать и
анализировать данные из баз данных.

4. Tableau: Инструмент визуализации данных, который позволяет создавать
интерактивные дашборды и отчеты для визуализации данных и их анализа.

5. Apache Spark: Распределенная платформа для обработки больших данных,
которая предлагает библиотеки для машинного обучения (MLlib), графового
анализа (GraphX) и потоковой обработки данных (Spark Streaming).

6. Jupyter Notebook: Интерактивная среда разработки, которая позволяет
комбинировать код, текст и визуализации в одном документе. Она широко
используется в Data Science для разработки и документирования
аналитических процессов

==============================================

1 - 1.3 -

# это комментарий
или
CTRL + /
или 
'''
........
'''
или 
"""
........
"""
- и в теле функции это докстринг 

В Python docstring игнорируются. Они не могут быть выполнены. Однако, когда вы добавляете docstring к модулю, функции и так далее, то данная строка становится специальным атрибутом, к которому можно получить доступ через __doc__ -
--
class Dog:
    """
    Это класс собаки.
    """

    def bark(self):
        """
        Собака лает из метода!
        """
        return True

animal = Dog()
print(animal.__doc__)
print(animal.bark.__doc__)
----
    Это класс собаки.
    

        Собака лает из метода!
------

PEP8 

Существует множество инструментов, которые можно использовать
для написания отличного кода -

pycodestyle — Проверяет, если ваш код соответствует
стандарту PEP8
https://pypi.org/project/pycodestyle/

Pylint — Инструмент для углубленного статического
тестирования кода, который находит общие проблемы в коде
https://www.pylint.org/

PyFlakes — Еще один инструмент для статического
тестирования кода
https://pypi.org/project/pyflakes/

flake8 — Обертка для PyFlakes, pycodestyle и McCabe
https://pypi.org/project/flake8/

Black — Форматировщик кода, который в основном следует
стандарту PEP8
https://black.readthedocs.io/en/stable/

Pylint, PyFlakes и flake8 кажутся мне наиболее полезными.
Black пригодится, если вы работаете в команде и хотите, чтобы
код каждого сотрудника был написан в одном формате.

Можете добавить Black в свой список инструментов форматирования
кода.

Более продвинутые IDE для Python делают определенные проверки в
режиме реального времени.

Например, PyCharm автоматически проверяет многие проблемы,
которые фиксируют эти инструменты.

WingIDE и VS Code также обеспечивают некоторую проверку кода.
Можете просто попробовать различные IDE и посмотреть, что
подойдет вам лучше всего.

==============================================

1 - 1.4 -

официальная документация python - 
1. Windows: 
https://www.python.org/downloads/windows/
2. MacOS: 
https://www.python.org/downloads/macos/
3. Other Platforms: 
https://www.python.org/download/other/

==============================================

2 - 2.1 - Установка и настройки интерпретатора Python 

https://www.python.org/downloads/

версия - от 3.10 

IDE - VSCode или PyCharm 

далее показывает как установить VSCode и PyCharm

PyCharm - 
у Вас появится следующее окно, в котором можно создать новый проект или открыть существующий

Когда установите IDE и запустите его у вас появится окошко где нужно нажать кнопку New Project

Тут нужно будет выбрать кнопку создания нового окружения. Оно изолирует ваш интерпретатор проекта от главного интерпретатора. Это полезно для тех случаев, когда вы не хотите засорять память компьютера лишними библиотеками – всё будет храниться в папке проекта

После создания проекта нажмите правой кнопкой мыши на серую папку и создайте файл Python и назовите его main.py

В нём вы будете писать свою первую программу. Запустить её можно либо по зеленой кнопке, либо через терминал, если ввести в нём python main.py

--
import hashlib

hash_object = hashlib.sha256(b'hello world')
hex_dig = hash_object.hexdigest()
print(hex_dig)
----

далее показывает код для кеширования с примерами 

==============================================

2 - 2.2 - Знакомство с консолью. Условные конструкции 

эта функция будет отличать повествовательные предложения от
вопросительных:
--
def get_type_of_sentence(sentence):
    last_char = sentence[-1]
    if last_char == '?':
        return 'question'
    return 'normal'

print(get_type_of_sentence('Hodor')) # => normal
print(get_type_of_sentence('Hodor?')) # => question
----

Теперь изменим функцию из предыдущего примера так, чтобы она
возвращала не просто тип предложения, а целую строку Sentence is
normal или Sentence is question :
--
def get_type_of_sentence(sentence):
    last_char = sentence[-1]

    if last_char == '?':
        sentence_type = 'question'
    else:
        sentence_type = 'normal'

    return "Sentence is " + sentence_type

print(get_type_of_sentence('Hodor')) # => 'Sentence is normal'
print(get_type_of_sentence('Hodor?')) # => 'Sentence is question'
----

далее на примерах объясняет концепцию - 
if - elif - elif - ... -else 

Тернарный оператор — единственный оператор в Python, который требует три операнда:
--
def abs(number):
    return number if number >= 0 else -number
----

Питон работает с двумя категориями данных – встроенными типами (они
поддерживаются по умолчанию) и специализированными (для операций с ними
нужно подключение определенного модуля).

К специализированным типам данных относятся, например, datetime (дата и время) и deque (двухсторонняя очередь).

Все встроенные типы данных в Python можно разделить на следующие группы:
- Числовые – целые, вещественные, комплексные числа.
Примечание: для максимально точных расчетов с десятичными числами в
Python используют модуль decimal (тип данных Decimal), а для операций с
рациональными числами (дробями) – модуль fractions (тип
данных Fraction).
- Булевы – логические значения True (истина) и False (ложь).
- Строковые – последовательности символов в кодировке Unicode.
- NoneType – нейтральное пустое значение, аналогичное null в других языках
программирования.
- Последовательности – списки, кортежи, диапазоны.
- Словари – структура данных типа «ключ: значение».
- Множества – контейнеры, содержащие уникальные значения.
Подразделяются на изменяемые set и
неизменяемые frozenset множества.
- Байтовые типы – bytes (байты), bytearray (изменяемая байтовая
строка), memoryview (предоставление доступа к внутренним данным
объекта).

Словарь создается с использованием фигурных скобок {} и содержит пары ключ-
значение, разделенные двоеточием.
Вот пример создания словаря:
--
my_dict = {
    "name": "John",
    "age": 30,
    "city": "New York"
}
----
В этом примере у нас есть словарь с тремя ключами: name , age и city , и их
соответствующими значениями

Для доступа к значению по ключу используется квадратные скобки [] -
--
name = my_dict["name"]
print(name)
----
John
------

Если ключ отсутствует в словаре, Python выбросит исключение KeyError .
Чтобы избежать этого, можно использовать метод get() , который
вернет None или указанное значение по умолчанию, если ключ отсутствует:
--
name = my_dict.get("name")
print(name)
----
John
------

--
country = my_dict.get("country")
print(country)
----
None
------

--
country = my_dict.get("country", "USA")
print(country)
----
USA
------

Чтобы добавить новую пару ключ-значение или изменить существующую,
используйте следующий синтаксис:
--
my_dict["country"] = "USA"
print(my_dict)

# Вывод: {'name': 'John', 'age': 30, 'city': 'New York', 'country':
'USA'}

my_dict["age"] = 31
print(my_dict)

# Вывод: {'name': 'John', 'age': 31, 'city': 'New York', 'country':
'USA'}
----
- В результате добавляется новая пара ключ-значение или обновляется
существующая.

Для удаления элемента из словаря используйте оператор del -
--
del my_dict["city"]
print(my_dict)

# Вывод: {'name': 'John', 'age': 31, 'country': 'USA'}
----
- Если указанный ключ отсутствует, Python выбросит исключение KeyError .
Чтобы безопасно удалить элемент, используйте метод pop() -
--
city = my_dict.pop("city", None)
print(city) 

# Вывод: None
----

Операторы:
математические -
+
-
*
/
//
%
**
сравнения -
<
>
<=
>=
==
!=
логические -
and
or
not 

Побитовые операторы работают с операндами как со строками из 0 и 1.
Они действуют бит за битом, как и говорит название.
Например, 2 в двоичной системе счисления — 10 , а 7 — 111

В таблице ниже: x = 10 ( 00001010 в двоичной системе счисления) и y = 4
( 00000100 в двоичной системе счисления)

Оператор          Действие                Пример
&                 Побитовое И             x & y = 0 ( 00000000 )
|                 Побитовое ИЛИ           x | y = 14 ( 00001110 )
~                 Побитовое НЕ            ~x = -11 ( 11110101 )
^                 Побитовое XOR           x ^ y = 14 ( 00001110 )
>>                Побитовый сдвиг вправо  x >> 2 = 2 ( 00000010 )
<<                Побитовый сдвиг влево   x << 2 = 40 ( 00101000 )

Операторы присваивания используются для назначения переменной некоторого
значения

a = 5 — простой оператор присваивания, который приравнивает значение 5
справа переменной а слева

В Python множество составных операторов, подобных a += 5 — он прибавляет 5
к переменной a и позже присваивает ей получившееся значение. Этот оператор
равносилен записи a = a + 5

is и is not — операторы тождественности в Python.
Они проверяют, находятся ли два значения (или две переменные) по одному
адресу в памяти. То, что две переменные равны еще не значит, что они идентичны

in и not in — операторы принадлежности в Python. Они проверяют, есть ли
значение или переменная в последовательности (строке, списке, кортеже,
множестве или словаре). Иначе говоря, проверяют вхождение элемента в коллекцию. В словаре можно проверить только присутствие ключа, не значения

Функции выполняются интерпретатором только в момент вызова.
При этом у функции — своя область видимости, т.е. находящиеся в ней переменные доступны только в рамках этой функции, и после выполнения функции сразу уничтожаются -
--
def function1 (input_x, input_y=5):
    print (input_x, input_y)
    return input_x + input_y

sum = function1 (2)
----
При этом при передаче дефолтных значений переменные с дефолтными значениями
приема должны располагаться в самом конце списка приема, именно поэтому
function X (x=5, y) — вызовет ошибку

Python — объекту-ориентированный язык программирования. Функция — это тоже объект.
Функции могут читать объявленные глобальные переменные, но не могут их
переписать. Исключение — если внутри функции перед изменением глобальной
переменной её вызвать как global var, что нарушает безопасность кода.
Глобальные переменные принято писать большими буквами. Функции могут быть запущены и в одну строку -
#1й вариант:
--
def sum (a, b):
    c = a + b
    return c
----
#2й вариант:
--
sum = lambda a, b: a + b
----

Списки и Справочники
1. list.append(‘z’) — добавить к концу списка
2. list.insert(X, ‘z’) — добавить в нужное место списка (X=0 — в начало
списка)
3. list.pop[0] — удаление значения с индексом 0
4. list.remove(‘value’) — удаление первого встречающегося слева
значения ‘value’
5. dict.update({x: ‘x’}) — обновить ключ и значение справочника
6. dict.pop(x) — удаление ключа
7. dict.get(x) — взять значение справочника без получения ошибки в случае
не существования ключа
8. dict.keys() — получение всех ключей
9. dict.values() — получение всех значений
10. dict.items() — получение всех ключей и значений - for key, value in
s.items():

Множества (set)
Создан для математических операций над множествами объектов.
В множество нельзя добавить повторяющиеся значения — все значения множества
всегда уникальны. При этом элементы внутри множества хранятся в неупорядоченном виде, и какой порядок будет внутри — программисту неизвестно -
--
set = {x1,x2,…}
type(s)
dir (set)
----
- s1 — s2 | Можно вычитать одно множество из другого
- s1.union (s2) | Объединение множеств
- s1 and s2 | s1 or s2 | И т.д. — можно делать логические операции

Функция – это структура, которую вы определяете. Вам нужно решить, будут ли в ней аргументы, или нет. Вы можете добавить как аргументы ключевых слов, так и готовые по умолчанию. Функция – это блок кода, который начинается с ключевого слова def, названия функции и двоеточия

Ключевое слово def в начале функции сообщает интерпретатору о том, что
следующий за ним код — есть её определение. Всё вместе — это объявление
функции

Аргументы часто путают с параметрами:
- Параметр — это переменная, которой будет присваиваться входящее в
функцию значение
- Аргумент — само это значение, которое передается в функцию при её вызове

Ключевая особенность функций — возможность возвращать значение. Для этого используется слово return

Главная фишка возвращаемых значений в том, что их можно использовать в
дальнейшем коде: присваивать переменным, совершать с ними разные операции и
передавать как аргументы в другие функции

Объявляя функцию, нужно следовать определенным правилам:
- Объявление происходит с помощью ключевого слова def , за ним идёт имя
функции и круглые скобки ().
- Аргументы, передаваемые в функцию, должны находится в круглых скобках.
Там же можно определить их значения по умолчанию, указав их после знака
равно.
- Перед основным содержимым желательно включить строку документации
(docstring), которая обычно описывает назначение и основные принципы
работы функции.
- Тело функции начинается после знака двоеточия. Важно не забыть об
отступах.
- Чтобы выйти из функции в Python, используют оператор return
[значение] . Если оператор опущен, будет возвращено значение None

Синтаксис объявления
Параметры (аргументы) нужно передавать в том порядке, в котором они
определены в круглых скобках.
--
def Имя(аргументы):
    "Документация"
    Тело (инструкции)
    return [значение]
----

Пример кода
Функция складывает два числа, переданные в качестве аргументов. Если один или оба аргумента не были переданы, используются значения по умолчанию
--
def print_sum(a = 2, b = 2):
    sum = a + b
    print(sum)
    return # вернёт None
----

Важность функций:

1. Абстракция

Человек бежит, машина едет, корабль плывёт, а самолёт летит. Всё это — объекты реального мира, которые выполняют однотипные действия. В данном случае, они перемещаются во времени и пространстве. Мы можем абстрагироваться от их природы, и рассматривать эти объекты с точки зрения того, какое расстояние они преодолели, и сколько времени на это ушло.
Мы можем написать функцию, которая вычисляет скорость в каждом конкретном
случае. Нам не важно, кто совершает движение: и для человека и для самолёта
средняя скорость будет рассчитываться одинаково.
--
def calculate_speed(distance, time):
    return distance / time
----
Это простой пример и простая функция, но абстракции могут быть куда более
сложными. И именно тогда раскрывается настоящая сила функций. Вместо того
чтобы решать задачу для каждого конкретного случая, проще написать функцию,
которая находит решение для целого ряда однотипных, в рамках применяемой
абстракции, объектов. В случае сложных и длинных вычислений, это повлечёт за собой значительное сокращение объёмов кода, а значит и времени на его написание

2. Возможность повторного использования

Функции были созданы ради возможности их многократного применения. Код без
функций превратился бы в огромное нечитаемое полотно, на порядки
превышающее по длине аналогичную программу с их использованием.
Например, при работе с массивами чисел, вам нужно часто их сортировать. Вместо того чтобы реализовать простой алгоритм сортировки (или использовать
встроенную функцию), вам пришлось бы каждый раз перепечатывать тело этой или похожей функции:
--
# пузырьковая сортировка
def bubble_sort(nums):
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(nums) - 1):
            if nums[i] > nums[i + 1]:
                nums[i], nums[i + 1] = nums[i + 1], nums[i]
                swapped = True
----
Всего 10 таких сортировок, и привет, лишние 60 строк кода

3. Модульность

Разбитие больших и сложных процессов на простые составляющие — важная часть, как кодинга, так и реальной жизни. В повседневности мы занимаемся этим неосознанно. Когда убираемся в квартире, мы пылесосим, моем полы и окна, очищаем поверхности от пыли и наводим блеск на всё блестящее. Всё это — составляющие одного большого процесса под названием "уборка", но каждую из них также можно разбить на более простые подпроцессы.
В программировании модульность строится на использовании функций. Для каждой подзадачи — своя функция. Такая компоновка в разы улучшает читабельность кода и уменьшает сложность его дальнейшей поддержки.
Допустим, мы работаем с базой данных. Нам нужна программа, которая считывает значения из базы, обрабатывает их, выводит результат на экран, а затем записывает его обратно в базу.
Без применения модульности получится сплошная последовательность инструкций:
# Database operation program
# Код для чтения данных из базы
# ...
# ...
# Код для выполнения операций над данными
# ...
# ...
# Код для вывода результата
# ...
# ...
# Код для записи данных в базу
# ...
# ...
Но если вынести каждую операцию в отдельную функцию, то текст главной
программы получится маленьким и аккуратным - 
--
def read_from_db():
# Код для чтения данных из базы
# ...
# ...
# ...
def operate_with_data():
# Код для выполнения операций над данными
# ...
# ...
# ...
def print_result():
# Код для вывода результата
# ...
# ...
# ...
def write_to_db():
# Код для записи данных в базу
# ...
# ...
# ...
# код основной программы
# Database operation program
read_from_db()
operate_with_data()
print_result()
write_to_db()
----
- Это и называется модульностью

Вызов функции в коде всегда должен быть ниже её объявления, так как интерпретатор читает код построчно сверху вниз 



































































