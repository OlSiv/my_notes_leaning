
https://bw10.skladchik.org/threads/avtomatizacija-testirovanija-na-python-tarif-bez-domashnix-zadanij-evgenij-okulik.457190/

https://okulik.by/video/

https://www.youtube.com/@SeniorTester/videos

курс записан автором в ноябре 2023



************************************

материалы - на жд4тб (CODING - QA)
+
https://cloud.mail.ru/public/JitG/YWEqCAbMT
+
telegram - избранное - 25.01.2026 (19:38)



************************************

видео с сайта-продажника - 

https://youtu.be/Z6atGnvmAn8

https://youtu.be/LhPeGnfszlw

основы python для тестировщика - 24 видео - 
https://www.youtube.com/playlist?list=PLRVGb5te8vVGuLyHYIsn6xGoxUXoYrVjk



************************************

1 - Стандарты PEP 20 - Дзен Python 

PEP 8 -
https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html

- 4 пробела на отступ 
- длинна строки - максимум 79 символов (в PyCharm - вертикальная полоса справа)
- между функциями и классами - 2 строки
- каждый импорт на отдельной строке 
- блок комментария - до разъясняемого кода
- разделение слов - через _
- и т.д.


ДЗ - прочитать руководство - 
https://pythonworld.ru/osnovy/pep-8-rukovodstvo-po-napisaniyu-koda-na-python.html



************************************

1 - Установка Python на Windows, Ubuntu, MacOs. Для чего нужен Pycharm и другие IDE

автор сделал 2 виртуальные машины - на Windows и на Ubuntu 

проверить есть ли python в Windows (CTR+R - cmd) - 
--
python --version 
----

проверить есть ли python в Ubuntu (в верхнем правом углу "Activites" - ввести "Terminal") - 
--
python --version 
----
или 
--
python3 --version 
----

скачать установщик последней или предпоследней стабильной версии с python.org 

поставить галочки в двух квадратах при установке 

затем лучше перезагрузить терминал 

проверить версию pip - 
--
pip --version 
----

если pip нет, то скачать и установить в Windows pip для установки модулей, в google ввести запрос - "как скачать pip через cmd"

скачать и установить pip в Ubuntu - 
--
sudo apt install python3-pip
----

если древняя MacOS, то установить python с сайта python.org (в видео - с 14:00)

среда разработки для программирования (IDE) - это как текстовый редактор 

первая программа - 
--
hello.py
--
print("Hello!")
----

установить PyCharm IDE 

создать проект 

настроить виртуальное окружение внутри PyCharm, но лучше не стандартное, а своё 

если используешь VSCode то установить расширение - Python от Microsoft 



************************************

2 - Git

установка Git - 

- Windows -
https://git-scm.com/download/win 

- Ubuntu -
--
apt-get install git
----

- MacOS -
https://git-scm.com/download/mac

проверить установлен ли git - 
--
git --version
----

настройка - 
--
git config --global user.name "Ivan Ivanov"
git config --global user.email "ivan_ivanov@mail.com"
----

проверить как установились значения - 
--
git config --list --show-origin
----

git не сможет отслеживать пустую папку, где нет файлов 

чтобы работать с репозиторием, нужно перейти в ту папку, где находится этот репозиторий 

создание репозитория - 
--
git init 
git add <file_name>
git add . (добавить все файлы)
git commit -m "message"
git commit -am "message" (объеденит add и commit)
----

git status 

git log 

git log --oneline 

выйти из редактора в Windows - 
- ESC потом :wq (с сохранением)
- ESC потом :q (без сохранения)

вернуться к старому коммиту - 
--
git checkout <commit Id>
----

вернуться в main (master) из старого коммита -
--
git switch -
----

отменить изменения в файле до индексации (до git add .) - 
--
git checkout <file name>
----

отмена индексации (если уже сделали git add .) -
--
git reset HEAD <file_name>
----

отмена последнего коммита -
--
git revert HEAD 
----

изменение наименования последнего коммита - 
--
git commit --amend -am "message"
----

создание новой ветки и переход на неё -
--
git checkout -b <new branch name>
----
- перед созданием новой ветки обязательно нужно посмотреть, на какой ветке ты сейчас находишся (git status или git branch)

переключение между ветками - 
--
git checkout <branch name>
----

книга о Git - 
https://git-scm.com/book/ru/v2

шпаргалка по командам Git - 
https://training.github.com/downloads/ru/github-git-cheat-sheet



************************************

2 - Github 

теперь будем создавать репозиторий на github и забирать его на свой компьютер 

github.com 

копировать на комп и потом отправлять на GitHub - по SSH 

клонирование репозитория -
--
git clone <url>
----

создать файл без расширения - config в папке С\Users\user\.ssh и добавить туда как в видео (17:00)

github.com/eugene-okulik/QAP-13onl/wiki
==
- Переходим в ветку main
- Получаем последнюю версию ветки (git pull)
- Создаем бранч
- Для первого задания нужно будет создать свою папку внутри папки homework
- Создаем папку для задания в своей директории (например Homework_3)
- Добавляем в созданную папку файл(ы) с результатом выполненного задания
- Коммитим с толковым описанием
- Пушим свой бранч в репозиторий
- Создаем Pull request на мерж своего бранча в main

Каждый коммит должен отвечать на вопрос "что было сделано?" - "added <что было добавлено>" или "updated <что было изменено>" или "fixed <что было исправлено/починено>" 

пример:
"added text variables", "added funtions for reading text from file" или "updated input text"
Если на английском сложно, то в коммитах можно на русском, например “исправлены пробелы в операциях присвоения”, “изменены названия функций”, или даже подлиннее: “изменен порядок выполнения функций и добавлены проверки корректности данных”

ветки создавать всегда из последней версии ветки main, перед этим перейти на ветку main (git checkout main), сделать git pull, потом создать новую ветку и перейти на неё (git checkout -b name_branch)

на github в строке сверху найти пункт Pull requests, при смерживании веток github сам предложит сделать Pull request

внесение изменений и отправка на github - 
--
git pull 
git checkout -b new_branch_name 
потом сделать изменение в коде 
git add .
git commit -m "commit_message"
git push origin main
----

копировать на комп и потом отправлять на GitHub - по SSH 

ДЗ - 
1 - создать свой репозиторий на git hub 
2 - склонировать себе этот репозиторий 
3 - создать бранч (ветку) в репозитории 
4 - создать внутри этого репозитория файл 
5 - сделать коммит с осмысленным комментарием 
6 - внести изменения в файл 
7 - сделать еще один коммит 
8 - отправить все сделанные изменения на github 
9 - создать пул-реквест 
10 - подтвердить пул-реквест 
11 - сделать мерж изменений 



************************************

2 - Для чего нужен Git_ Может, без него проще

открыть папку из графического интерфейса в терминале - 
- Linux - ПКМ > Open in Terminal
- Windows - ПКМ + SHIFT > Открыть окно PowerShell здесь 

переименовать ветку master в ветку main - 
--
git branch -m master main 
----

git init 

git status 

git log 

git add .

git commit -m "message"

git checkout main 

находясь на ветке main влить в неё ветку my_branch
--
git merge my_branch
----

git и github - это разные вещи 



************************************

2 - Настройка SSH подключения к Github_ Сравнение с HTTPS подключением_ Windows, Linux, Mac

git clone https://github.com/...................git

настроим клонирование репозитория с hithub с помощью SSH 

кнопка "<> Code" - скопируем ссылку SSH - 
git@github.com:OlSiv/code_my_projects.git

git clone git@github.com:OlSiv/code_my_projects.git

инструкция как настроить SSH - 
- аватар пользователя в верхнем правом углу 
- Setting 
- в столбце слева "SSH and GPG keys"
- SSH keys (Check out our guide to connecting to GitHub using SSH keys or troubleshoot common SSH problems) - https://docs.github.com/authentication/connecting-to-github-with-ssh

Как сгенерировать новый ключ - 
https://docs.github.com/ru/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent
- Откройте Git Bash
- Вставьте текст ниже, заменив адрес электронной почты, использованный в примере, на свой адрес электронной почты GitHub -
--
ssh-keygen -t ed25519 -C "your_email@example.com"
----
- ..........

в видео с 17:00 показывает как создать ключ SSH и добавить в github 

приватный и публичный ключи лежат - 
- Windows - C\Users\user\.ssh
- Linux - /home/my_user/.ssh

на Linux перейти в папку пользователя - 
--
cd ~/.ssh
----




************************************

3 - lesson_python_basics_1

работать будем в VSCode - там есть бесплатный jupyter notebook

каждый раз перед работой делаем - 
git checkout main 
git pull 
git checkout - b my_branch
тут делаем работу 
...
git add .
git commit -m "message"
git push origin my_branch
..........................................ИЛИ ЛУЧШЕ ТАК - 
git push --set -upstream origin my_branch
+
Создай Pull Request:
После пуша в терминале обычно появляется прямая ссылка на создание PR. Если нет — заходи на страницу репозитория в GitHub, там сверху выскочит плашка "Compare & pull request". Жми её.
+
Оформи PR:
Выбери base: main и compare: my_branch, опиши, что сделал, и назначай ревьюеров.
+
Совет от профи: перед git push полезно сделать git status, чтобы убедиться, что ты не тянешь в проект лишний мусор (вроде логов или временных конфигов).



Идентификаторы (названия) -

Идентификаторы в Python это имена используемые для обозначения переменной, функции, класса, модуля или другого объекта.

Правила для написания идентификаторов:
1 - Идентификаторы могут быть комбинацией букв в нижнем регистре (a - z) или верхнего регистра (A - Z) или цифр (0 - 9) или подчеркивание _. Например: myClass, var_1 и print_this_to_screen.
2 - Идентификатор не может начинаться с цифры. 1variable неправильно, но variable1 правильно.
3 - Ключевые слова не могут использоваться как идентификаторы.
4 - Нельзя использовать специальные символы !, @, #, $, %. 5 - Идентификаторы могут быть любой длины.



Зарезервированные слова -

Мы не можем использовать ключевые слова как имена переменных, имена функций или какой-нибудь любой другой идентификатор.

Они используются, для определения синтаксиса и структуры в языке Python. Ключевые слова регистрозависимые.

Все слова за исключением True, False и None в маленьком регистре.

Python – регистрозависимый язык. Это означает, что "Variable" и "variable" не одно и тоже.  

Называйте идентификаторы осмысленно.  

Несколько слов могут быть разделены подчеркиванием this_is_a_long_variable.  

"snake_case" (undercore notation) - стандарт для именования всего кроме классов



Основные типы данных -

1. int - integer - целые числа (4)
2. float - числа с плавающей точкой (4.2)
3. str - string - строки ('My cool text')
4. bool - boolean - логические значения: True или False 

Это не все типы данных, а только основные.

--
print(42)
print(42.5)
print('text')
print(True)
print(False)
----
42
42.5
text
True
False
------



Переменная -

Именованный участок памяти, обладающий некоторым типом.  

Таким образом, в Python у переменной всегда есть:  
- Имя (название)  
- Значение  

Переменная - это элемент, который хранит в себе какие либо данные.  
Если мы создали переменную, то она никогда не бывает абсолютно пустой. В ней может храниться, например, пустая строка. Тогда переменная хранит строку, которая пустая. И хранит ее до тех пор, пока программа не завершит работу.

--
empty_str = ''
----



Объявление переменной -

Переменные в Python не типизированные. Это значит, что при создании переменной не нужно указывать какой тип данных в ней будет храниться. Более того, переменную не нужно объявлять заранее, до того как присвоить ей какие-либо данные. Объявление переменной происходит простым присвоением ей значения:
--
a = 45
print(2 + a)
----
47
------

После присвоения, переменная сама знает какой тип данных в ней хранится. У переменной всегда есть тип (конечно, если значение не None). Но этот тип НЕ неизменнен. Вы всегда можете переназначить содержимое переменной значением любого типа
--
b = None
----



Операторы:

Типы операторов - 
- арифметические (+, -, *, /, и т.д.)
- сравнения (<, >, <=, >=, ==, !=)
- идентичности (x is y) - проверяет ссылку на адрес в памяти
- присваивания (=, +=, -=, *=, /= и т.д.)
- принадлежности (in)
- логические (and, or, not)
- битовые (&, |)



Операторы сравнения -

Один оператор замазан, там "<>" - он умер вместе с Python 2.7
Все эти операторы используются для того чтобы сравнивать какие-либо значения. Результатом такого сравнения будет True или False
--
print('E' in 'hello')

c = 'text'
d = 'text'
----
print(c is d)
------

--
d = 256
c = 256

print(c is d)
----
True 
------

--
d = 257
c = 257

print(c is d)
print(c == d)
----
False 
True
------

--
print(1 == 1)
print(1 == 2)
print(1 < 2)
print(1 > 2)
print(1 >= 2)
print(1 != 2)
----
True
False
True
False
False
True
------



Арифметические операторы -

+
-
*
/
% - остаток от деления 
** - возведение в степень
// - целочисленное деление 

--
e = 4
print(e % 2)
----
0
------



Порядок операций -

Если в выражении встречается больше, чем один оператор, то порядок вычислений зависит от правил старшинства (rules of precedence). Для математических операций, Python следует математическим соглашениям. Аббревиатура PEMDAS является простым способом для запоминания правил:  
1. Parentheses - Скобки
2. Exponentiation - Возведение в степень
3. Multiplication - Умножение
4. Division - Деление  
5. Addition - Сложение 
6. Subtraction - Вычитания



тип переменной можно указать самому вручную - 
--
name: str = "Alex"
age: int = 42
----

по работе линтера на github - 
- при ошибке в строке вверху кликнуть по "Checks"
- смотреть ошибки после нижних синих двух строк



************************************

4 - lesson_python_basics_2

Операторы присваивания - 

Используются для того, чтобы присвоить какое либо значение переменной.

--
a = 1

a += 1
# a = a + 1

print(a)
----
2
------

--
print('text' + 'text')
text = 'text'
# text = text + ' new'
text += ' new'
print(text)
symbol = '='
# symbol = symbol * 20
symbol *= 30
print(symbol)
print('Copyrights')
print(symbol)
----
texttext
text new
==============================
Copyrights
==============================
------



Операторы принадлежности -

Используются в условных выражениях (выражения, в которых содержится условие) для проверки вхождения (или не вхождения) одного объекта в состав другого. Результат работы - True или False  
Например, можно проверить есть ли какое-то слово в строке:
--
text = 'I love Python!'
print('love' in text)
print('Love' in text)
----
True
False
------



Операторы идентичности -

Используется для проверки является ли объект идентичным тому, что от него требуется (не просто равным по значению, а именно полностью идентичным).  

Происходит проверка являются ли сравниваемые значения представителями одного и того же участка памяти в системе. Для чисел от 0 до 256 участки в памяти зарезервированы, поэтому при помещении в переменную такого числа (от 0 до 256) в переменную помещается не само число, а ссылка на него и память для этого числа не выделяется. Эти числа всегда хранятся в системе по одному и тому же адрему. Но если внести в переменную число больше 256, то под это число выделяется память и в переменную сохраняется ссылка на эту новую ячейку памяти. Если создать еще одну переменную с таким же значением, под нее снова будет выделена память и в переменную будет сохранена ссылка на новую ячейку памяти.  

Таким образом, операторы идентичности проверяют, что сравниваемые объекты представляют собой одну и ту же ячейку памяти.

--
b = 2
print(id(b))

c = 2
print(id(c))

d = 257
print(id(d))

e = 257
print(id(e))

print(b is c)
print(d is not e)
----
139905517617424
139905517617424
139905450350128
139905450348784
True
True
------



Способы ввода данных -
Клавиатура  
Чтение из файла  
База данных  
API  

Но сначала разберемся с одним из них -
--
input('What is your name?')
a = 1
----

--
user_name = input('What is your name?')
print('Hello', user_name, '!')
----
Hello sdfsdfsdfsdf !
------



Касательно функции input, важно знать, что все, что ввел пользователь будет сохранено в переменную как текст, независимо от того что пользователь ввел. Поэтому, если мы ждем от пользователя число и хотим работать с этим как с числом, то нужно будет преобразовать тот текст, который ввел пользователь в число.
--
user_input = int(input('Enter a number'))
print(type(user_input))

print(2 + user_input)
----
-------------------------------------------------------------------
ValueError            Traceback (most recent call last)
/tmp/ipykernel_290489/1698465796.py in <module>
----> 1 user_input = int(input('Enter a number'))
      2 print(type(user_input))
      3 
      4 print(2 + user_input)

ValueError: invalid literal for int() with base 10: 'sdf'
------



Преобразование типов данных -
--
a = '1'
print(type(a))

a = int(a)
print(type(a))

a = str(a)
print(type(a))

b = 'True'
print(type(b))

b = bool(b)
print(type(b))

a = float(a)
print(type(a))

print(a)
----
<class 'str'>
<class 'int'>
<class 'str'>
<class 'str'>
<class 'bool'>
<class 'float'>
1.0
------



Типы данных в Python -

Number (целое число)  
String (строка)  
Boolean (логический тип данных)  
Float(числа с плавающей точкой)  
List (список)  
Dictionary (словарь)  
Tuple (кортеж)  
Set (множество)  



List(списки) -

Python список - структура данных для хранения последовательностей.   
Экземпляры значений, находящихся в списке, называются элементами списка.
--
my_list = [1, 3, 6, 7, None, 'text', False, 2.42, 'sdsdf', 'last', 'last2']
print(my_list)
print(my_list[2])
print(my_list[0])
print(my_list[9])
print(my_list[-1])
print(my_list[-3])

my_list[2] = 42
print(my_list)
----
[1, 3, 6, 7, None, 'text', False, 2.42, 'sdsdf', 'last', 'last2']
6
1
last
last2
sdsdf
[1, 3, 42, 7, None, 'text', False, 2.42, 'sdsdf', 'last', 'last2']
------

--
my_list = []
my_list = list()
my_list.append(42)
my_list.append('text')
print(my_list)
print(len(my_list))
print(my_list.index('text'))
poped = my_list.pop(0)
print(my_list)
print(poped)

print(42 in my_list)
----
[42, 'text']
2
1
['text']
42
False
------



Tuple(кортежи) -

Хранят данные различных типов  
Неизменяемы  
Занимают меньший размер  
Оптимизируются интепретатором   
По поведению похожи на списки. Главное отличие - нет функций, позволяющих что-то добавить в кортеж или изменить внутри него
--
my_tuple = (1, 3, 6, 7, None, 'text', False, 2.42)
print(my_tuple[2])
print(my_tuple[-1])
# my_tuple[4] = 42
----
6
2.42
------

--
my_tuple = ()
my_tuple = tuple()
my_tuple = (1, 5, 2, 6, 1)
print(my_tuple)
print(my_tuple.count(1))
print(my_tuple.index(5))
----
(1, 5, 2, 6, 1)
2
1
------

--
llist = [56]
print(llist)
ttuple = (56,)
print(ttuple)
print(type(ttuple))
----
[56]
(56,)
<class 'tuple'>
------



Set(множества) -

Содержит в себе только неповторяющиеся элементы  
Не гарантирует порядок элементов  
Работа с ним тоже похожа на работу со списком  
--
my_set = {1, 3, 6, 7, None, 'text', False, 2.42, 3, 7}
# print(my_set[2])
my_set.add(42)
my_set.add('text')
print(my_set)
----
{False, 1, 2.42, 3, 6, 7, 42, 'text', None}
------

--
list1 = list(set([1, 2, 5, 6, 2, 1, 8]))
# list1 = set(list1)
# list1 = list(list1)

print(list1)
----
[1, 2, 5, 6, 8]
------

--
my_set = {} # Это словарь
print(type(my_set))
my_set = set() #  Пустой set можно создать только так
print(type(my_set))
----
<class 'dict'>
<class 'set'>
------



Dictionary(словари) -

Словари в Python - коллекции произвольных объектов с доступом по ключу. Их иногда ещё называют ассоциативными массивами или хеш-таблицами.  
  
данные в словаре - это пары ключ: значение  
доступ к значениям осуществляется по ключу, а не по номеру, как в списках  
данные в словаре упорядочены по порядку добавления элементов  
так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять  
ключ должен быть объектом неизменяемого типа: число, строка, кортеж  
значение может быть данными любого типа  

--
my_dict = {'one': 'value', 'two': 'value2'}
print(my_dict['one'])
print(len(my_dict))
my_dict['one'] = 'myvalue'
my_dict['three'] = 'value3'
my_dict['four'] = False
my_dict['five'] = [1, 5, 8]
my_dict['six'] = {1, 6, 9}
my_dict[2] = 'skldjflskdf'
my_dict[False] = 'skdjhskdjf'
my_dict[2.42] = 'werwerw'
my_dict[(1, 2)] = 'ieruyieurtert'
my_dict[5] = {1: 2}



print(my_dict)
print(type(my_dict))

print(my_dict.keys())
print(my_dict.values())
print(my_dict.items())
----
value
2
{'one': 'myvalue', 'two': 'value2', 'three': 'value3', 'four': False, 'five': [1, 5, 8], 'six': {1, 6, 9}, 2: 'skldjflskdf', False: 'skdjhskdjf', 2.42: 'werwerw', (1, 2): 'ieruyieurtert', 5: {1: 2}}
<class 'dict'>
dict_keys(['one', 'two', 'three', 'four', 'five', 'six', 2, False, 2.42, (1, 2), 5])
dict_values(['myvalue', 'value2', 'value3', False, [1, 5, 8], {1, 6, 9}, 'skldjflskdf', 'skdjhskdjf', 'werwerw', 'ieruyieurtert', {1: 2}])
dict_items([('one', 'myvalue'), ('two', 'value2'), ('three', 'value3'), ('four', False), ('five', [1, 5, 8]), ('six', {1, 6, 9}), (2, 'skldjflskdf'), (False, 'skdjhskdjf'), (2.42, 'werwerw'), ((1, 2), 'ieruyieurtert'), (5, {1: 2})])
------

--
a = 1, 2, 3

print(a)
print(type(a))
----
- тут формирует кортеж 



************************************

5 - lesson_python_basics_3

Распаковка -

Используется для того, чтобы распределить элементы коллекции (список, словарь, множество, кортеж) по отдельным переменным.  
Используется только в ситуациях, когда вы наверняка знаете количество элементов, содержащихся в коллекции.
--
my_list = [1, 3]
my_tuple = (2, 6, 9)
# a = my_list[0]
# b = my_list[1]
# c = my_tuple[0]
# d = my_tuple[1]
# e = my_tuple[2]
a, b = my_list
c, d, e = my_tuple
print(a, b, c, d, e)
----
1 3 2 6 9
------



Срез -
  
Извлечение среза позволяет взять из списка определенную его часть
--
lll = [1, 3, 5, 2, 5, 7 ,1, 3]
print(lll)
print(lll[1:4])
print(lll[:4])
print(lll[3:])
print(lll[1::2])
print(lll[:])
print(lll[::-1])
print(lll[::-2])
print(lll[-2:-6:-1])
----
[1, 3, 5, 2, 5, 7, 1, 3]
[3, 5, 2]
[1, 3, 5, 2]
[2, 5, 7, 1, 3]
[3, 2, 7, 3]
[1, 3, 5, 2, 5, 7, 1, 3]
[3, 1, 7, 5, 2, 5, 3, 1]
[3, 7, 2, 3]
[1, 7, 5, 2]
------

когда в python мы указывем ОТ и ДО, то ДО - не включительно (срезы, range и т.п.) кроме одной ситуации, но о ней автор расскажет позже 



Методы строк -

Со строкой можно делать многое из того, что можно делать с другими коллекциями, т.к. строка это по сути тоже коллекция - последовательность символов. Больше всего функциональность строки похожа на функциональность кортежей.
--
text = 'my long long string'
print(text[3])
print(len(text))
print(text.index('long'))
print('long' in text)
print(text.count('n'))
print(text.count('long'))
print(text.find('lone'))
print(text[:7])
print(text.startswith('my'))
print(text.endswith('string'))
----
l
19
3
True
3
2
-1
my long
True
True
------

--
txt = "ThIs tExt wiTh meSsEd uP CaPITalIZatiOn!"
print(txt.capitalize()) # Делает первую букву предложения заглавной
print(txt.title())  # Делает каждую первую букву заглавной
print(txt.upper())  # Делает все буквы большими
print(txt.lower())  # Делает все буквы маленькими
----
This text with messed up capitalization!
This Text With Messed Up Capitalization!
THIS TEXT WITH MESSED UP CAPITALIZATION!
this text with messed up capitalization!
------

--
text = 'mY lOng loNg STRING'
string_index = text.lower().index('string')
print(text[:string_index].lower() + text[string_index:].upper())
----
my long long STRING
------

--
msg = 'Hello world!'
msg = msg.replace('world', 'universe')
print(msg)
----
Hello universe!
------

--
data = '12,3'
data = data.replace(',', '.')
print(data)
----
12.3
------

--
s = "     ss   tttt       iiiii   "

while " " in s:
    s = s.replace(" ", "")
    
print(s)
----
ssttttiiiii
------

--
txt = ' admin '
# txt = txt.replace(' ', '')
# txt = txt.strip()  # убирает пробелы слева и справа
# txt = txt.lstrip()
txt = txt.rstrip()
print(txt)
text = '"name"'
text = text.strip('"')
print(text)
----
 admin
name
------



Строка в список и список в строку -

--
my_string = 'some little text'
my_string2 = 'some,little,text'
list_from_text = my_string.split()
list_from_text2 = my_string2.split(',')
print(list_from_text)
print(list_from_text2)
----
['some', 'little', 'text']
['some', 'little', 'text']
------

--
languages = ['Python', 'Java', 'Ruby']
print(languages)
# languages = ', '.join(languages)
print(languages)
print('Student knows these languages:', ', '.join(languages))
----
['Python', 'Java', 'Ruby']
['Python', 'Java', 'Ruby']
Student knows these languages: Python, Java, Ruby
------



Форматирование строки -

--
a = 'one'
b = 'two'
print('First word is', a, ', second word is', b)


my_text = 'First word is ' + a + ', second word is ' + b
print(my_text)

my_text = 'First word is %s, second word is %s'
print(my_text % (a, b))

#string format
my_text = 'First word is {}, second word is {}'
print(my_text.format(a, b))

my_text = 'First word is {1}, second word is {0}'
print(my_text.format(a, b))

#f-string
my_text = f'First word is {{a}}, second word is {b}'
print(my_text)
----
First word is one , second word is two
First word is one, second word is two
First word is one, second word is two
First word is one, second word is two
First word is two, second word is one
First word is {a}, second word is two
------

--
template = 'Hello, {0}!'
# print(f'Hello, {username}!')
username = input('What is your name?')

print(template.format(username))
----
Hello, Tom!
Hello, Tim!
------

--
a = 'qwe'
b = 'asd'

my_text = 'First word is {{}}, second word is {}'
print_text = my_text.format(b)
print(print_text)

print(print_text.format('qqqqq'))
----
First word is {}, second word is asd
First word is qqqqq, second word is asd
------



************************************

6 - conditions_n_loops

Условия -

if - elif - ... - elif - else

--
user_input = input('your number: ')

if user_input.isnumeric():
    user_input = int(user_input)
    if user_input == 1:
        print('One')
    elif user_input == 2:
        print('two')
    elif user_input == 3:
        print('three')
    else:
        print('many')
else:
    print('Enter a number please')
----
Enter a number please
------

--
user_input = int(input('your number: '))

if user_input == 1:
    print('One')

if user_input == 2:
    print('two')

if user_input not in [1, 2]:
    print('many')
----
many
------

--
if user_input > 0:
    if user_input > 1:
        if user_input == 2:
            print()
        elif user_input == 3:
            if 1 == 1:
                print()
            elif 2 == 2:
                print()
    elif 3 == 3:
        print()
----



Loops - циклы - 

Цикл for (for loop) -
--
names = ['John', 'Tim', 'James', 'Bob', 'Jim', 'Bill']
print(names)
print(names[0])
print(names[1])
print(names[2])
print(names[3])
print(names[4])

for name in names:
    print(name)

print('the end')
----
['John', 'Tim', 'James', 'Bob', 'Jim', 'Bill']
John
Tim
James
Bob
Jim
John
Tim
James
Bob
Jim
Bill
the end
------

--
names = ['John', 'Tim', 'James', 'Bob', 'Jim', 'Bill']


for name in names:
    name = name.replace('i', 'I')
    if name.startswith('J'):
        print('Mr.', end=' ')
    print(name)
----
Mr. John
TIm
Mr. James
Bob
Mr. JIm
BIll
------

--
names = ('John', 'Tim', 'James', 'Bob', 'Jim', 'Bill')
for name in names:
    print(name)
----
John
Tim
James
Bob
Jim
Bill
------

--
persons = {'John': 132, 'Tom': 167, 'James': 234}
for person in persons:
    print(person)
----
John
Tom
James
------

--
persons = {'John': 132, 'Tom': 167, 'James': 234}
print(persons.keys())
for person in persons.keys():
    print(person)
----
dict_keys(['John', 'Tom', 'James'])
John
Tom
James
------

--
persons = {'John': 132, 'Tom': 167, 'James': 234}
print(persons.values())
for person in persons.values():
    print(person)
----
dict_values([132, 167, 234])
132
167
234
------

--
persons = {'John': 132, 'Tom': 167, 'James': 234}
for person in persons:
    print(f'{person}: {persons[person]}')
----
John: 132
Tom: 167
James: 234
------

--
persons = {'John': 132, 'Tom': 167, 'James': 234}
for name, height in persons.items():
    print(f'{name}: {height}')
----
John: 132
Tom: 167
James: 234
------



Распечатать все слова, в которых есть бука "о" и выбросить из текста, текст в конце рапечатать -
--
text = 'Sed vitae justo malesuada, commodo libero eu, bibendum mauris.'

words = text.split()
fin_words = []
for word in words:
    if 'o' in word:
        print(word)
        # words.remove(word)
    else:
        fin_words.append(word)

print(' '.join(words))
----
justo
commodo
Sed vitae malesuada, libero eu, bibendum mauris.
------



************************************

7 - loops_n_funcs

while loop - цикл while -
--
i = 0

while i < 5:
    print('hello')
    i += 1

print('The end')
----
hello
hello
hello
hello
hello
The end
------

--
while True:
    user_input = input('Enter something: ')
    if user_input == 'exit':
        break
    elif user_input == 'skip':
        print('skipping.....')
        continue
    elif len(user_input) > 10:
        print('Your input is too long')
    else:
        print('input is ok')

print('Good bye!')
----
skipping.....
input is ok
input is ok
Good bye!
------

--
text = 'Sed vitae justo malesuada, commodo libero eu, bibendum mauris.'

words = text.split()
fin_words = []
for word in words:
    if word == 'end':
        break
    elif 'o' in word:
        print(word)
        continue
    fin_words.append(word)

print(' '.join(fin_words))
----
justo
commodo
libero
Sed vitae malesuada, eu, bibendum mauris.
------



Functions -

Это самые основные программные структуры в языке Python, позволяющие многократное использование программного кода и уменьшающие его избыточность. Так же позволяют разбить сложную систему на достаточно простые и легко управляемые части. Они могут принимать аргументы и возвращать результаты выполнения.


DRY - don't repeat yourself

--
a = 1
b = 5
c = 4
d = 7
y = 1


main_number = 47

if y == 0:
    print(a)
else:
    print(a + main_number)
if y == 0:
    print(b)
else:
    print(b + main_number)
if y == 0:
    print(c)
else:
    print(c + main_number)
if y == 0:
    print(d)
else:
    print(d + main_number)
----
48
52
51
54
------

--
a = 1
b = 5
c = 4
d = 7
y = 0


main_number = 47

def calc(numb):
    if y == 0:
        print(numb)
    else:
        print(numb + main_number)

calc(a)
calc(b)
calc(c)
calc(d)
----
1
5
4
7
------

--
a = 1
b = 5
c = 4
d = 7
y = 1

main_number = 47

def calc(numb):
    if y == 0:
        return numb
    else:
        result = numb + main_number
        return result
    

print(calc(a))
# result_b = calc(b)
# print(result_b)
# calc(c)
# calc(d)
----
48
None
------

--
def hello():
    a = 12
    return None

print(hello())
----
None 
------

--
def print_words(first, second, third, fourth, fifth):
    print(f'The first word is {first}, second word is {second}, {third}, {fourth}, {fifth}')

print_words('one', 'two', 'three', 'four', 'five')
print_words(fifth='five', third='three', fourth='four', first='one', second='two')
----
The first word is one, second word is two, three, four, five
The first word is one, second word is two, three, four, five
------

--
def power(number, degree=2):
    return number ** degree

print(power(2))
print(power(2, 3))
----
4
8
------

--
def example(e, f, g, ff='one', gg='two'):
    print(e, f, g, ff, gg)

example(2, 3, 6, gg=444)
example(3, 5, 7)
----
2 3 6 one 444
3 5 7 one two
------

--
print('string')
print('werwer', 'erert', 'werwer')

def print(word):
    ...

def print(word1, wrod2, word3):
    ...
----

--
def sum_all(*args):
    # print(args)
    # result = 0
    # for x in args:
    #     result += x
    # return result
    return sum(args)

print(sum_all(1, 4, 6, 5, 7))
----
23
------

--
def price_list(title, price):
    print(f'Product {title} price is {price}')

price_list('iphone', 2500)
price_list('laptop', 1500)
----
Product iphone price is 2500
Product laptop price is 1500
------

--
def price_list(list_title, *args, default_qty=234, **kwargs):
    print(list_title)
    for title, price in kwargs.items():
        print(f'Product {title} price is {price}')


price_list('Products prices', iphone=2500, laptop=1500, samsung=2000, monitor=1000)
----
Products prices
Product iphone price is 2500
Product laptop price is 1500
Product samsung price is 2000
Product monitor price is 1000
------



************************************

8 - generators_and_modules

Generator function -
--
def generate_text(text1, text2):
    return f'Text consists on the wrods:{text1} and {text2}'
    a = 1
print(generate_text('Ivan', 'Ivanov'))
----
Text consists on the wrods:Ivan and Ivanov
------

--
my_list = [1, 2, 5, 7, 4, 9]

for x in my_list:
    print(x)
----

--
n = 2

progression = []
num = 1
while len(progression) < 1_000_000_000:
    progression.append(num)
    num += n
----

--
def progression(limit=100):
    n = 2
    num = 1
    count = 1
    while count < limit:
        yield num
        num += n
        count += 1

# for number in progression(10):
#     print(number)
# print(list(progression(10)))

count = 1
for number in progression(10000000000000000000000000000000000000000):
    if count == 1000000:
        print(number)
        break
    count += 1
----
1999999
------



ключевое слово - yield -
--
def get_numbers_yield(n):
    for i in range(n):
        yield i  # Отдаем по одному числу за раз

    
gen = get_numbers_yield(3)

print(next(gen)) # Выведет 0
print(next(gen)) # Выведет 1 (функция "проснулась" там же, где остановилась
----
0
1
------



раньше в каждую папку проекта на python добавлялся файл __init__.py, в котором ничего не было, он просто инициировал папку как директорию python, но сейчас это уже делать не нужно 



импорты (модули) -
--
import random 
from random import randint
----
random.randrange(0, 10, 2)  # тут 10 НЕ используется в ряде генерации
randint(1, 100)  # при этом тут 100 тоже используется в ряде генерации
------

то есть в завистимости от названия функции -
- random.randint(1, 10) - последнее число входит в последовательность 
- random.randrange(1, 10) - последнее число НЕ входит в последовательность 

- random.randint(1, 10) - это единственное исключение в python, когда последнее число входит в последовательность

--
import random 

users = ["user_1", "user_2", "user_3"]
print(random.choice(users))
----

--
import os 
import sys

print(sys.platform)
----
Win32 
------

в python библиотеки называются модулями 

--
import selenium 
----

перед тем, как импортировать модуль, его нужно установить - 
pip install selenium 

для каждого модуля отдельно гуглить, как его установить, или посмотреть на сайте - 
pypi.org 

виртуальное окружение - все модули устанавливать только внутри своего проекта 

создать свой собственный модуль - допустим создадим файл helper.py в котором напишем функцию и переменную - 
--
helper.py
--
def assist():
    print("I am an assistant")

variable = "I am a variable"
----
и импортируем этот модуль в другой файл проекта -
--
import helper 

helper.assist()
print(helper.variable)
----

если нужно импортировать файл из другой папки, то нужно прописать полный путь от корня проекта, например - 
--
from homework.okulik.utils import helper 

helper.assist()
.....
----

если нужна только одна функция из модуля, то импортировать так, и уже обращение идет напрямую к методу (не helper.assist() а уже assist()) - 
--
from homework.okulik.utils.helper import assist 

assist()
.....
----
- но такой подход не рекомендуется, так как он нарушает читаемость кода (то есть принято импортировать модуль, а не методы (функции)) 



а так делать вообще не рекомендуется - 
--
from random import *

randint()
.....
----



можно делать переназначения - 
--
import random as rd 

rd.randrange()
.....
----



если из двух разных модулей импортируются функции с однаковоыми названиями, то работать будет только та, импорт которой прописан последним (ниже чем первый)



это код автора - 
--
# import random
from random import random, randint, randrange, choice
# from random import *
from homework.eugene_okulik.utils.helper import assist as assist1
from homework.eugene_okulik.utils.help2 import assist as assist2
from homework.eugene_okulik.utils.help2 import very_useful_function_for_your_easy_life as useful

# print()
# input()
# int()

# print(random.random())
# print(f'Your price is {int(random.random() * 100)}')
# print(random.randint(0, 1))
# print(random.randrange(0, 10, 2))
# users = ['user11', 'user12', 'user100']
# print(random.choice(users))

print(random())
print(f'Your price is {int(random() * 100)}')
print(randint(0, 1))
print(randrange(0, 10, 2))
users = ['user11', 'user12', 'user100']
print(choice(users))

assist1()
# print(helper.variable)
while 'sldkjfl' == 'sdsdfsdf':
    if 'sldkjfl' == 'sdsdfsdf':
        print(f'skadflkasdjfhalsdkjhlaksdfjhlaksjdfh {useful()}')
----

ДЗ - создать в своем проекте python виртуальное окружение 



************************************

9 - map_and_filter_and_datetime

хорошая практика - писать в коде "if x is True:" а не "if x == True:", а лучше писать просто - "if x:" 

--
summer = True

if summer is True:
    print('The weather is fine')
else:
    print('The weather is not fine')
----
The weather is fine
------

--
import random
summer = random.choice([False, True])

if summer:
    print('The weather is fine')
else:
    print('The weather is not fine')
----
The weather is not fine
------

--
a = 0

if a is not None:
    print('...')
----
...
------



In-built functions - встроенные функции -
--
numbers = [1, 45, 23, 67, 32, 89]
print(max(numbers))

# max_num = 0
# for x in numbers:
#     if x > max_num:
#         max_num = x

# print(max_num)

print(min(numbers))
print(sum(numbers))

a = 1 / 3
print(round(a, 2))

print(abs(1))

print(sorted(numbers))  # не меняет исходный список
print(sorted(numbers, reverse=True))
print(numbers)
numbers.sort()  # меняет исходный список 
print(numbers)
numbers.sort(reverse=True)
print(numbers)
----
89
1
257
0.33
1
[1, 23, 32, 45, 67, 89]
[89, 67, 45, 32, 23, 1]
[1, 45, 23, 67, 32, 89]
[1, 23, 32, 45, 67, 89]
[89, 67, 45, 32, 23, 1]
------



Map (mapping - сопоставление) - применение операции к каждому элементу -
--
my_list = [1, 2, 3, 4, 5]

new_list = []
for x in my_list:
    new_list.append(x * 2)

print(new_list)
----
[2, 4, 6, 8, 10]
------

--
my_list = [1, 2, 3, 4, 5]

def mult_by_2(x):
    return x * 2

new_list = map(mult_by_2, my_list)
print(list(new_list))
----
[2, 4, 6, 8, 10]
------

--
name, surname = input('Your name and surname').split()
print(f'name is {name}, surname is {surname}')
----
name is Eugene, surname is Okulik
------

--
code, number = map(int, input('code and number').split())
print(f'name is {code + 1}, surname is {number + 2}')
----
name is 235, surname is 3453456
------



lambda-функция (анонимная функция) -
--
lambda x: x * 5 if x > 10 else x * 2
----

--
sp = [1, 2, 3]

sp2 = list(map(lambda x: x * 5 if x > 10 else x * 2, sp))
print(sp2)
----
[2, 4, 6]
------

--
my_list = [1, 2, 3, 4, 5]


new_list = map(lambda x: x * 2, my_list)
print(list(new_list))
----
[2, 4, 6, 8, 10]
------

объект генератора напрямую взять нельзя, можно перебрать его с помощью цикла или преобразовать в список - list(....)



Тернарный оператор (в одну строку) - 
--
x * 5 if x > 10 else x * 2
----

--
my_list = [1, 2, 3, 4, 5]

def mult_by_2(x):
    if x > 10:
        return x * 5
    else:
        return x * 2

new_list = map(lambda x: x * 5 if x > 10 else x * 2, my_list)
print(list(new_list))
----

--
my_list = [1, 2, 3, 4]
b = 1 if len(my_list) > 4 else 5

print(b)
----
5
------



Filter -
--
my_list2 = [1, 2, 3, 4, 5, 6, 7, 8]

new_list2 = []
for x in my_list2:
    if x % 2 == 0:
        new_list2.append(x)

print(new_list2)
----
[2, 4, 6, 8]
------

--
my_list2 = [1, 2, 3, 4, 5, 6, 7, 8]

def is_even(x):
    if x % 2 == 0:
        return True
    else:
        return False


new_list2 = filter(is_even, my_list2)
print(list(new_list2))
----
[2, 4, 6, 8]
------

--
my_list2 = [1, 2, 3, 4, 5, 6, 7, 8]

def is_even(x):
    return x % 2 == 0


new_list2 = filter(is_even, my_list2)
print(list(new_list2))
----
[2, 4, 6, 8]
------

--
my_list2 = [1, 2, 3, 4, 5, 6, 7, 8]


new_list2 = filter(lambda x: x % 2 == 0, my_list2)
print(list(new_list2))
----
[2, 4, 6, 8]
------



Datetime -
--
import datetime

time_now = datetime.datetime.now()
print(time_now)
print(time_now.hour)
print(time_now.year)
# print(time_now.weekday())
print(time_now.isoweekday())
print(time_now.timestamp()) - количество секунд с начала эпохи Linux
----
2023-11-09 20:56:07.493825
20
2023
4
1699552567.493825
------

--
easy_date = datetime.datetime(1360, 1, 15)
print(easy_date)
print(easy_date.timestamp())
----
1360-01-15 00:00:00
-19248544216.0
------

--
my_time = '2023/06/05 12 hours, 30 mins, 10 secs'

python_date = datetime.datetime.strptime(my_time, '%Y/%m/%d %H hours, %M mins, %S secs')

print(python_date)
print(python_date.month)
----
2023-06-05 12:30:10
6
------

https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes

--
human_date = python_date.strftime('Year: %y, month: %B, day: %d')
print(human_date)
----
Year: 23, month: June, day: 05
------



моя практика по sorted и sort - 
--
sp = [2, 8, 3, 9, 5, 4, 6, 1]

sp2 = sorted(sp)  # не меняет начальный список
print(sp2)  
print(sp)

sp.sort() # меняет начальный список
print(sp)
----
[1, 2, 3, 4, 5, 6, 8, 9]
[2, 8, 3, 9, 5, 4, 6, 1]
[1, 2, 3, 4, 5, 6, 8, 9]
------



************************************

10 - decorators_and_list_dict_comprehension

Decorators - 
--
def calc():
    print(1 + 1)

calc()
print(calc)
new_calc = calc
print(new_calc)
new_calc()
----
2
<function calc at 0x7fa818414f70>
<function calc at 0x7fa818414f70>
2
------

--
def greet():

    def hello():
        return 'hello'
    
    return hello()

print(greet())
----
hello 
------

--
def outer():

    def inner():
        result = 2 + 5
        return result
    
    return inner


print(outer()())
inner_function = outer()
print(inner_function())
----
7
7
------

--
def func1(give_me_a_func):
    print('before')
    give_me_a_func()
    print('after')


def simple1():
    print('simple1')

def simple2():
    print('simple2')

simple1()
simple2()

func1(simple1)
func1(simple2)

def simple3():
    print('I')
    print('love')
    print('Python')
    print('and')
    print('decorators')

func1(simple3)
----
simple1
simple2
before
simple1
after
before
simple2
after
before
I
love
Python
and
decorators
after
------

--
def add_text(func):

    def wrapper():
        print('before')
        func()
        print('after')

    return wrapper


def simple1():
    print('simple1')

simple1()

simple1 = add_text(simple1)

print(simple1)
simple1()
    

def simple2():
    print('simple2')

simple2()

simple2 = add_text(simple2)

simple2()
----
simple1
<function add_text.<locals>.wrapper at 0x7fa8184145e0>
before
simple1
after
simple2
before
simple2
after
------



декоратор позволяет добавить какое-либо действие до и/или после функции, по синтаксису - пред декоратором пишется @
--
def add_text(func):

    def wrapper():
        print('before')
        func()
        print('after')

    return wrapper


@add_text
def simple1():
    print('simple1')

@add_text
def simple2():
    print('simple2')
    print('simple2')

simple1() # add_text(simple1)() - python понимает что нужно вызвать так
simple2()
----
before
simple1
after
before
simple2
after
------



самому писать свои декораторы тебе писать придется редко, если вообще придется

вложенную функцию, имя которой возвращается без скобок, обычно всегда называют - wrapper

узнать имя запускаемой функции - 
print(f"{name_parametr.__name__}") - Это используется когда функция передается аргументом в другую функцию под наименованием параметра
--
def add_logs(func):
    
    def wrapper():
        print(f'function {func.__name__} started')
        result = func()
        print(f'finished {func.__name__}')
        return result
        
    return wrapper


@add_logs
def simple1():
    print('simple1')


@add_logs
def simple2():
    print('simple2')
    print('simple2')


@add_logs
def print_nothing():
    return 'hello'

@add_logs
def calc(x):
    print(x * 2)

simple1()
simple2()
print(print_nothing())
calc(3)
----
function simple1 started
simple1
finished simple1
function simple2 started
simple2
simple2
finished simple2
function print_nothing started
finished print_nothing
hello
------------------------------------------------------
TypeError            Traceback (most recent call last)
/tmp/ipykernel_1009755/3607865929.py in <module>
     33 simple2()
     34 print(print_nothing())
---> 35 calc(3)

TypeError: add_logs.<locals>.wrapper() takes 0 positional arguments but 1 was given
------

--
def add_logs(func):
    
    def wrapper(*args):
        print(f'function {func.__name__} started')
        result = func(*args)  # распаковывает кортеж (убирает скобки)
        print(f'finished {func.__name__}')
        return result
        

    return wrapper

@add_logs
def simple1():
    print('simple1')

@add_logs
def print_nothing():
    return 'hello'

@add_logs
def calc(x):
    print(x * 2)

@add_logs
def calc2(x, y):
    print(x * y)

simple1()
print(print_nothing())
calc(3)
calc2(3, 7)
----
function simple1 started
simple1
finished simple1
function print_nothing started
finished print_nothing
hello
function calc started
6
finished calc
function calc2 started
21
finished calc2
------



*args - распаковывает кортеж (убирает скобки) - 
--
def func(*args):
    # print((1, 2, 3, 5, 9))
    print(*args)
    # print(1, 2, 3, 5, 9)

func(1, 2, 3, 5, 9)
----
1 2 3 5 9
------



List comprehension (генератор списков, лист компрехеншен) -
--
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 10]

new_list = []
# for x in my_list:
#     new_list.append(x * 2)
new_list = [x * 2 for x in my_list]
# new_list = map(lambda x: x * 2, my_list)


print(new_list)
----
[2, 4, 6, 8, 10, 12, 14, 16, 20]
------

--
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 10]

# new_list = []
# for x in my_list:
#     if x % 2 == 0:
#         new_list.append(x)

# new_list = filter(lambda x: x % 2 == 0, my_list)
new_list = [x for x in my_list if x % 2 == 0]
new_list2 = [x if x % 2 == 0 else x + 1 for x in my_list]
new_list2 = [x if x % 2 == 0 else print(f'{x} is not even') for x in my_list]
new_generator = (x for x in my_list if x % 2 == 0)

print(new_list)
print(new_list2)
print(new_generator)
----
1 is not even
3 is not even
5 is not even
7 is not even
[2, 4, 6, 8, 10]
[None, 2, None, 4, None, 6, None, 8, 10]
<generator object <genexpr> at 0x7fa7fb66c580>
------

--
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 10]

{1: 3, 'SDFSDF': 'WER'}

# new_dict = {}
# for x in my_list:
#     new_dict[x] = x * 3

new_dict = {x: x * 3 for x in my_list}

print(new_dict)
----
{1: 3, 2: 6, 3: 9, 4: 12, 5: 15, 6: 18, 7: 21, 8: 24, 10: 30}
------

--
data = [('one', 'two'), ('three', 'four')]

# new_dict = {}
# for key, value in data:
#     new_dict[key] = value

new_dict = {key: value for key, value in data}
new_dict = dict(data) # то же самое что и строка выше

print(new_dict)
----
{'one': 'two', 'three': 'four'}
------

--
countries = ['USA', 'Hawaii', 'Cuba']
temps = [23, 33, 35]

country_temps_dict = dict(zip(countries, temps))
print(country_temps_dict)
----
{'USA': 23, 'Hawaii': 33, 'Cuba': 35}
------

zip() - создает список двухзначных кортежей, а если впереди написать dict, то собирает словарь из двух итерируемых последовательностей


  
************************************

11 - python_classes

Classes -
--
from abc import abstractmethod


class Group:
    pupils = True
    school_name = 42
    director = 'Marivanna'

    def __init__(self, title, pupils_count, group_leader):
        self.title = title
        self.pupils_count = pupils_count
        self.group_leader = group_leader

    def study(self):
        print('sit down and read')

    @abstractmethod
    def move(self):
        pass


class PrimaryGroup(Group):
    max_age = 11
    min_age = 6
    building_section = 'left'

    def __init__(self, title, pupils_count, group_leader, class_room):
        super().__init__(title, pupils_count, group_leader)
        self.class_room = class_room

    def move(self):
        print('Run fast')


class HighGroup(Group):
    max_age = 18
    min_age = 14

    def move(self):
        print('Go slowly')

class MediumGroup(Group):
    max_age = 15
    min_age = 10
----



объект класса = объект типа = представитель класса = экземпляр класса -
--
first_a = PrimaryGroup('1a', 18, 'MF', 5)
first_b = PrimaryGroup('1b', 20, 'TD', 8)

eleven_a = HighGroup('11a', 22, 'AR')
six_a = MediumGroup('6a', 25, 'RI')


print(first_a.pupils_count)
print(first_a.class_room)
print(first_b.title)
print(first_a.title)
print(first_a.pupils)
print(first_a.building_section)
print(first_a.director)
print(first_a.max_age)
print(first_a.min_age)
print(first_a.school_name)
print(eleven_a.pupils)
# print(eleven_a.building_section)
print(eleven_a.director)
print(eleven_a.max_age)
print(eleven_a.min_age)
print(eleven_a.school_name)
first_a.study()
eleven_a.study()
first_a.move()
eleven_a.move()
six_a.move()
----
18
5
1b
1a
True
left
Marivanna
11
6
42
True
Marivanna
18
14
42
sit down and read
sit down and read
Run fast
Go slowly
------

метод отличается от функции тем, что метод всегда находится внутри класса и у метода первым параметром в скобках всегда является self 

абстрактный метод - имеет название, имеет какое-то действие, но не реализует его, и любой класс, где есть абстрактный метод, является абстрактным классом - 
--
from abc import abstractmethod


class Group:
    pupils = True
    school_name = 42
    director = 'Marivanna'

    def __init__(self, title, pupils_count, group_leader):
        self.title = title
        self.pupils_count = pupils_count
        self.group_leader = group_leader

    def study(self):
        print('sit down and read')

    @abstractmethod
    def move(self):
        pass

.......

----


  
************************************

12 - python_oop

ООП(OOP) - Объектно ориентированное программирование

Приципы ООП:
- Инкапсуляция (Encapsulation)
- Наследование (inheritance)
- Полиморфизм (Polymorphism)

Инкапсуляция -
Все данные объекта должны хранится в объекте. Никто не может изменить данные объекта без его ведома.

Наследование -
Объекты и их типы организуют иерархию типов. Дочерние типы наследуют свою функциональность от родительского класса, расширяя и дополняя её.

Полиморфизм -
Способность классов менять своё поведение в зависимости от типов операций и операндов. Полиморфизм в программировании реализуется через перегрузку метода, либо через его переопределение.

В python классы создавать не обязательно, в отличие от java, там обязательно сначала создается класс, а потом в нем уже методы (функции)

--
from abc import abstractmethod


class Group:
    pupils = True
    school_name = 42
    director = 'Marivanna'

    def __init__(self, title, pupils_count, group_leader):
        self.title = title
        self.pupils_count = pupils_count
        self.group_leader = group_leader


    def study(self):
        print('sit down and read')

    @abstractmethod
    def move(self):
        pass


class PrimaryGroup(Group):
    max_age = 11
    min_age = 6
    building_section = 'left'

    def __init__(self, title, pupils_count, group_leader, class_room):
        super().__init__(title, pupils_count, group_leader)
        self.class_room = class_room

    def move(self):
        print('Run fast')


class HighGroup(Group):
    max_age = 18
    min_age = 14

    def move(self):
        print('Go slowly')

class MediumGroup(Group):
    max_age = 15
    min_age = 10
----

--
first_a = PrimaryGroup('1 A', 15, 'SD', 112)
first_a.class_room = 1000000
print(first_a.class_room)
----
1000000
------

--
# data1.txt
{"Country": "Turkey", "avg_temp": 30}
# data2.txt
{"Country": "Greece", "avg_temp": 28}
----

при обращении к файлу, если он не лежит в той же папке где и файл проекта, в open() нужно прописать полный путь к файлу - 
"/home/user_1/data1.txt"

"r" - чтение
"w" - запись (при этом стирает всё, что было до этого в файле)
"a" - запись в конец файла

--
file_data = open("data1.txt", "r")
data = file_data.read()
print(data)
file_data.close()
----
- но лучше так не делать, лучше писать через with, при его использовании файл автоматически закрывается после окончания работы

json.load() - превратит содержание файла в словарь (dict) 
json.loads() - превратит строку (str) в словарь (dict) 

--
import json

def read_file(filename):
    file_data = open(filename, 'r')
    # data = file_data.read()
    data = json.load(file_data)  # преобразует JSON в словарь (dict)
    file_data.close()
    return data

data1 = read_file('data1.txt')
data2 = read_file('data2.txt')

print(data1['Country'])
print(data1['avg_temp'])
print(data2['Country'])
print(data2['avg_temp'])
----
Turkey
30
Greece
28
------

одна черточка внизу - объявление свойства защищенным - 
self._temp

две черточки внизу - объявление свойства приватным - 
self.__temp

то есть _ и __ мы помечаем, что эти свойства и методы не для использования извне, а для использования внутри объекта класса

но в коде не должно быть таково, чтобы при вызове после точки ставились _ или _ -
--
data1._avg
data1.__avg
----
- вот так быть не должно 

@property - декоратор, который позволяет прочитать идущий за ним метод, возвращающий приватные значения (называется "геттер") - 
--
class CountryData:
    def __init__(self, filename):
        self.__filename = filename
        self.__data = self.__read_file()
        self._comfort = self.__is_comfort()

    @property
    def data(self):
        return self.__data
----

а таким образом можно изменять приватные значения (называется "сеттер") - 
--
    @comfort.setter
    def comfort(self, value):
        self._comfort = value
----

для любого класса, даже если он не наследует родительский класс, родительским всегда также являестс класс object, ему и принадлежат родительские методы 

магические функции - 
--
    def __str__(self):
        return f'str File {self.__filename} with data {self.__data}'
    
    def __repr__(self):
        return f'repr File {self.__filename} with data {self.__data}'
    
    def __lt__(self, obj):
        return self.avg_temp < obj.avg_temp
    
    def __le__(self, obj):
        return self.avg_temp <= obj.avg_temp
    
    def __add__(self, obj):
        return [self, obj]
		# или так ? -
		# return [self.__data, obj.data]
----

__str__ - говорит python что делать, когда кто-то хочет превратить в строку мой объект 

__repr__ - почти то же самое, что и __str__

методы __lt__, __le__ и другие аналогичные магические методы используются для сравнения (больше, меньше, меньше или равно и т.д.)

__add__ - магический метод для сложения

в obj всегда попадает то, что идет после оператора (<, >, и т.д.)



--
import json


class CountryData:
    def __init__(self, filename):
        self.__filename = filename
        self.__data = self.__read_file()
        self.__country = self.__data['Country']
        self.__avg_temp = self.__data['avg_temp']
        self._comfort = self.__is_comfort()

    @property
    def data(self):
        return self.__data

    @property
    def country(self):
        return self.__country

    @property
    def avg_temp(self):
        return self.__avg_temp

    @property
    def comfort(self):
        return self._comfort

    @comfort.setter
    def comfort(self, value):
        self._comfort = value

    def __read_file(self):
        file_data = open(self.__filename, 'r')
        data = json.load(file_data)
        file_data.close()
        return data

    def __is_comfort(self):
        return self.__avg_temp > 25
    
    def __str__(self):
        return f'str File {self.__filename} with data {self.__data}'
    
    def __repr__(self):
        return f'repr File {self.__filename} with data {self.__data}'
    
    def __lt__(self, obj):
        return self.avg_temp < obj.avg_temp
    
    def __le__(self, obj):
        return self.avg_temp <= obj.avg_temp
    
    def __add__(self, obj):
        return [self, obj]
----

--
data1 = CountryData('data1.txt')
data1.comfort = False
print(data1.comfort)
# data1.data = 'skdfjhskdjf'
print(data1.data)
# data1.__data = {'1': 5}
print(data1.data)
print(data1.country)
# print(data1.avg_temp)
data2 = CountryData('data2.txt')
print(data2.country)
data1.__avg_temp = 2342342
print(data1.avg_temp)
----
False
{'Country': 'Turkey', 'avg_temp': 30}
{'Country': 'Turkey', 'avg_temp': 30}
Turkey
Greece
30
------

--
# data3.txt
{"Country": "Poland", "avg_temp": 15, "min_temp": 2}
----

--
class CountryDataWithMinTemp(CountryData):
    def __init__(self, filename):
        super().__init__(filename)
        self.min_temp = self.data['min_temp']


data3 = CountryDataWithMinTemp('data3.txt')
print(data3.avg_temp)
print(data3.min_temp)
----
15
2
------

--
print(data1)  # print(str(data1))
print(data1 < data2)
print(data1 <= data2)
print(data1 > data2)
print(data1 >= data2)
print(data1 + data2)
----
str File data1.txt with data {'Country': 'Turkey', 'avg_temp': 30}
False
False
True
True
[repr File data1.txt with data {'Country': 'Turkey', 'avg_temp': 30}, repr File data2.txt with data {'Country': 'Greece', 'avg_temp': 28}]
------

--
class MyClass:
    @property
    def my_word(self):
        return 'hello'
    
    def act(self):
        print('hello')
    

qqq = MyClass()
qqq.act()
qqq.my_word
----
hello
------
+
----
'hello'
------


  
************************************

13 - python_tools

with - (с) ключевое слово

as - (как) ключевое слово 

--
data.txt 
--
first, line.
second, line.
third, line.
----

--
files.py
--
import os

# data_file = open('data.txt', 'r')
# data_file.read()
# print('sdfsdf' + 1)
# data_file.close()

base_path = os.path.dirname(__file__)
# base_path = 'C:\\users\\username\\projects\\congenial_testers\\homework\\homework\\eugeny_okulik\\Lesson_13'
# file_path = f'{base_path}/data.txt'
file_path = os.path.join(base_path, 'data.txt')
new_file_path = os.path.join(base_path, 'data2.txt')
print(file_path)


def read_file():
    with open(file_path, 'r') as data_file:
        # print(data_file)
        for line in data_file.readlines():
            yield line


for data_line in read_file():
    with open(new_file_path, 'a') as new_file:
        data_line = data_line.replace('.', '').replace(',', '')
        new_file.write(data_line)

homework_path = os.path.dirname(os.path.dirname(base_path))
alina_file_path = os.path.join(homework_path, 'AlinaKravch', 'file.txt')
print(alina_file_path)


with open(alina_file_path) as alina_file:
    print(alina_file.read())
----

00-10-00























