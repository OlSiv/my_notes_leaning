ЭТИ КУРСЫ ТУТ - 

python - 
https://stepik.org/course/209150/promo

parsing - 
https://stepik.org/course/209546/promo

взял 07.12.2024 - 450 руб. + 285 руб. 

это Баданов - у него ранее покупал курс по DE



************************************
************************************
************************************

КУРС - Python Engineer с нуля до junior

************************************
************************************
************************************

Для возможности задавать вопросы преподавателям, а также состоять в группе единомышленников и одногруппников, можно вступить в чат по ссылке -
https://t.me/+lIvySxhZXGZhM2My

По ссылке можно и нужно отслеживать изменения курса -
https://t.me/stepik_hello_py

************************************

2.1 - Что такое программирование?

нужно только желаниие обучаться 

чат-боты, ИИ - изучение python не углубленно, а широко, и потом выбрать ту область которую захочешь 

нужен только один монитор 

в программировании сложно, но не очень - 
python + библиотеки к нему 

************************************

2.2 - Актуальность Python

+

************************************

2.3 - Что можно сделать на Python

+

************************************

2.4 - Что такое PEP 8 и почему это важно

PEP 8 (Python Enhancement Proposal 8) — это официальный стиль кодирования для языка программирования Python. Этот документ был предложен Гвидо ван Россумом, создателем Python, и Тимом Петерсом, одним из ключевых разработчиков языка, и описывает правила форматирования кода, которые помогают сделать код Python более читаемым и единообразным.

Основные положения PEP 8:

- Отступы: Использование четырёх пробелов для отступов. Это помогает поддерживать единообразие кода и делает его легко читаемым. Важно избегать смешивания пробелов и табуляций.

- Максимальная длина строки: Рекомендуется, чтобы строки кода не превышали 79 символов. Это облегчает чтение кода на экранах с небольшой шириной и помогает в многооконной работе.

- Пробелы в выражениях и операторах: PEP 8 описывает, где следует и не следует использовать пробелы в коде. Например, пробелы не используются внутри скобок, но должны быть вокруг операндов в выражениях.

- Именование переменных и функций: PEP 8 рекомендует использовать нижний регистр с подчеркиваниями (snake_case) для переменных и функций, а для классов — стиль CamelCase.

- Импорт модулей: Все импорты должны быть в начале файла, отдельно от остального кода. Импорты должны быть структурированы в определённом порядке: стандартные библиотеки, сторонние библиотеки, и затем модули самого проекта.

- Документирование: PEP 8 рекомендует использовать строки документации (docstrings) для описания назначения функций, классов и методов.



Почему PEP 8 важен:

1. Читаемость кода: Одной из главных целей PEP 8 является улучшение читаемости кода. Когда код написан в соответствии с единым стилем, его легче читать и понимать. Это особенно важно в командной разработке, где код пишет и поддерживает множество людей.

2. Поддержка и сопровождение кода: Когда код следует единым правилам форматирования, его проще поддерживать. Новым разработчикам легче подключиться к проекту и начать работу с существующим кодом, если он структурирован по понятным и общепринятым правилам.

3. Снижение ошибок: Следование PEP 8 может помочь снизить вероятность появления ошибок. Например, использование четырёх пробелов для отступов вместо табуляций помогает избежать проблем, связанных с различной интерпретацией отступов в разных текстовых редакторах.

4. Инструменты автоматической проверки: Существуют инструменты, такие как flake8, pylint и black, которые автоматически проверяют и форматируют код в соответствии с PEP 8. Использование этих инструментов помогает поддерживать качество кода на высоком уровне и следить за его соответствием общепринятым стандартам.

5. Профессионализм: Код, написанный в соответствии с PEP 8, демонстрирует профессиональный подход к программированию. Это показывает, что разработчик заботится о качестве своего кода и уважает работу других, следуя общим стандартам.


В Pycharm есть удобное сочетание клавиш Ctrl + alt + L для быстрого исправления

************************************

2.5 - Установка всего необходимого

Для начала перейдем по ссылке - https://www.jetbrains.com/pycharm/download/?section=mac
Далее на странице найдем версию Community Edition, она бесплатна.

У Вас проектов может не быть, если Вы раньше не работали с этой программой. Поэтому нажимаем на кнопку "New Project".

Далее конфигурируем проект. Введем название, выберем путь, где его сохранить. В Python Version можно указать любую версию Python и она скачается. Скачивайте больше 3.10.

Все, что слева находится  является корнем проекта. Папки внутри директории .venv и External Libraries являются служебными. Создадим первый скрипт, чтобы проверить, что все установилось корректно.

Для этого нажмем на название проекта, щелкнем правой кнопкой мыши, New, Python File.

Введем название нашего скрипта. У меня это будет main. Обязательно на английском.

Preferences - это настройки. 

************************************

3.1 - Переменные

все файлы python называются скриптами 

переменная - это определенная область памяти, на которую мы можем сослаться 

--
main.py 
--
print("Hello, world!")

count_apple = 5 
# область в памяти на которую ссылается переменная - count_apple 

number = 42
# переменные называть по смыслу 

res = (count_apple + number)
print(res)

# слишком длинные переменные создавать не нужно 
----
Hello, world!
47
------

переменная - это именованная область памяти, которая может хранить некоторое значение

--
name = "Alice"  # Переменная 'name' хранит текст "Alice"
age = 25        # Переменная 'age' хранит число 25
----

определим некоторый список правил, как необходимо переменные именовать.

1. Именуйте переменные так, за что они отвечают. Если это имя, то название переменной будет name, а не n, anton и т.д. -
--
name = "Ivan"
----

2. Не используйте какие-то цифры, специальные символы и так далее, особенно в начале переменной

Если у Вас длинное название переменной, используйте 2 стиля на выбор, а именно - 

- snake_case — слова разделяются нижними подчеркиваниями, каждое слово пишется с маленькой буквы. Часто используется в Python: user_name, total_price 

- camelCase — первое слово пишется с маленькой буквы, а каждое последующее слово начинается с заглавной. Например, userName, totalPrice

Также не используйте в качестве названия переменных ключевые слова, они же служебные. Мы с ними далее познакомимся, но это слова по типу - class, if, for, return

По длине у названия переменных ограничений нет, но лучше использовать не длинные конструкции

Константа — это фиксированное значение, которое не изменяется в течение выполнения программы. В отличие от переменных, значение константы задается один раз и остается неизменным на протяжении всей работы программы.
Но их в Python нет - Поэтому используем следующую конструкцию.
Константы принято называть заглавными буквами, используя символ подчеркивания для разделения слов.
--
PI = 3.14159
MAX_USERS = 100
URL = "https://example.com"
----

Python не запрещает изменение значений констант, это просто конвенция. Вы можете изменить значение константы, но делать это не рекомендуется, так как это нарушает логику использования констант

************************************

3.2 - Типы данных и комментарии

--
count_apple = 5 
name = "Gleb"
pi = 3.14 
enabled = True 

# это комментарий 

'''
это 
тоже 
комментарий
'''

# проверить тип переменной - 
print(type(enabled))
----
<class 'bool'>
------

Рассмотрим примитивные типы данных -

- int (целые числа, он же integer): представляют собой числа без дробной части. Пример - 5, -10

- float (числа с плавающей запятой): представляют собой вещественные числа, то есть числа с дробной частью. Пример - 3.14, -0.001

- double (расширенная точность): в некоторых языках это тип для чисел с плавающей запятой повышенной точности. Пример: 3.1415926535

- bool (булевый тип, он же boolean): принимает два значения — True (истина) и False (ложь). Пример - is_valid = True

- string (строка): представляют собой последовательность символов. Пример: "Hello", "12345"

Но, что если мы хотим узнать тип данных, но выводить его в терминал не хотим? Для этого зажмите кнопку ctrl и наведите курсор на название любой переменной

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах -
--
import sys

x = 10
y = 3.14
z = "Hello, world!"

print("Размер переменной x (int):", sys.getsizeof(x), "байт")
print("Размер переменной y (float):", sys.getsizeof(y), "байт")
print("Размер переменной z (str):", sys.getsizeof(z), "байт")
----
Размер переменной x (int): 28 байт
Размер переменной y (float): 24 байт
Размер переменной z (str): 62 байт
------

Размер переменной типа int в Python зависит от значения числа. В CPython малые целые числа имеют базовый размер 28 байт, но этот размер увеличивается по мере роста числа, так как Python динамически увеличивает количество байт, чтобы вместить большие значения -
--
import sys

x = 1
y = 1000
z = 10**100  # Очень большое число

print("Размер переменной x (1):", sys.getsizeof(x), "байт")
print("Размер переменной y (1000):", sys.getsizeof(y), "байт")
print("Размер переменной z (10**100):", sys.getsizeof(z), "байт")
----
Размер переменной x (1): 28 байт
Размер переменной y (1000): 28 байт
Размер переменной z (10**100): 72 байт
------

Размер переменной типа float фиксирован и обычно составляет 24 байта (в CPython), так как они реализованы с использованием 64-битных чисел с плавающей запятой (double precision) -
--
import sys

f = 3.14
print("Размер переменной f (float):", sys.getsizeof(f), "байт")
----
Размер переменной f (float): 24 байт
------

Размер строки в Python зависит от её длины, так как каждая строка хранится как последовательность символов Unicode. Базовый размер строки — около 49 байт для пустой строки, затем добавляется по 1 байту за каждый символ в строке -
--
import sys

s1 = ""
s2 = "a"
s3 = "Hello, World!"

print("Размер пустой строки:", sys.getsizeof(s1), "байт")
print("Размер строки 'a':", sys.getsizeof(s2), "байт")
print("Размер строки 'Hello, World!':", sys.getsizeof(s3), "байт")
----
Размер пустой строки: 49 байт
Размер строки 'a': 50 байт
Размер строки 'Hello, World!': 62 байт
------

************************************

3.3 - Ввод и вывод информации 

--
age = 5 
name = 'Jon'
print(age, name)
----
5 Jon 
------

\n - перевод на новую строку 

input() - по умолчанию всегда str 

--
name = input('Enter your name:   ')
age = int(input('Enter age:   '))

print(name, str(age))
----

sep=' ,'

end='!'

************************************

3.4 - Операции с переменными 

--
a = 4 
b = 45 
print(a * b)

a = 56 
print(a)
----

+
-
*
**
/
//
%

f-строки - 
--
age = 45
name = 'Alex'

print(f'Hello {name} - {age} age')
----
Hello Alex - 45 age
------

приоритет арифметических операций - как и в математике 

нельзя складывать str с int или float 

int() — преобразует данные в целое число
float() — преобразует данные в число с плавающей запятой
str() — преобразует данные в строку
bool() — преобразует данные в булево значение (True или False)

************************************

4.1 - Условный оператор if/else

pep8 - 4 пробела или TAB 

--
number = 15

if (number > 0):
	print('number > 0')
elif (number < 0):
	print('number < 0')
else:
	print('number = 0')
----

операторы сравнения -
>
<
>=
<=
==
!= 

--
number = int(input("Enter number:   "))

if (number % 2 == 0):
	print(f'{number} - четное число')
else:
	print(f'{number} - нечетное число')
----

and - И
or  - ИЛИ
not - НЕ 

************************************

4.2 - Цикл for

цикл в C++ выглядит примерно так - 
--
for (i=0, i<5, i++):
	print(i)
----
- там синтаксис немного другой, но условия так прописываются 

--
for i in range(2, 11, 2):
	print(i)
----
- первое включительно, второе не включительно, третье это шаг 

левая граница диапазона всегда включается, а правая всегда не включается -
--
for i in range(10, 1, -1):
    print(i)
----
10
9
8
7
6
5
4
3
2
------

--
st = 'abcde' 

for i in st:
    print(i)
----
a
b
c
d
e
------

выведем все нечетные числа от 0 до 50 - 
--
for i in range(0, 51):
	if i % 2 != 0:
	    print(i)
----

************************************

4.3 - Цикл while 

for - заранее задает диапазон 
while - не задает диапазона, а прячет его под условием 

--
i = 1

while i <= 5:
    print(i)
	i += 1
----

--
check = True 

while check:
    age = int(input('Enter age:   '))
    if age == 18:
        print('Ok')
        check = False
----

continue - оператор продолжения (пропуска итерации)

break - оператор прерывания цикла 

pass - заглушка 

************************************

4.4 - Конструкция try/except (и осталось ещё 85 пунктов)

чаще всего try/except пользуются когда ошибка возникает и нам нужно её "простить" чтобы python её пропустил 

--
a = 5
b = 0
print(a/b)
print("Hello")
----
- будет ошибка и "Hello" напечатано не будет, и чтобы этого избежать можно предусмотреть ошибки -  

--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
----

--
try:
    age = int(input("Введите ваш возраст:   "))
    print(age)
except ValueError:
    print("Ошибка")
----

блоков except может быть несколько 

блок finally - выполняется всегда, в независимости от того, были ли ошибки или нет -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
except ValueError:
    print("Ошибка")
else:
    print(f'Результат {result}')
finally:
    print('Программа завершена')
----
- тут блок else выполняется в случае успеха try (то есть когда не обнаружено ошибок)

если у нас выскакивает ошибка которую мы в первый раз видим - мы можем её расшифровать -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except Exception as e:
    print(e)
----

try/except часто используется для открытия файлов (если файл открылся - то ОК, если не открылся - то не ОК)

пример использования try/except в цикле while для ввода числа - 
--
while True:
    try:
        num = int(input("Введите число (или 0 для выхода)"))
        if num == 0:
            break
        print(f'Вы ввели число {num}')
    except ValueError:
        print("Ошибка, введите корректное число")
----

Основные исключения, которые будут встречаться Вам чаще всего -
ValueError: Введено некорректное значение.
ZeroDivisionError: Попытка деления на ноль.
FileNotFoundError: Файл не найден.
TypeError: Неправильный тип данных для операции.

Блок try не может существовать без except или finally.

************************************

5.1 - Что такое изменяемые и неизменяемые типы данных?

Строки в Python — это последовательности символов, используемые для хранения и представления текстовой информации. В Python строки являются неизменяемыми (immutable), что означает, что после создания строки её содержимое нельзя изменить.

Неизменяемые типы данных (Immutable) -
Неизменяемые типы данных — это такие объекты, которые нельзя изменить после их создания. Любые операции, которые, кажется, изменяют значение, на самом деле создают новый объект.

Примеры неизменяемых типов данных:
Числа: int, float, complex
Логические значения: bool
Строки: str
Кортежи: tuple
Множества: frozenset
Изменяемые типы данных (Mutable) 

Изменяемые типы данных — это объекты, которые могут быть изменены после их создания. Операции с изменяемыми объектами могут менять их содержимое напрямую, не создавая новый объект.

Примеры изменяемых типов данных:
Списки: list
Словари: dict
Множества: set
Массивы (из библиотеки array)
Объекты пользовательских классов

что происходит со старыми объектами неизменяемых типов данных и можно ли получить к ним доступ?

Когда вы пытаетесь "изменить" значение неизменяемого объекта, Python создаёт новый объект с новым значением. Старый объект остаётся в памяти, но к нему можно получить доступ только через переменные, которые продолжают на него ссылаться. Например - 
--
s = "Hello"
s = s + " World"
----

Вначале переменная s ссылается на строку "Hello".
Когда вы делаете s + " World", создается новая строка, а переменная s теперь ссылается на новую строку "Hello World".
Старый объект "Hello" остаётся в памяти до тех пор, пока на него есть ссылки.
Если на старый объект больше нет ссылок (никакие переменные не указывают на него), Python в конечном итоге удалит его с помощью сборщика мусора. Этот механизм автоматически освобождает память, когда объекты больше не нужны.

************************************

5.2 А теперь про строки!

конкатенация (сложение, склеивание) строк - 
--
text1 = 'Hello'
text2 = "John"

print(text1 + ' ' + text2)
----
Hello John
------

индексы строк - [::]

умножение строк - 
--
text1 = 'Abcdefgh'

print(text1 * 3)
----
AbcdefghAbcdefghAbcdefgh
------

len() - считает количество символов - 
--
text1 = 'Abcdefgh'

print(len(text1))
----
8
------

************************************

5.3 - Методы строк 

text.upper()

text.lower()

text.capitalize() 

text.title() 

text.swapcase() 

text.strip() 

text.lstrip() 

text.rstrip() 

text.find('abc')
# возращает индекс первого входжения или -1 если нет вхождения 

--
text = "Hello, World"
print(text.index("World"))
----
7
------
- а тут если нет вхождения - вернет ошибку 

text.rfind('abc')
# возвращает индекс последнего(правого) вхождения или -1 

--
text = "banana"
print(text.count('a'))
----
3
------

--
text = "Hello, Python"
print(text.startswith("Hello"))
----
True 
------

--
text = "Hello, Python"
print(text.endswith("Python"))
----
True 
------

--
text = "yes my name John yes yes"
print(text.replace("yes", "no"))
print(text.replace("yes", ""))
----
no my name John no no
 my name John
------

--
text = "apple, banana, cherry"
fruits = text.split(",")
print(fruits)
----
['apple', ' banana', ' cherry']
------

--
text = "12345"
print(text.isdigit())
----
True 
------

--
text = "abc"
print(text.isalpha())
----
True 
------

--
text = "abc123"
print(text.isalnum())
----
True 
------

--
text = "     "
print(text.isspace())
----
True 
------

--
text = "hello"
print(text.islower())
----
True 
------

--
text = "HELLO"
print(text.isupper())
----
True 
------

--
text = "hello!123"
print(text.islower())

text = "HELLO!123"
print(text.isupper())
----
True 
True 
------
- но эти два метода проверяют только регистры букв 

--
text = "42"
print(text.zfill(5))
----
00042
------

--
text = "Python, Python"
print("Python" in text)
----
True 
------

************************************

5.4 - Форматирование строк

--
text = "Hello!"

print(text.center(10))
print(text.ljust(10))
print(text.rjust(10))
----
  Hello!  
Hello!    
    Hello!
------

--
name = "Bob"
age = 30 
greeting = "Привет, {}! Тебе {} лет.".format(name, age)
greeting1 = f"Привет, {name}! Тебе {age} лет."
print(greeting)
print(greeting1)
----
Привет, Bob! Тебе 30 лет.
Привет, Bob! Тебе 30 лет.
------

--
greeting3 = "Hello {n} you - {a}".format(n='Bob', a=30)
print(greeting3)
----
Hello Bob you - 30
------

--
num = 1234.56789
print(num)
print(f"Value - {num:.2f}")
----
1234.56789
Value - 1234.57
------

--
num = 42 
print("Number - {:05}".format(num))
----
Number - 00042
------

--
text = "Hello"

formatted_string = "|{:^10}|".format(text)  # Центрирование
print(formatted_string)

formatted_string = "|{:<10}|".format(text)  # Левое выравнивание
print(formatted_string)

formatted_string = "|{:>10}|".format(text)  # Правое выравнивание
print(formatted_string)
----
|  Hello   |
|Hello     |
|     Hello|
------

Для форматирования дат и времени используется метод strftime(). Это позволяет гибко настроить отображение дат и времени -
--
from datetime import datetime

now = datetime.now()

formatted_string = "Current date and time: {:%Y-%m-%d %H:%M:%S}".format(now)
print(formatted_string)
----
Current date and time: 2025-01-07 08:11:39
------

************************************

5.5 - Итоговое задание №1

--
import string


str = input("Введите строку: ")

spec = string.punctuation

for x in spec:
    str = str.replace(x, "")

str2 = list(str.split())

count_words = len(str2)
print(f"Количество слов: {count_words}")

sum_all_worlds = 0

for i in str2:
    sum_all_worlds += len(i)

print(f"Средняя длина слова: {sum_all_worlds / count_words}")
----
Введите строку: Hello, world! This is Python.
Количество слов: 5
Средняя длина слова: 4.4
------

************************************

6.1 - Введение в списки (list(), [])

на практике лучше не хранить в списке разные типы данных 

--
numbers = [1, 4, 2, 8, 5, 9]

words = ["aaa", "bbb", "ccc"]

print(numbers)
print(words)
print(numbers[1])
print(words[-1])
----
[1, 4, 2, 8, 5, 9]
['aaa', 'bbb', 'ccc']
4
ccc
------

--
numbers = [1, 4, 2, 8, 5, 9]

numbers[1] = 111
print(numbers)
----
[1, 111, 2, 8, 5, 9]
------

--
numbers = [1, 4, 2, 8, 5, 9]

numbers += [4]
numbers += [5, 6]

print(numbers)
----
[1, 4, 2, 8, 5, 9, 4, 5, 6]
------

удаление элемента из списка - 
--
num = [1, 2, 3]

del num[2]

print(num)
----
[1, 2]
------

for i in num: - это то же самое что и - 
--
num = [1, 2, 3]

for i in range(0, len(num)):
    print(num[i])
----
1
2
3
------

срезы в списках работают так же как и срезы в строках 

--
num = [1, 2, 3, 4, 5]
num[1:3] = [222, 333]
print(num)
----
[1, 222, 333, 4, 5]
------

сделать копию - 
--
num1 = [1, 2, 3]

num2 = num1[:]
num2[0] = 100

num3 = num1.copy()
num3[-1] = 300

print(num1)
print(num2)
print(num3)
----
[1, 2, 3]
[100, 2, 3]
[1, 2, 300]
------

вложенные списки - это когда внутри списка есть еще список или списки -
--
sp = [[1, 2, 3, 4], ['a', 'b', 'c', 'd']]

print(sp[0][1])
print(sp[1][1])
----
2
b 
------

Этап 1. Предварительное выделение памяти. 
Когда создается список, Python выделяет определенный блок памяти для хранения его элементов. При этом выделяется память с запасом, чтобы избежать частого перераспределения при добавлении новых элементов.
Например, если вы создаете список из 3 элементов, Python может выделить место для 4 или 6 элементов, чтобы в дальнейшем избежать копирования и перераспределения памяти при добавлении новых элементов.

Этап 2. Динамическое расширение.
Когда список заполняется (то есть количество элементов достигает выделенной памяти), Python выделяет новый блок памяти большего размера и копирует туда все элементы старого списка.
Обычно при каждом расширении размер списка увеличивается в 1.5–2 раза, что делает операцию добавления элементов к списку эффективной по времени.

Этап 3. Указатели.
Важно понимать, что список хранит указатели на объекты, а не сами объекты. Это значит, что элементы списка могут быть объектами любого типа, а сам список хранит ссылки на эти объекты.
Каждый элемент списка — это указатель на конкретный объект в памяти (например, числа, строки или другие объекты).
При добавлении новых элементов, когда текущая выделенная память заполняется, происходит реаллокация памяти — выделяется новый больший блок памяти, и указатели на старые элементы копируются в этот новый блок.

************************************

6.2 - Методы работы со списками

--
fruits = ["apple", "banana", "cherry"]

fruits.append("orange")

print(fruits)
----
['apple', 'banana', 'cherry', 'orange']
------

раздвижение списка - 
--
fruits = ["apple", "banana", "cherry"]

fruits.insert(1, "orange")

print(fruits)
----
['apple', 'orange', 'banana', 'cherry']
------

--
fruits = ["apple", "banana", "cherry"]

fruits.extend(["cherry", "orange"])

print(fruits)
----
['apple', 'banana', 'cherry', 'cherry', 'orange']
------

del - удаляет элемент по индексу, а remove - удаляет элемент по значению (слову) - 
--
fruits = ["apple", "banana", "cherry"]

fruits.remove("cherry")

print(fruits)
----
['apple', 'banana']
------
- но удаляет только одно (первое слева) значение, первое вхождение 

--
fruits = ["apple", "cherry", "banana", "cherry"]

del fruits[0]

print(fruits)
----
['cherry', 'banana', 'cherry']
------

метод pop работает быстрее чем оператор del - 
--
fruits = ["apple", "banana", "cherry"]

fruits.pop(1)

print(fruits)
----
['apple', 'cherry']
------
- и если не указывать индекс - удалит последнее значение, и может вернуть удаленное значение если присвоить его переменной -
--
fruits = ["apple", "cherry", "banana", "cherry"]

v = fruits.pop(1)

print(fruits)
print(v)
----
['apple', 'banana', 'cherry']
cherry
------

--
fruits = ["apple", "cherry", "banana", "cherry"]

fruits.clear()

print(fruits)
----
[]
------

index - возвращает индекс первого вхождения элемента в список - 
--
fruits = ["apple", "cherry", "banana", "cherry"]

f = fruits.index("cherry")

print(f)
----
1
------

--
fruits = ["apple", "cherry", "banana", "cherry"]

f = fruits.count("cherry")

print(f)
----
2
------

--
num = [10, 40, 20, 30, 200, 100]

num.sort()

print(num)
----
[10, 20, 30, 40, 100, 200]
------

--
num = [10, 40, 20, 30, 200, 100]

num.sort(reverse=True)

print(num)
----
[200, 100, 40, 30, 20, 10]
------

развернуть зеркально элементы списка - 
--
num = [10, 40, 20, 30, 200, 100]

num.reverse()

print(num)
----
[100, 200, 30, 20, 40, 10]
------

также развернуть зекрально элементы списка можно так - 
--
num = [10, 40, 20, 30, 200, 100]

f = num[::-1]

print(f)
----
[100, 200, 30, 20, 40, 10]
------

x.copy()

len(x)

все методы запоминать не нужно - они есть в документации 

--
sp1 = [1, 2, 3]
sp2 = sp1.copy() 
sp2.append(4)

print(sp1)
print(sp2)
----
[1, 2, 3]
[1, 2, 3, 4]
------

Метод copy используется для создания поверхностной копии списка. Поверхностная копия означает, что создается новый список, но все его элементы — это ссылки на те же объекты, что и в исходном списке. Таким образом, изменения в элементах будут видны в обоих списках, но изменения в структуре списка (например, добавление или удаление элементов) затронут только копию или оригинал.

Как работает copy?
Создание нового списка: Метод copy создает новый список. Этот список содержит ссылки на те же объекты, что и оригинальный список.
Поверхностная копия: При использовании copy объекты в списке не копируются. Это означает, что если элементы списка являются изменяемыми объектами (например, вложенные списки), изменения в этих объектах будут отражаться в обоих списках.
Не создается глубокая копия: Для создания глубоких копий, где копируются все вложенные объекты, нужно использовать функцию deepcopy из модуля copy. -
--
import copy 

original_list = [1, 2, [3, 4]] 

shallow_copy = original_list.copy() 
print(shallow_copy) # Вывод: [1, 2, [3, 4]] 

# Изменяем вложенный список в копии 
shallow_copy[2][0] = 'changed' 
print(original_list) # Вывод: [1, 2, ['changed', 4]] 
print(shallow_copy) # Вывод: [1, 2, ['changed', 4]]
----

Различие между поверхностной и глубокой копией
Поверхностная копия: Создается с помощью copy() и копирует только ссылки на объекты. Вложенные объекты не копируются, а просто ссылаются на те же объекты, что и в оригинале.
Глубокая копия: Создается с помощью deepcopy() из модуля copy. Этот метод создает новый объект и рекурсивно копирует все вложенные объекты. Изменения в глубокой копии не затрагивают оригинал и наоборот.
Пример использования deepcopy - 
--
import copy

original_list = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original_list)

print(deep_copy)  # Вывод: [1, 2, [3, 4]]

# Изменяем вложенный список в глубокой копии
deep_copy[2][0] = 'changed'

print(original_list)  # Вывод: [1, 2, [3, 4]]
print(deep_copy)      # Вывод: [1, 2, ['changed', 4]]
----
- здесь изменение в глубокой копии не влияет на оригинальный список, так как все вложенные объекты были также скопированы.

************************************

6.3 - Поэлементное взаимодействие со списками

--
my_list = [10, 20, 30, 40, 50] 
total_sum = 0 

for element in my_list: 
    total_sum += element 
print(f"Сумма всех элементов: {total_sum}")
----

Поиск максимального элемента в списке -
--
s = [1, 2, 3, 6, 7, 100, 1000, 200, 100, 2, 1]

max_v = s[0]

for i in s:
    if i > max_v:
	    max_v = i 
		
print(max_v)
----
1000
------

************************************

6.4 - Генерация списков (list comprehension)

--
numbers = []

for i in range(1, 6):
    numbers.append(i)
	
print(numbers)
----
- но это не генерация списка, генерация списка - это когда мы используем такой синтаксис - 
--
numbers = [i for i in range(1, 6)]

print(numbers)
----

--
numbers = [i**2 for i in range(1, 6) if i%2==0]

print(numbers)
----
[4, 16]
------

--
fruits = ['apple', 'banana', 'cherry']
up = [x.upper() for x in fruits]
print(up)
----
['APPLE', 'BANANA', 'CHERRY']
------

--
fruits = ['apple', 'banana', 'cherry']
dl = [len(x) for x in fruits]
print(dl)
----
[5, 6, 6]
------

генератор списка работает быстрее чем цикл for 

Генерация всех комбинаций из двух списков -
--
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
combinations = [(x, y) for x in list1 for y in list2]
print(combinations)
----
[(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
------

--
list = [i * 2 if i % 2 == 0 else i ** 3 for i in range(10)]
----

************************************

6.5 - Что такое кортежи?

картеж (tuple) - неизменяемый тип данных, но можно изменить структуры внутри картежа - 
--
t = (2, 3, [111, 111])
print(t)
t[2][0] = 222
print(t)
----
(2, 3, [111, 111])
(2, 3, [222, 111])
------

кортеж с одним значением - 
--
t = (1,)
----

t.count(3)

t.index(3)

print(t[0])

print(t[1:3])

--
t1 = (1, 2)
t2 = (3, 4)

print(t1 + t2)
----
(1, 2, 3, 4)
------

len(t)

--
my_list = [1, 2, 3]
my_tuple = tuple(my_list)
print(my_tuple)
print(type(my_tuple))
----
(1, 2, 3)
<class 'tuple'>
------

Кортеж без скобок (также допустимо) -
--
my_tuple2 = 1, 2, 3
----

************************************

7.1 - Что такое словарь и зачем он нужен, если есть списки?

Словарь (или dictionary) в Python — это изменяемая структура данных, которая хранит пары ключ-значение. В отличие от списков, которые используют числовые индексы для доступа к элементам, словари позволяют получать доступ к значениям по ключам, которые могут быть строками, числами или другими неизменяемыми типами данных.

Основные характеристики словарей:
- Неупорядоченные (до Python 3.7) и упорядоченные (начиная с Python 3.7): начиная с Python 3.7, словари сохраняют порядок добавления ключей, однако доступ к элементам осуществляется через ключи, а не индексы.
- Ключи уникальны: в словаре не может быть повторяющихся ключей, но значения могут дублироваться.
- Изменяемость: как и списки, словари можно изменять, добавляя, удаляя или изменяя пары ключ-значение.
- Быстрый доступ: доступ к элементам по ключу происходит быстрее, чем доступ к элементам списка по индексу (благодаря хеш-таблицам).

Словарь создается с использованием фигурных скобок {} или функции dict()

В словарях поиск по ключу выполняется быстрее, чем поиск по индексу в списке, благодаря использованию хеширования. Если у Вас большой набор данных, словарь позволяет более эффективно искать элементы.

когда что лучше использовать -  
- Списки лучше подходят для упорядоченных наборов данных, когда важен порядок элементов, и доступ осуществляется по индексу.
- Словари лучше подходят, когда данные имеют ассоциированные ключи, и вам нужно быстро находить значения по этим ключам.

************************************

7.2 - Методы работы со словарями

--
my_dict = {
    "apple": 3,
	"banana": 5,
	"cherry": 7
}

print(my_dict)

keys = my_dict.keys()
print(keys)
print(type(keys))

value = my_dict.values()
print(value)
print(type(value))

print(my_dict.items())

print(my_dict.get("apple", "не найдено"))

# обновить данные в словаре, добавить новые данные - 
my_dict.update({"apple": 333, "banana": 555, "kiwi": 888})
print(my_dict)

# удалить элемент словаря - 
x = my_dict.pop("kiwi")
print(x)   # 888
print(my_dict)

# удалить последнюю (правую) пару и вернуть пару ключ-значение - 
x = my_dict.popitem()
print(x)   # ('kiwi', 888)
print(my_dict)
----

d.clear()

len(d)

--
my_dict = {
    "apple": 3,
	"banana": 5,
	"cherry": 7
}

print(my_dict)
del my_dict["apple"]
print(my_dict)
----
{'apple': 3, 'banana': 5, 'cherry': 7}
{'banana': 5, 'cherry': 7}
------

словарь может содержать вложенные словари, списки и т.д. -
--
students = {
    "Alice": {"age": 25, "grade": 5},
    "Bob": {"age": 30, "grade": 10}
}

print(students)
print(students["Alice"]["age"])
----
{'Alice': {'age': 25, 'grade': 5}, 'Bob': {'age': 30, 'grade': 10}}
25
------

d.keys()

d.values()

d.items()

генератор словарей -
--
d = {x: x**2 for x in range(6)}

print(d)
----
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} 
------

Для удаления элементов из словаря можно использовать следующие методы - 
- pop(key) — удаляет элемент по ключу и возвращает его значение
- popitem() — удаляет и возвращает последнюю пару (ключ, значение)
- del dict[key] — удаляет элемент по ключу (без возврата значения)
- clear() — удаляет все элементы из словаря

Для получения значений по ключам используются следующие методы -
- dict[key] — получение значения по ключу (если ключ отсутствует, возникает ошибка)
- get(key, default) — получение значения по ключу, если ключ отсутствует, возвращается значение по умолчанию (None или указанное значение)

************************************

7.3 - Вложенные словари

Создание вложенного словаря -
--
company = {
    'department1': {
        'manager': 'Alice',
        'employees': 10,
        'location': 'Building A'
    },
    'department2': {
        'manager': 'Bob',
        'employees': 15,
        'location': 'Building B'
    }
}

# Добавление нового отдела в компанию
company['department3'] = {
    'manager': 'Charlie',
    'employees': 20,
    'location': 'Building C'
}
----

************************************

7.4 - Множества и методы множеств

множество - set() - неупорядоченная изменяемая коллекция уникальных элементов - соответственно индексы тут не работают, обращаться можно только по значениям 

--
my_set_1 = {1, 2, 3, 3}

my_set_2 = set([1, 2, 3, 3])

print(my_set_1)
print(my_set_2)
----
{1, 2, 3}
{1, 2, 3}
------

--
my_set = {1, 2, 3, 4, 5}

my_set.add(6)
print(my_set)
----
{1, 2, 3, 4, 5, 6}
------

--
my_set = {1, 2, 3, 4, 5}

my_set.remove(1)
print(my_set)
----
{2, 3, 4, 5}
------
- тут нужно использовать try-except так как если попробовать удалить элемент которого нет, то выйдет ошибка 

удаление элемента без вызова ошибки - 
--
my_set = {1, 2, 3, 4, 5}

my_set.discard(1)
print(my_set)
----
{2, 3, 4, 5}
------

s.pop() - удаляет и возвращает случайный элемент множества 

s.clear() - очищает множество 

объеденить 2 множества -
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.union(set2))
----
{1, 2, 3, 4, 5}
------

пересечение множеств (возьмет только те элементы которые есть и в одном и во втором множестве) -
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.intersection(set2))
----
{3}
------

разность множеств (выдасть элементы которые есть в первом множестве но нет во втором) - 
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.difference(set2))
----
{1, 2}
------

вывести элементы, которые есть в одном множестве но отсутствуют в другом (то есть все элементы которые не в пересечении множеств) - 
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.symmetric_difference(set2))
----
{1, 2, 4, 5}
------

входить ли первое множество полностью во второе - 
--
set1 = {1, 3, 2}
set2 = {5, 4, 3, 2, 1}

print(set1.issubset(set2))
----
True
------

входить ли второе множество полностью в первое - 
--
set1 = {1, 3, 2}
set2 = {2, 1}

print(set1.issuperset(set2))
----
True
------

frozenset - замороженное множество, оно не изменяется -
--
f = frozenset([1, 3, 5, 5, 5, 5])
print(f)
print(type(f))
----
frozenset({1, 3, 5})
<class 'frozenset'>
------

frozenset - часто используют как ключ для словаря, так как он неизменяемый 

Проверка на наличие элемента - 
in — проверяет, находится ли элемент в множестве -
--
my_set = {1, 2, 3}
print(2 in my_set)  # True
print(5 in my_set)  # False
----

************************************

7.5 - Круги Эйлера и операции над множествами

рассмотрим каждую из операций на простых примерах - 

- Пересечение (Intersection)
Операция пересечения возвращает множество элементов, которые одновременно принадлежат обоим множествам.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Тогда операция пересечения вернет {3,4}

- Объединение (Union)
Операция объединения возвращает множество всех уникальных элементов, которые принадлежат хотя бы одному из множеств.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция объединения вернет {1,2,3,4,5,6}
Здесь мы включаем все элементы из обоих множеств.

- Разность (Difference)
Операция разности возвращает множество элементов, которые принадлежат одному множеству, но не принадлежат другому.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция разности вернет {1,2}
Элементы 1 и 2 принадлежат множеству A, но не принадлежат множеству B.

- Дополнение (Complement)
Операция дополнения возвращает множество элементов, которые находятся в универсальном множестве U, но не принадлежат множеству A. Это, как правило, используется, когда определено универсальное множество всех возможных элементов.
Универсум (U) = {1, 2, 3, 4, 5, 6, 7, 8}
Множество A = {1, 2, 3, 4}
Тогда операция дополнения вернет {5,6,7,8}.
Элементы, которые не принадлежат множеству A, но принадлежат универсуму.

- Симметрическая разность (Symmetric Difference)
Симметрическая разность возвращает множество элементов, которые принадлежат только одному из множеств, но не обоим.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция симметрической разности вернет {1,2,5,6}
Элементы 1 и 2 принадлежат только множеству A, а элементы 5 и 6 принадлежат только множеству B.

Теперь тоже самое, только на Python и чуточку больше - 

- Объединение (Union)
Объединение множеств возвращает новое множество, содержащее все уникальные элементы обоих множеств.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2  # {1, 2, 3, 4, 5}
# Или
union_set = set1.union(set2)  # {1, 2, 3, 4, 5}
print(union_set)
----

- Пересечение (Intersection)
Пересечение множеств возвращает новое множество, содержащее только те элементы, которые есть в обоих множествах.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1 & set2  # {3}
# Или
intersection_set = set1.intersection(set2)  # {3}
print(intersection_set)
----

- Разность (Difference)
Разность множеств возвращает новое множество, содержащее элементы, которые есть в одном множестве, но отсутствуют в другом.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1 - set2  # {1, 2}
# Или
difference_set = set1.difference(set2)  # {1, 2}
print(difference_set)
----

- Симметрическая разность (Symmetric Difference)
Симметрическая разность возвращает новое множество, содержащее элементы, которые присутствуют только в одном из множеств, но не в обоих.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
sym_diff_set = set1 ^ set2  # {1, 2, 4, 5}
# Или
sym_diff_set = set1.symmetric_difference(set2)  # {1, 2, 4, 5}
print(sym_diff_set)
----

- Проверка подмножества (Subset)
Подмножество — это множество, все элементы которого содержатся в другом множестве. Проверка на подмножество возвращает True, если одно множество является подмножеством другого.
--
set1 = {1, 2}
set2 = {1, 2, 3, 4}
print(set1 <= set2)  # True
# Или
print(set1.issubset(set2))  # True
----

- Проверка надмножества (Superset)
Надмножество — это множество, которое содержит все элементы другого множества. Проверка на надмножество возвращает True, если одно множество является надмножеством другого.
--
set1 = {1, 2, 3, 4}
set2 = {1, 2}
print(set1 >= set2)  # True
# Или
print(set1.issuperset(set2))  # True
----

Проверка на пересечение (Disjoint)
Возвращает True, если два множества не имеют общих элементов
--
set1 = {1, 2, 3}
set2 = {4, 5, 6}
print(set1.isdisjoint(set2))  # True
----

************************************

7.6 - Frozenset

frozenset в Python — это неизменяемый (иммутабельный) вариант множества (set). В отличие от обычного множества, элементы в котором можно добавлять, удалять или изменять, элементы во frozenset после создания не могут быть изменены. Это делает его удобным для ситуаций, когда Вам нужно использовать множество как ключ в словаре или элемент множества (так как изменяемые объекты не могут быть ключами).

По особенностям, здесь все очень просто -
- После создания элементы нельзя изменять — нельзя добавлять или удалять элементы.
- Как и в обычных множествах, все элементы frozenset уникальны.
- Элементы не упорядочены, как и в обычных множествах, поэтому доступ по индексу невозможен.

Создается очень просто -
--
# Создание frozenset из списка
fset = frozenset([1, 2, 3, 4, 5])
print(fset)  # frozenset({1, 2, 3, 4, 5})

# Создание пустого frozenset
empty_fset = frozenset()
print(empty_fset)  # frozenset()
----

Несмотря на то, что frozenset неизменяем, его можно использовать для выполнения операций над множествами, таких как объединение, пересечение, разность и симметрическая разность:
--
fset1 = frozenset([1, 2, 3])
fset2 = frozenset([3, 4, 5])

# Объединение
print(fset1 | fset2)  # frozenset({1, 2, 3, 4, 5})

# Пересечение
print(fset1 & fset2)  # frozenset({3})

# Разность
print(fset1 - fset2)  # frozenset({1, 2})

# Симметрическая разность
print(fset1 ^ fset2)  # frozenset({1, 2, 4, 5})
----

Frozenset можно использовать, как ключ в словаре.
--
# Множество для примера
my_set = {1, 2, 3}
# Создаем frozenset
my_frozenset = frozenset([1, 2, 3, 4])

# Пример использования frozenset в качестве ключа в словаре
my_dict = {my_frozenset: "значение"}
print(my_dict[my_frozenset])  # Вывод: значение
----

************************************

8.1 - Что такое функция и зачем они нужны?

В информатике функция — это блок кода, который выполняет определённую задачу, принимает входные данные (аргументы) и возвращает результат. Функции позволяют разбивать программы на более мелкие, управляемые части, что делает код более структурированным и читаемым.

--
def greet():
    print("Hello, world!")
	
greet()
----
Hello, world!
------

еще про плюсы функций -
- Функции позволяют скрыть детали реализации и сосредоточиться на том, что функция делает, а не как
- Изменение кода в функции изменяет поведение программы сразу во всех местах, где эта функция используется, что облегчает поддержку и исправление ошибок

************************************

8.2 - Функции без параметров и с параметрами

Один раз написал - много раз используешь 

--
def greet(name, x, y):
    return f"Hello, {name} {x+y}"

a = "Alex"
b = 100
c = 50

f = greet(name=a, x=b, y=c)
print(f)
----
Hello, Alex 150
------

вызывать функцию можно и внутри других конструкций - while, if, for и т.д. 

если функция ничего не возвращает, но что-то делает (например print("Hello!")) то будет возвращаться None (ничего, пустота) -
--
def greet():
    print("Hello, world!")
	
result = greet()
print(result)
----
Hello, world!
None
------

параметр по умолчанию - 
--
def greet(name="Guest"):
    print(f"Hello, {name}")

a = "Alex"

greet()
greet(a)
----
Hello, Guest
Hello, Alex
------

есть 2 понятия - локальная и глобальная область видимости, представим, что функция - это капсула

Глобальная область видимости (Global Scope):
- Переменные, объявленные вне всех функций, являются глобальными.
- Глобальные переменные доступны для всех функций, однако функции не могут изменять их напрямую без специального указания (используя global).
--
x = 10  # Глобальная переменная

def my_func():
    print(x)  # Доступна глобальная переменная

my_func()
----
- то есть переменная была инициализированная до функции, в ней вполне может использоваться

Локальная область видимости (Local Scope):
- Переменные, объявленные внутри функции, являются локальными для этой функции и доступны только в ней.
- Локальные переменные создаются при вызове функции и уничтожаются после её завершения -
--
def my_func():
    y = 5  # Локальная переменная
    print(y)

my_func()
# print(y)  # Ошибка, так как y не доступна вне функции
----

Есть еще такое понятие, как вложенность функций -
--
def outer():
    z = 50  # Переменная в enclosing scope

    def inner():
        print(z)  # Доступ к enclosing переменной
    inner()

outer()
----
- Если одна функция объявлена внутри другой, то внутренняя функция имеет доступ к переменным внешней функции (но не глобальной области видимости напрямую)

************************************

8.3 - Возвращение результата из функции

Возвращение результата из функции — это процесс передачи значения или значений из функции обратно в ту часть программы, которая вызвала эту функцию. Это делается с помощью ключевого слова return. Когда функция выполняет return, она завершает своё выполнение и возвращает результат. После оператора return выполнение функции прекращается, и никакой код ниже него не выполняется.

Основные аспекты -
- Функция может возвращать одно значение.
- Функция может возвращать сразу несколько значений в виде кортежа.
- Когда встречается return, выполнение функции немедленно прекращается, даже если есть код ниже.
--
def square(num):
    return num ** 2  # Возвращаем квадрат числа

result = square(4)  # Записываем результат в переменную
print(result)  # Выведет: 16
----

также рассмотрим возвращение нескольких значений в качестве списка или переменных -
--
def get_even_numbers():
    return [2, 4, 6, 8, 10]  

result = get_even_numbers() 
print(result)  
----
[2, 4, 6, 8, 10]
------
- Функция get_even_numbers() возвращает список из пяти четных чисел

Либо вот такой пример -
--
def get_squares(numbers):
    squares = [num ** 2 for num in numbers]  
    return squares  # Возвращаем список квадратов

result = get_squares([1, 2, 3, 4, 5])  
print(result)
----
[1, 4, 9, 16, 25]
------

************************************

8.4 - Рекурсия

Рекурсия — это способ организации выполнения функций, при котором функция вызывает саму себя для решения подзадачи, которая является частью исходной задачи. Рекурсия широко применяется для решения задач, которые можно разделить на подобные, но меньшие подзадачи. Например, задачи, которые требуют поиска, перебора или разложения на части (разбор деревьев, графов и т.д.)

--
def factorial(n):
    if n == 0:  # базовый случай
        return 1
    else:
        return n * factorial(n - 1)  # рекурсивный вызов функции

print(factorial(5)) # Результат: 120
----

************************************

8.5 - Аннотация типов

Аннотация типов в Python — это механизм, который позволяет указать ожидаемые типы аргументов функций и возвращаемых значений. Это не строгая проверка типов, а всего лишь подсказка для разработчиков и инструментов, таких как IDE или статические анализаторы кода (например, mypy)

Аннотации делают код более понятным для других разработчиков и инструментов. Видно, какие типы данных ожидаются, что уменьшает вероятность ошибок и улучшает читаемость.

Читая функцию, невозможно заранее понять, какие типы данных ожидаются в аргументах и что она должна вернуть. Это может привести к путанице и ошибкам при использовании функции.

аннотации - это рекомендации для разработчиков 

--
def add(x, y):
    return x + y 
	
a = int(input())
b = int(input())
	
print(add(a, b))
----

--
def add(x: int, y: int) -> int:
    return x + y 
	
print(add(5, 4))
----
- будет писать предупреждения (подчеркивать желтым цветом), но функционал ограничивать не будет, то есть к примеру если будет передано str вместо int, то всё сработает - 
--
def add(x: int, y: int) -> int:
    return x + y 
	
print(add("12", "34"))
----
1234
------

--
def greet(name: str) -> str:
    return f"Hello, {name}"

print(greet(45))
print(type(greet(45)))
----
Hello, 45
<class 'str'>
------

--
from typing import List 


def sum_list(numbers: List[int]) -> int:
    return sum(numbers) 

result = sum_list([1, 2, 3, 4, 5])

print(result)
----

--
from typing import Dict 

def get_population(country: Dict[str, int]) -> int:
    return sum(country.values())
	
population = get_population({"Russia": 140_000_000, "USA": 330_000_000})

print(population)
----

--
from typing import Tuple 


def get_coord() -> Tuple[int, int]:
    return 10, 20

print(get_coord())
----
(10, 20)
------

явное указание типов переменных -
--
age: int = 30 
name: str = "Alex"
power: bool = False 
----

посмотреть что есть в модуле - 
--
from typing import Tuple 
----
- зажать CTRL и нажать мышкой на > typing

метод Optional - нужен когда аргумент может быть необязателен - 
--
from typing import Optional 


def greet(name: Optional[str] = None) -> str:
    if name is None:
        return "Hello, Guest!"
    else:
        return f"Hello, {name}"
		
print(greet())
print(greet("Alex"))
----
Hello, Guest!
Hello, Alex
------

mypy — это инструмент для статической проверки типов в Python. Он проверяет соответствие типов, указанных в аннотациях функций и переменных, и фактических типов, используемых в программе, без её запуска.

mypy анализирует код на наличие несоответствий между аннотированными типами и реальными типами данных, используемыми в программе. Если типы не совпадают, mypy выдаёт предупреждения или ошибки.

Чтобы установить mypy необходимо открыть PyCharm и открыть там терминал и ввести команду -
--
pip install mypy
----

терминале достаточно ввести mypy и название Вашего скрипта -
--
mypy main.py
----
- программа не запускается, а просто сопоставляются типы данных. Некий хороший тон для разработки программ, почему нет. Ну и все ошибки будут показываться во время разработки, а не во время работы программы

************************************

8.6 - *Args и **Kwargs

*args и **kwargs — это специальные параметры, которые используются в функциях Python для передачи произвольного количества аргументов

Когда мы используем *args в функции, это позволяет передавать любое количество позиционных аргументов (аргументы, которые передаются по порядку) -
--
def greet(*args):
    for name in args:
        print(f"Привет, {name}!")

greet("Аня", "Борис", "Света")
----
- Как бы это выглядело без args? Все очень просто и одновременно неудобно. Чтобы реализовать функцию без использования *args, нам нужно будет заранее определить фиксированное количество параметров. В этом случае функция сможет принимать только заранее заданное количество аргументов. Например, если мы хотим принимать ровно три имени (как в примере с "Аня", "Борис" и "Света"), код выглядел бы следующим образом:
--
def greet(name1, name2, name3):
    print(f"Привет, {name1}!")
    print(f"Привет, {name2}!")
    print(f"Привет, {name3}!")

greet("Аня", "Борис", "Света")
----
- Этот вариант жестко ограничен количеством аргументов, которое функция может принять. Если вы захотите передать больше имен, вам придется модифицировать определение функции и добавить дополнительные параметры

**kwargs позволяет передавать любое количество именованных аргументов (аргументы, которые передаются в виде ключ-значение) -
--
def describe_person(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

describe_person(name="Аня", age=25, city="Москва")
----

если убрать использование **kwargs, то нам нужно будет заранее задать конкретные именованные параметры для функции, что в свою очередь, ограничит количество и тип передаваемых аргументов, и они будут передаваться как обычные параметры функции -
--
def describe_person(name, age, city):
    print(f"name: {name}")
    print(f"age: {age}")
    print(f"city: {city}")

describe_person(name="Аня", age=25, city="Москва")
----
- Без использования **kwargs нет возможности передавать динамическое количество именованных аргументов, что делает функцию менее гибкой

Звездочки (* и **) у *args и **kwargs — это специальные синтаксические символы в Python, которые указывают на то, как будут интерпретироваться передаваемые в функцию аргументы.

*args — одна звездочка перед переменной означает, что эта переменная будет принимать произвольное количество позиционных аргументов и хранить их в виде кортежа.
--
def example(*args):   # (1, 2, 3)
    print(args)

example(1, 2, 3)
----

**kwargs — две звездочки перед переменной означают, что эта переменная будет принимать произвольное количество именованных аргументов (ключ-значение) и сохранять их в виде словаря.
--
def example(**kwargs):   # {'a': 1, 'b': 2, 'c': 3}
    print(kwargs)

example(a=1, b=2, c=3)
----

То есть -
- *args — для позиционных аргументов, результатом будет кортеж.
- **kwargs — для именованных аргументов, результатом будет словарь.

посмотрим на использование обычных параметров, args и kwargs в одной функции.
--
def example(param1, param2, *args, param3=100, **kwargs):
    print(f"param1: {param1}")
    print(f"param2: {param2}")
    print(f"args: {args}")
    print(f"param3: {param3}")
    print(f"kwargs: {kwargs}")

# Вызов функции
example(10, 20, 30, 40, param3=300, key1='value1', key2='value2')
----
param1: 10
param2: 20
args: (30, 40)
param3: 300
kwargs: {'key1': 'value1', 'key2': 'value2'}
------
- Обычные параметры param1 и param2 получают первые два позиционных аргумента: 10 и 20.
*args собирает оставшиеся позиционные аргументы: (30, 40).
param3 принимает значение по умолчанию, но в этом случае оно переопределено с помощью именованного аргумента: param3=300.
**kwargs собирает все именованные аргументы, которые не привязаны к параметрам функции, и хранит их в словаре: {'key1': 'value1', 'key2': 'value2'}.

************************************

8.7 - Декораторы, передача функции как параметра

Декораторы в Python — это функции, которые принимают другую функцию в качестве аргумента и возвращают новую функцию (или объект), тем самым модифицируя или оборачивая поведение исходной функции без изменения ее исходного кода. Они часто используются для добавления дополнительной логики к функциям, таких как логирование, валидация или контроль доступа.

В Python функции являются объектами первого класса. Это значит, что они могут передаваться как аргументы другим функциям, возвращаться из функций, храниться в переменных, и так далее

--
def execute_function(func):
    print("Выполняем функцию...")
    func()  # Вызов переданной функции

def say_hello():
    print("Привет!")

# Передаем функцию say_hello как параметр
execute_function(say_hello)
----
Выполняем функцию...
Привет!
------
- Здесь execute_function принимает другую функцию say_hello как аргумент и вызывает её. Это базовая идея декоратора

Декоратор — это "обёртка" вокруг функции. Представьте, что у Вас есть функция, которая что-то делает, и Вы хотите добавить к ней дополнительное действие, не изменяя её код. Вот тут на помощь приходит декоратор.

Декоратор — это такой "помощник", который добавляет что-то новое к функции. Например, Вы можете перед вызовом функции добавить вывод текста или проверку, а сама функция останется такой же.

Представьте, что Вы хотите каждый раз перед тем, как поприветствовать человека, сказать: "Подготовка к приветствию". Вот как это можно сделать с декоратором
--
def decorator(func):
    def wrapper():
        print("Подготовка к приветствию...")
        func()  # Здесь вызывается наша исходная функция
        print("Приветствие завершено.")
    return wrapper

@decorator
def say_hello():
    print("Привет!")

say_hello()
----
Подготовка к приветствию...
Привет!
Приветствие завершено.
------
decorator — это функция-декоратор, которая добавляет действия перед и после функции say_hello.
@decorator — это волшебная строчка, которая говорит: "Применить декоратор к функции say_hello".
Когда вызывается say_hello(), декоратор делает так, что сначала выводится текст "Подготовка к приветствию...", потом сама функция говорит "Привет!", а затем выводится "Приветствие завершено.

@decorator это то же, что и say_hello = decorator(say_hello)

создадим декоратор, который будет замерять время выполнения функции и выводить результат -
--
import time


def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  
		# Запоминаем время начала
        result = func(*args, **kwargs)  
		# Вызываем оригинальную функцию
        end_time = time.time()  
		# Запоминаем время окончания
        print(f"Функция {func.__name__} заняла {end_time - start_time:.4f} секунд.")
        return result  
		# Возвращаем результат работы функции
    return wrapper

@time_it
def slow_function():
    print("Функция начала работу...")
    time.sleep(2)  
	# Задержка на 2 секунды для имитации долгой работы
    print("Функция завершила работу.")

slow_function()
----
Функция начала работу...
Функция завершила работу.
Функция slow_function заняла 2.0129 секунд.
------
time_it — это декоратор, который замеряет время выполнения функции.
time.time() — используется для захвата текущего времени до и после выполнения функции. Разница между ними даст время выполнения.
wrapper(*args, **kwargs) — обёртка, которая передаёт аргументы в оригинальную функцию и возвращает результат её работы.
Декоратор выводит время выполнения функции в секундах с точностью до четырёх знаков после запятой.

@time_it то же, что и slow_function = time_it(slow_function)

************************************

8.8 - map(), filter(), reduce()

В Python функции map(), filter() и reduce() относятся к функциям высшего порядка (higher-order functions), так как они принимают в качестве аргументов другие функции и применяют их к элементам последовательностей (списков, кортежей и т.д.). Эти функции полезны для работы с коллекциями данных и позволяют делать код более лаконичным и функциональным.

map()
Функция map() применяется для того, чтобы применить функцию к каждому элементу последовательности (например, список) и вернуть новый объект-итератор с результатами
--
def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(square, numbers))

print(squared_numbers)  
----
[1, 4, 9, 16, 25]
------
- Здесь map() применяет функцию square к каждому элементу списка numbers

filter()
Функция filter() используется для фильтрации элементов последовательности на основе заданного условия (функции). Она возвращает только те элементы, для которых функция возвращает True -
--
def is_even(x):
    return x % 2 == 0

numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(is_even, numbers))

print(even_numbers)
----
[2, 4, 6]
------
- Здесь filter() возвращает только те числа, которые делятся на 2 без остатка

reduce() 
Функция reduce() применяется для того, чтобы свести (сжать) всю последовательность к одному значению, применяя функцию поэтапно к элементам. Она последовательно применяет функцию к парам элементов и возвращает одно итоговое значение -
--
from functools import reduce

def multiply(x, y):
    return x * y

numbers = [1, 2, 3, 4]
result = reduce(multiply, numbers)

print(result)
----
24
------

Функция reduce() работает следующим образом:
Она берёт первые два элемента списка и применяет к ним функцию multiply.
Затем результат применения функции к этим двум элементам используется вместе с третьим элементом списка в следующем вызове функции.
Процесс повторяется до тех пор, пока все элементы списка не будут обработаны и не останется одно итоговое значение.
Давай посмотрим, как это работает пошагово -
Шаг 1: multiply(1, 2) → возвращает 2.
Шаг 2: multiply(2, 3) → возвращает 6.
Шаг 3: multiply(6, 4) → возвращает 24.
В итоге перемножение всех чисел из списка [1, 2, 3, 4] даёт результат 24


































******************

DA itProgger - 
https://www.youtube.com/playlist?list=PLDyJYA6aTY1kcb2fIGFZ9064fi-u1sLyf

https://itproger.com/course/data-analytics

1 - 

NumPy 
Pandas
Matplotlib 
Seaborn 
Plotly

- аналитика данных - это изучение прошлого и настоящего 
- дата саенс - создание моделей машинного обучения для предсказания будущего 

2 -

00-20














docker -
https://www.youtube.com/watch?v=KWn3f3xJkCE

перейти в папку проекта -
cd papka_proecta 

npm init 

npm i express 

в папке проекта создать файл - 
--
Dockerfile 
--
FROM node:20.11.1

2-50



















БРАУЗЕРНЫЕ НОДЫ - Доход в крипте без вложений -
https://www.youtube.com/watch?v=ONteW4Z3v0w

cryptorank.io/price/nodepay 

тут нода - это расширение для браузера (версии для - ПК, android, ios)

поддерживают инфраструктуру сети 

11-11











































<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

xakep.ru - Иван Сараев - 4 статьи по python - 
https://xakep.ru/author/solprogram/

1 статья - 

переменные - 
int 
float 
str 
bool 
None 
list 
dict 
tuple 
set 
...

условный оператор - if - elif - elif - .... - else 

print()
input()

a.lower()
a.upper()

list - 
a = [1, 2, 3, 'a, 'b', 'Hello', True]

a.append() 

a.sort() 

срезы - [::]

циклы - 
for  
while 

range() -
--
for i in range(5):
    print(i)
----

Практическая задача: мониторим буфер обмена
А теперь от учебных примеров перейдем к чему-нибудь интересному! В кон­це концов, мы ведь изучаем программирование не просто из любопытства. Давай напишем программу, которая будет следить за тем, что происходит в буфере обмена.

Од­на из силь­ных сто­рон Python — это огромная база готовых модулей, которые мож­но брать и под­клю­чать к сво­им прог­раммам. Что­бы их уста­новить и исполь­зовать внут­ри сво­их прог­рамм, мож­но заюзать менед­жер пакетов под наз­вани­ем pip. Будем счи­тать, что pip у тебя уже уста­нов­лен.

Пер­вым делом ста­вим при помощи pip модуль, который отве­чает за работу с буфером обме­на. 

В Windows это будет вот такая коман­да:
pip install pyperclip

В Linux — слег­ка дру­гая:
pip3 install pyperclip

Пе­рехо­дим к кодиро­ванию. Наша прог­рамма будет монито­рить буфер обме­на и печатать на экра­не любой текст, который копиру­ет поль­зователь. Пояс­нения я дал в виде ком­мента­риев, они в Python отби­вают­ся зна­ком # в начале стро­ки.
--
# Подключим модуль для работы с буфером обмена
import pyperclip
# Подключим модуль для работы с системным временем
import time
# Задаем переменную old и присваиваем ей пустую строку
old = ''
# Начнем бесконечный цикл слежения за буфером обмена
while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()
    # Если полученное содержимое не равно предыдущему, то:
    if(s != old):
        # печатаем его
        print(s)
        # в переменную old записываем текущее пойманное значение
        # чтобы в следующий виток цикла не повторяться и не печатать то, что уже поймано
        old = s
    # В конце витка цикла делаем паузу в одну секунду, чтобы содержимое буфера обмена успело прогрузиться
    time.sleep(1)
----

Домашнее задание
Да­вай я дам тебе пароч­ку посиль­ных заданий на дом, что­бы ты мог поуп­ражнять­ся сам.
1
Сде­лай прог­рамму, которая вычис­ляет твой иде­аль­ный вес в зависи­мос­ти от рос­та и воз­раста. Най­ди соот­ветс­тву­ющую фор­мулу в поис­ковых сис­темах и реали­зуй усло­вие для рас­чета. Пиво пивом, а за здо­ровь­ем нуж­но сле­дить!
2
На­пиши прог­рамму, которая в цик­ле монито­рит буфер обме­на, пери­оди­чес­ки получая из него текст с помощью pyperclip.paste(), и, если видит, что кем‑то был ско­пиро­ван email, заменя­ет этот email дру­гим, заранее про­писан­ным в коде, помещая его в буфер обме­на коман­дой pyperclip.copy('coolhacker@xakep.ru').

1 -
--
rost = int(input('Введите ваш рост в см.:   '))
vozrast = int(input('Введите ваш возраст:   '))

res = 0
if vozrast >= 40:
    res = rost - 100
else:
    res = rost - 110

print(res)
----

2 -
--
import pyperclip
import time

while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()

    if '@' in s:
        pyperclip.copy('xxx@xxx.com')
        time.sleep(1)
----



2 статья - 

переб­рал сло­варь, что­бы заменить каж­дое из слов (key) на соот­ветс­тву­ющее зна­чение из сло­варя (slova[key]):
--
s = 'Все лето мы пили пиво. Вот как-то открываю дверь, а на пороге Чебурашка, весь такой пьяный-пьяный, и бутылка из кармана торчит.'

slova = {'пили':'читали', 'пиво':'книги', 'пьяный':'начитанный', 'бутылка':'энциклопедия'}


for key in slova:
    s = s.replace(key, slova[key])
print(s)
----

replace() удоб­но исполь­зовать, что­бы начис­то уда­лить какие‑то сло­ва из стро­ки. Для это­го будем заменять их пус­той стро­кой (если открыть и зак­рыть кавыч­ку, то получит­ся пус­тая стро­ка):
--
s = '''Я не люблю пить пиво.
Оно невкусное и неполезное!'''

s = s.replace('не','')
print(s)
----

Что­бы получить количес­тво сим­волов в стро­ке, исполь­зует­ся фун­кция len() -
--
s = 'Если очень вам неймется, код пишите как придется!'
n = len(s)
print(n)
----

от строк мож­но брать сре­зы как от мас­сивов, если ука­зать начало и конец подс­тро­ки в квад­ратных скоб­ках пос­ле перемен­ной. Позиция начина­ется с нуля.
--
s = 'Меня зовут Бонд, Джеймс Бонд'
a = s[11:15]
print('Фамилия: ' + a)
----

Пред­положим, тебе нуж­но най­ти в спис­ке стро­ки, которые начина­ются на https. Переби­раем их с помощью for, для каж­дой про­веря­ем, сов­пада­ют ли пер­вые пять зна­ков со стро­кой https, и если да, то выводим стро­ку -
--
values = ['httpsaaaaa', 'aaa', 'httpbbbb', 'httpsccccc', 'bbb']
zn = 'https' 

for i in values:
	if i[:5] == zn:
		print(i)

print('end')
----
httpsaaaaa
httpsccccc
end
------

подсчитать количество - 
--
n = lst.count('hello')
----

Иног­да в начале или в кон­це стро­ки могут быть лиш­ние про­белы или перено­сы строк. Давай уда­лим их спе­циаль­ной коман­дой .strip() -
--
s = ' Пива много не бывает!  \n'
s = s.strip()
print('***')
print(s)
print('***')
----
***
Пива много не бывает!
***
------

Пе­рено­сы строк мож­но добавить с помощью сим­волов \n (исполь­зует­ся во всех ОС) либо \r\n (в Windows). Есть и дру­гие спец­симво­лы. Нап­ример, \t — знак табуля­ции

Что­бы опре­делить наличие подс­тро­ки в стро­ке s, мож­но исполь­зовать метод .find() - 
--
n = s.find('строка, которую ищем')
----
- Ес­ли иско­мая подс­тро­ка най­дена, то в перемен­ную n попадет ее позиция в стро­ке, а если не най­дена, n ста­нет рав­ной -1.

поп­робу­ем опре­делить, есть ли в стро­ке адрес элек­трон­ной поч­ты с Xakep.ru, то есть будем искать подс­тро­ку @xakep.ru.

Но сна­чала нам понадо­бит­ся еще один стро­ковый метод — .split(). Он поз­воля­ет раз­делить стро­ку на час­ти, ука­зав в качес­тве аргу­мен­та стро­ку‑раз­делитель. Нап­ример, s.split('\n') раз­делит текст на абза­цы по сим­волу перено­са стро­ки. Если же оста­вить скоб­ки пус­тыми, то будет исполь­зован раз­делитель по умол­чанию — про­бел.
--
s = 'Это обычная строка, а в ней адрес почты vasya@xakep.ru'
words = s.split()
for w in words:
    n = w.find('@xakep.ru')
    if n != -1:
        print('Найден e-mail: ' + str(w) + ' в позиции ' + str(n))
----

Ме­тод .join() поз­воля­ет, наобо­рот, скле­ивать стро­ки. Он при­нима­ет спи­сок и воз­вра­щает стро­ку, где каж­дый эле­мент спис­ка соеди­нен с дру­гим через стро­ку, у которой ты выз­вал этот метод -
--
s = 'вирус внедряется '
list1 = ['раз, ', 'два, ', 'три...']
print(s + s.join(list1))
----
вирус внедряется раз, вирус внедряется два, вирус внедряется три...
------

lst.split()

'*'.join(lst)

метод .format() для форматирования строк - 
Мы можем вста­вить в стро­ку пар­ные фигур­ные скоб­ки, а затем выз­вать стро­ковый метод .format() и передать ему нуж­ные зна­чения в поряд­ке их под­ста­нов­ки в стро­ку.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(name, age, address)
print(info)
----

Мож­но передать информа­цию спис­ком через звез­дочку:
--
data = ['Вася Пупкин', 20, 'улица Пушкина, дом Колотушкина']
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(*data)
print(info)
----

Способ 2 — через f-строки -
Дру­гой вари­ант — написать бук­ву f перед стро­кой и затем в фигур­ных скоб­ках ука­зывать непос­редс­твен­но перемен­ные.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = f'Имя: {name.upper()}. Возраст: {age}. Адрес: {address}'
print(info)
----

Глав­ное пре­иму­щес­тво это­го спо­соба в том, что ты можешь вста­вить зна­чение в стро­ку нес­коль­ко раз. К тому же мож­но менять зна­чения пря­мо в фигур­ных скоб­ках: спер­ва Python выпол­нит все дей­ствия в них, а затем под­ста­вит получен­ный резуль­тат в стро­ку. Так, метод .upper() в при­мере выше дела­ет все бук­вы заг­лавны­ми

Что­бы работать с фай­лом, его нуж­но открыть. Для это­го слу­жит фун­кция open(), а работа­ет она вот так:
--
f = open('имя файла с путем и расширением', 'режим работы с файлом', encoding='Кодировка текста')
----

Ре­жимов работы с фай­лами нес­коль­ко, но тебя инте­ресу­ет в основном:

r — открыть файл для чте­ния из него информа­ции;
w — открыть файл для записи в него информа­ции (соз­дает новый файл);
a — открыть файл для дозапи­си информа­ции в конец фай­ла (дописы­вает информа­цию в конец сущес­тву­юще­го фай­ла);
a+ — дозапись и чте­ние.

Что­бы избе­жать проб­лем с путями в Windows, исполь­зуй в них двой­ной слеш \\, а так­же перед откры­вающей кавыч­кой пути фай­ла ставь бук­ву u, ука­зыва­ющую на то, что стро­ка в кодиров­ке Unicode:
--
f = open(u'D:\\test.txt', 'r', encoding='UTF-8')
----

Чи­тать стро­ки из фай­ла мож­но методом .read():
--
f = open('test.txt', 'r', encoding='UTF-8')
s = f.read()
print(s)
----

Как вари­ант — мож­но пос­ледова­тель­но читать из фай­ла отдель­ные стро­ки с помощью цик­ла for:
--
f = open('test.txt', 'r', encoding='UTF-8')
for x in f:
    print(x)
----

Пос­ле того как работа с фай­лом закон­чена, нуж­но зак­рыть его.
--
f.close()
----

















