ЭТИ КУРСЫ ТУТ - 

python - 
https://stepik.org/course/209150/promo

parsing - 
https://stepik.org/course/209546/promo

взял 07.12.2024 - 450 руб. + 285 руб. 

это Баданов - у него ранее покупал курс по DE



************************************
************************************
************************************

КУРС - Python Engineer с нуля до junior

************************************
************************************
************************************

Для возможности задавать вопросы преподавателям, а также состоять в группе единомышленников и одногруппников, можно вступить в чат по ссылке -
https://t.me/+lIvySxhZXGZhM2My

По ссылке можно и нужно отслеживать изменения курса -
https://t.me/stepik_hello_py

************************************

2.1 - Что такое программирование?

нужно только желаниие обучаться 

чат-боты, ИИ - изучение python не углубленно, а широко, и потом выбрать ту область которую захочешь 

нужен только один монитор 

в программировании сложно, но не очень - 
python + библиотеки к нему 

************************************

2.2 - Актуальность Python

+

************************************

2.3 - Что можно сделать на Python

+

************************************

2.4 - Что такое PEP 8 и почему это важно

PEP 8 (Python Enhancement Proposal 8) — это официальный стиль кодирования для языка программирования Python. Этот документ был предложен Гвидо ван Россумом, создателем Python, и Тимом Петерсом, одним из ключевых разработчиков языка, и описывает правила форматирования кода, которые помогают сделать код Python более читаемым и единообразным.

Основные положения PEP 8:

- Отступы: Использование четырёх пробелов для отступов. Это помогает поддерживать единообразие кода и делает его легко читаемым. Важно избегать смешивания пробелов и табуляций.

- Максимальная длина строки: Рекомендуется, чтобы строки кода не превышали 79 символов. Это облегчает чтение кода на экранах с небольшой шириной и помогает в многооконной работе.

- Пробелы в выражениях и операторах: PEP 8 описывает, где следует и не следует использовать пробелы в коде. Например, пробелы не используются внутри скобок, но должны быть вокруг операндов в выражениях.

- Именование переменных и функций: PEP 8 рекомендует использовать нижний регистр с подчеркиваниями (snake_case) для переменных и функций, а для классов — стиль CamelCase.

- Импорт модулей: Все импорты должны быть в начале файла, отдельно от остального кода. Импорты должны быть структурированы в определённом порядке: стандартные библиотеки, сторонние библиотеки, и затем модули самого проекта.

- Документирование: PEP 8 рекомендует использовать строки документации (docstrings) для описания назначения функций, классов и методов.



Почему PEP 8 важен:

1. Читаемость кода: Одной из главных целей PEP 8 является улучшение читаемости кода. Когда код написан в соответствии с единым стилем, его легче читать и понимать. Это особенно важно в командной разработке, где код пишет и поддерживает множество людей.

2. Поддержка и сопровождение кода: Когда код следует единым правилам форматирования, его проще поддерживать. Новым разработчикам легче подключиться к проекту и начать работу с существующим кодом, если он структурирован по понятным и общепринятым правилам.

3. Снижение ошибок: Следование PEP 8 может помочь снизить вероятность появления ошибок. Например, использование четырёх пробелов для отступов вместо табуляций помогает избежать проблем, связанных с различной интерпретацией отступов в разных текстовых редакторах.

4. Инструменты автоматической проверки: Существуют инструменты, такие как flake8, pylint и black, которые автоматически проверяют и форматируют код в соответствии с PEP 8. Использование этих инструментов помогает поддерживать качество кода на высоком уровне и следить за его соответствием общепринятым стандартам.

5. Профессионализм: Код, написанный в соответствии с PEP 8, демонстрирует профессиональный подход к программированию. Это показывает, что разработчик заботится о качестве своего кода и уважает работу других, следуя общим стандартам.


В Pycharm есть удобное сочетание клавиш Ctrl + alt + L для быстрого исправления

************************************

2.5 - Установка всего необходимого

Для начала перейдем по ссылке - https://www.jetbrains.com/pycharm/download/?section=mac
Далее на странице найдем версию Community Edition, она бесплатна.

У Вас проектов может не быть, если Вы раньше не работали с этой программой. Поэтому нажимаем на кнопку "New Project".

Далее конфигурируем проект. Введем название, выберем путь, где его сохранить. В Python Version можно указать любую версию Python и она скачается. Скачивайте больше 3.10.

Все, что слева находится  является корнем проекта. Папки внутри директории .venv и External Libraries являются служебными. Создадим первый скрипт, чтобы проверить, что все установилось корректно.

Для этого нажмем на название проекта, щелкнем правой кнопкой мыши, New, Python File.

Введем название нашего скрипта. У меня это будет main. Обязательно на английском.

Preferences - это настройки. 

************************************

3.1 - Переменные

все файлы python называются скриптами 

переменная - это определенная область памяти, на которую мы можем сослаться 

--
main.py 
--
print("Hello, world!")

count_apple = 5 
# область в памяти на которую ссылается переменная - count_apple 

number = 42
# переменные называть по смыслу 

res = (count_apple + number)
print(res)

# слишком длинные переменные создавать не нужно 
----
Hello, world!
47
------

переменная - это именованная область памяти, которая может хранить некоторое значение

--
name = "Alice"  # Переменная 'name' хранит текст "Alice"
age = 25        # Переменная 'age' хранит число 25
----

определим некоторый список правил, как необходимо переменные именовать.

1. Именуйте переменные так, за что они отвечают. Если это имя, то название переменной будет name, а не n, anton и т.д. -
--
name = "Ivan"
----

2. Не используйте какие-то цифры, специальные символы и так далее, особенно в начале переменной

Если у Вас длинное название переменной, используйте 2 стиля на выбор, а именно - 

- snake_case — слова разделяются нижними подчеркиваниями, каждое слово пишется с маленькой буквы. Часто используется в Python: user_name, total_price 

- camelCase — первое слово пишется с маленькой буквы, а каждое последующее слово начинается с заглавной. Например, userName, totalPrice

Также не используйте в качестве названия переменных ключевые слова, они же служебные. Мы с ними далее познакомимся, но это слова по типу - class, if, for, return

По длине у названия переменных ограничений нет, но лучше использовать не длинные конструкции

Константа — это фиксированное значение, которое не изменяется в течение выполнения программы. В отличие от переменных, значение константы задается один раз и остается неизменным на протяжении всей работы программы.
Но их в Python нет - Поэтому используем следующую конструкцию.
Константы принято называть заглавными буквами, используя символ подчеркивания для разделения слов.
--
PI = 3.14159
MAX_USERS = 100
URL = "https://example.com"
----

Python не запрещает изменение значений констант, это просто конвенция. Вы можете изменить значение константы, но делать это не рекомендуется, так как это нарушает логику использования констант

************************************

3.2 - Типы данных и комментарии

--
count_apple = 5 
name = "Gleb"
pi = 3.14 
enabled = True 

# это комментарий 

'''
это 
тоже 
комментарий
'''

# проверить тип переменной - 
print(type(enabled))
----
<class 'bool'>
------

Рассмотрим примитивные типы данных -

- int (целые числа, он же integer): представляют собой числа без дробной части. Пример - 5, -10

- float (числа с плавающей запятой): представляют собой вещественные числа, то есть числа с дробной частью. Пример - 3.14, -0.001

- double (расширенная точность): в некоторых языках это тип для чисел с плавающей запятой повышенной точности. Пример: 3.1415926535

- bool (булевый тип, он же boolean): принимает два значения — True (истина) и False (ложь). Пример - is_valid = True

- string (строка): представляют собой последовательность символов. Пример: "Hello", "12345"

Но, что если мы хотим узнать тип данных, но выводить его в терминал не хотим? Для этого зажмите кнопку ctrl и наведите курсор на название любой переменной

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах -
--
import sys

x = 10
y = 3.14
z = "Hello, world!"

print("Размер переменной x (int):", sys.getsizeof(x), "байт")
print("Размер переменной y (float):", sys.getsizeof(y), "байт")
print("Размер переменной z (str):", sys.getsizeof(z), "байт")
----
Размер переменной x (int): 28 байт
Размер переменной y (float): 24 байт
Размер переменной z (str): 62 байт
------

Размер переменной типа int в Python зависит от значения числа. В CPython малые целые числа имеют базовый размер 28 байт, но этот размер увеличивается по мере роста числа, так как Python динамически увеличивает количество байт, чтобы вместить большие значения -
--
import sys

x = 1
y = 1000
z = 10**100  # Очень большое число

print("Размер переменной x (1):", sys.getsizeof(x), "байт")
print("Размер переменной y (1000):", sys.getsizeof(y), "байт")
print("Размер переменной z (10**100):", sys.getsizeof(z), "байт")
----
Размер переменной x (1): 28 байт
Размер переменной y (1000): 28 байт
Размер переменной z (10**100): 72 байт
------

Размер переменной типа float фиксирован и обычно составляет 24 байта (в CPython), так как они реализованы с использованием 64-битных чисел с плавающей запятой (double precision) -
--
import sys

f = 3.14
print("Размер переменной f (float):", sys.getsizeof(f), "байт")
----
Размер переменной f (float): 24 байт
------

Размер строки в Python зависит от её длины, так как каждая строка хранится как последовательность символов Unicode. Базовый размер строки — около 49 байт для пустой строки, затем добавляется по 1 байту за каждый символ в строке -
--
import sys

s1 = ""
s2 = "a"
s3 = "Hello, World!"

print("Размер пустой строки:", sys.getsizeof(s1), "байт")
print("Размер строки 'a':", sys.getsizeof(s2), "байт")
print("Размер строки 'Hello, World!':", sys.getsizeof(s3), "байт")
----
Размер пустой строки: 49 байт
Размер строки 'a': 50 байт
Размер строки 'Hello, World!': 62 байт
------

************************************

3.3 - Ввод и вывод информации 

--
age = 5 
name = 'Jon'
print(age, name)
----
5 Jon 
------

\n - перевод на новую строку 

input() - по умолчанию всегда str 

--
name = input('Enter your name:   ')
age = int(input('Enter age:   '))

print(name, str(age))
----

sep=' ,'

end='!'

************************************

3.4 - Операции с переменными 

--
a = 4 
b = 45 
print(a * b)

a = 56 
print(a)
----

+
-
*
**
/
//
%

f-строки - 
--
age = 45
name = 'Alex'

print(f'Hello {name} - {age} age')
----
Hello Alex - 45 age
------

приоритет арифметических операций - как и в математике 

нельзя складывать str с int или float 

int() — преобразует данные в целое число
float() — преобразует данные в число с плавающей запятой
str() — преобразует данные в строку
bool() — преобразует данные в булево значение (True или False)

************************************

4.1 - Условный оператор if/else

pep8 - 4 пробела или TAB 

--
number = 15

if (number > 0):
	print('number > 0')
elif (number < 0):
	print('number < 0')
else:
	print('number = 0')
----

операторы сравнения -
>
<
>=
<=
==
!= 

--
number = int(input("Enter number:   "))

if (number % 2 == 0):
	print(f'{number} - четное число')
else:
	print(f'{number} - нечетное число')
----

and - И
or  - ИЛИ
not - НЕ 

************************************

4.2 - Цикл for

цикл в C++ выглядит примерно так - 
--
for (i=0, i<5, i++):
	print(i)
----
- там синтаксис немного другой, но условия так прописываются 

--
for i in range(2, 11, 2):
	print(i)
----
- первое включительно, второе не включительно, третье это шаг 

левая граница диапазона всегда включается, а правая всегда не включается -
--
for i in range(10, 1, -1):
    print(i)
----
10
9
8
7
6
5
4
3
2
------

--
st = 'abcde' 

for i in st:
    print(i)
----
a
b
c
d
e
------

выведем все нечетные числа от 0 до 50 - 
--
for i in range(0, 51):
	if i % 2 != 0:
	    print(i)
----

************************************

4.3 - Цикл while 

for - заранее задает диапазон 
while - не задает диапазона, а прячет его под условием 

--
i = 1

while i <= 5:
    print(i)
	i += 1
----

--
check = True 

while check:
    age = int(input('Enter age:   '))
    if age == 18:
        print('Ok')
        check = False
----

continue - оператор продолжения (пропуска итерации)

break - оператор прерывания цикла 

pass - заглушка 

************************************

4.4 - Конструкция try/except (и осталось ещё 85 пунктов)

чаще всего try/except пользуются когда ошибка возникает и нам нужно её "простить" чтобы python её пропустил 

--
a = 5
b = 0
print(a/b)
print("Hello")
----
- будет ошибка и "Hello" напечатано не будет, и чтобы этого избежать можно предусмотреть ошибки -  

--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
----

--
try:
    age = int(input("Введите ваш возраст:   "))
    print(age)
except ValueError:
    print("Ошибка")
----

блоков except может быть несколько 

блок finally - выполняется всегда, в независимости от того, были ли ошибки или нет -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
except ValueError:
    print("Ошибка")
else:
    print(f'Результат {result}')
finally:
    print('Программа завершена')
----
- тут блок else выполняется в случае успеха try (то есть когда не обнаружено ошибок)

если у нас выскакивает ошибка которую мы в первый раз видим - мы можем её расшифровать -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except Exception as e:
    print(e)
----

try/except часто используется для открытия файлов (если файл открылся - то ОК, если не открылся - то не ОК)

пример использования try/except в цикле while для ввода числа - 
--
while True:
    try:
        num = int(input("Введите число (или 0 для выхода)"))
        if num == 0:
            break
        print(f'Вы ввели число {num}')
    except ValueError:
        print("Ошибка, введите корректное число")
----

Основные исключения, которые будут встречаться Вам чаще всего -
ValueError: Введено некорректное значение.
ZeroDivisionError: Попытка деления на ноль.
FileNotFoundError: Файл не найден.
TypeError: Неправильный тип данных для операции.

Блок try не может существовать без except или finally.

************************************

5.1 - Что такое изменяемые и неизменяемые типы данных?

Строки в Python — это последовательности символов, используемые для хранения и представления текстовой информации. В Python строки являются неизменяемыми (immutable), что означает, что после создания строки её содержимое нельзя изменить.

Неизменяемые типы данных (Immutable) -
Неизменяемые типы данных — это такие объекты, которые нельзя изменить после их создания. Любые операции, которые, кажется, изменяют значение, на самом деле создают новый объект.

Примеры неизменяемых типов данных:
Числа: int, float, complex
Логические значения: bool
Строки: str
Кортежи: tuple
Множества: frozenset
Изменяемые типы данных (Mutable) 

Изменяемые типы данных — это объекты, которые могут быть изменены после их создания. Операции с изменяемыми объектами могут менять их содержимое напрямую, не создавая новый объект.

Примеры изменяемых типов данных:
Списки: list
Словари: dict
Множества: set
Массивы (из библиотеки array)
Объекты пользовательских классов

что происходит со старыми объектами неизменяемых типов данных и можно ли получить к ним доступ?

Когда вы пытаетесь "изменить" значение неизменяемого объекта, Python создаёт новый объект с новым значением. Старый объект остаётся в памяти, но к нему можно получить доступ только через переменные, которые продолжают на него ссылаться. Например - 
--
s = "Hello"
s = s + " World"
----

Вначале переменная s ссылается на строку "Hello".
Когда вы делаете s + " World", создается новая строка, а переменная s теперь ссылается на новую строку "Hello World".
Старый объект "Hello" остаётся в памяти до тех пор, пока на него есть ссылки.
Если на старый объект больше нет ссылок (никакие переменные не указывают на него), Python в конечном итоге удалит его с помощью сборщика мусора. Этот механизм автоматически освобождает память, когда объекты больше не нужны.

************************************

5.2 А теперь про строки!

конкатенация (сложение, склеивание) строк - 
--
text1 = 'Hello'
text2 = "John"

print(text1 + ' ' + text2)
----
Hello John
------

индексы строк - [::]

умножение строк - 
--
text1 = 'Abcdefgh'

print(text1 * 3)
----
AbcdefghAbcdefghAbcdefgh
------

len() - считает количество символов - 
--
text1 = 'Abcdefgh'

print(len(text1))
----
8
------

************************************

5.3 - Методы строк 

text.upper()

text.lower()

text.capitalize() 

text.title() 

text.swapcase() 

text.strip() 

text.lstrip() 

text.rstrip() 

text.find('abc')
# возращает индекс первого входжения или -1 если нет вхождения 

--
text = "Hello, World"
print(text.index("World"))
----
7
------
- а тут если нет вхождения - вернет ошибку 

text.rfind('abc')
# возвращает индекс последнего(правого) вхождения или -1 

--
text = "banana"
print(text.count('a'))
----
3
------

--
text = "Hello, Python"
print(text.startswith("Hello"))
----
True 
------

--
text = "Hello, Python"
print(text.endswith("Python"))
----
True 
------

--
text = "yes my name John yes yes"
print(text.replace("yes", "no"))
print(text.replace("yes", ""))
----
no my name John no no
 my name John
------

--
text = "apple, banana, cherry"
fruits = text.split(",")
print(fruits)
----
['apple', ' banana', ' cherry']
------

--
text = "12345"
print(text.isdigit())
----
True 
------

--
text = "abc"
print(text.isalpha())
----
True 
------

--
text = "abc123"
print(text.isalnum())
----
True 
------

--
text = "     "
print(text.isspace())
----
True 
------

--
text = "hello"
print(text.islower())
----
True 
------

--
text = "HELLO"
print(text.isupper())
----
True 
------

--
text = "hello!123"
print(text.islower())

text = "HELLO!123"
print(text.isupper())
----
True 
True 
------
- но эти два метода проверяют только регистры букв 

--
text = "42"
print(text.zfill(5))
----
00042
------

--
text = "Python, Python"
print("Python" in text)
----
True 
------

************************************

5.4 - Форматирование строк

--
text = "Hello!"

print(text.center(10))
print(text.ljust(10))
print(text.rjust(10))
----
  Hello!  
Hello!    
    Hello!
------

--
name = "Bob"
age = 30 
greeting = "Привет, {}! Тебе {} лет.".format(name, age)
greeting1 = f"Привет, {name}! Тебе {age} лет."
print(greeting)
print(greeting1)
----
Привет, Bob! Тебе 30 лет.
Привет, Bob! Тебе 30 лет.
------

--
greeting3 = "Hello {n} you - {a}".format(n='Bob', a=30)
print(greeting3)
----
Hello Bob you - 30
------

--
num = 1234.56789
print(num)
print(f"Value - {num:.2f}")
----
1234.56789
Value - 1234.57
------

--
num = 42 
print("Number - {:05}".format(num))
----
Number - 00042
------

--
text = "Hello"

formatted_string = "|{:^10}|".format(text)  # Центрирование
print(formatted_string)

formatted_string = "|{:<10}|".format(text)  # Левое выравнивание
print(formatted_string)

formatted_string = "|{:>10}|".format(text)  # Правое выравнивание
print(formatted_string)
----
|  Hello   |
|Hello     |
|     Hello|
------

Для форматирования дат и времени используется метод strftime(). Это позволяет гибко настроить отображение дат и времени -
--
from datetime import datetime

now = datetime.now()

formatted_string = "Current date and time: {:%Y-%m-%d %H:%M:%S}".format(now)
print(formatted_string)
----
Current date and time: 2025-01-07 08:11:39
------

************************************

5.5 - Итоговое задание №1

--
import string


str = input("Введите строку: ")

spec = string.punctuation

for x in spec:
    str = str.replace(x, "")

str2 = list(str.split())

count_words = len(str2)
print(f"Количество слов: {count_words}")

sum_all_worlds = 0

for i in str2:
    sum_all_worlds += len(i)

print(f"Средняя длина слова: {sum_all_worlds / count_words}")
----
Введите строку: Hello, world! This is Python.
Количество слов: 5
Средняя длина слова: 4.4
------

************************************

6.1 - Введение в списки (list(), [])

на практике лучше не хранить в списке разные типы данных 

--
numbers = [1, 4, 2, 8, 5, 9]

words = ["aaa", "bbb", "ccc"]

print(numbers)
print(words)
print(numbers[1])
print(words[-1])
----
[1, 4, 2, 8, 5, 9]
['aaa', 'bbb', 'ccc']
4
ccc
------

--
numbers = [1, 4, 2, 8, 5, 9]

numbers[1] = 111
print(numbers)
----
[1, 111, 2, 8, 5, 9]
------

--
numbers = [1, 4, 2, 8, 5, 9]

numbers += [4]
numbers += [5, 6]

print(numbers)
----
[1, 4, 2, 8, 5, 9, 4, 5, 6]
------

удаление элемента из списка - 
--
num = [1, 2, 3]

del num[2]

print(num)
----
[1, 2]
------

for i in num: - это то же самое что и - 
--
num = [1, 2, 3]

for i in range(0, len(num)):
    print(num[i])
----
1
2
3
------

срезы в списках работают так же как и срезы в строках 

--
num = [1, 2, 3, 4, 5]
num[1:3] = [222, 333]
print(num)
----
[1, 222, 333, 4, 5]
------

сделать копию - 
--
num1 = [1, 2, 3]

num2 = num1[:]
num2[0] = 100

num3 = num1.copy()
num3[-1] = 300

print(num1)
print(num2)
print(num3)
----
[1, 2, 3]
[100, 2, 3]
[1, 2, 300]
------

вложенные списки - это когда внутри списка есть еще список или списки -
--
sp = [[1, 2, 3, 4], ['a', 'b', 'c', 'd']]

print(sp[0][1])
print(sp[1][1])
----
2
b 
------

Этап 1. Предварительное выделение памяти. 
Когда создается список, Python выделяет определенный блок памяти для хранения его элементов. При этом выделяется память с запасом, чтобы избежать частого перераспределения при добавлении новых элементов.
Например, если вы создаете список из 3 элементов, Python может выделить место для 4 или 6 элементов, чтобы в дальнейшем избежать копирования и перераспределения памяти при добавлении новых элементов.

Этап 2. Динамическое расширение.
Когда список заполняется (то есть количество элементов достигает выделенной памяти), Python выделяет новый блок памяти большего размера и копирует туда все элементы старого списка.
Обычно при каждом расширении размер списка увеличивается в 1.5–2 раза, что делает операцию добавления элементов к списку эффективной по времени.

Этап 3. Указатели.
Важно понимать, что список хранит указатели на объекты, а не сами объекты. Это значит, что элементы списка могут быть объектами любого типа, а сам список хранит ссылки на эти объекты.
Каждый элемент списка — это указатель на конкретный объект в памяти (например, числа, строки или другие объекты).
При добавлении новых элементов, когда текущая выделенная память заполняется, происходит реаллокация памяти — выделяется новый больший блок памяти, и указатели на старые элементы копируются в этот новый блок.

************************************

6.2 - Методы работы со списками

--
fruits = ["apple", "banana", "cherry"]

fruits.append("orange")

print(fruits)
----
['apple', 'banana', 'cherry', 'orange']
------

раздвижение списка - 
--
fruits = ["apple", "banana", "cherry"]

fruits.insert(1, "orange")

print(fruits)
----
['apple', 'orange', 'banana', 'cherry']
------

--
fruits = ["apple", "banana", "cherry"]

fruits.extend(["cherry", "orange"])

print(fruits)
----
['apple', 'banana', 'cherry', 'cherry', 'orange']
------

del - удаляет элемент по индексу, а remove - удаляет элемент по значению (слову) - 
--
fruits = ["apple", "banana", "cherry"]

fruits.remove("cherry")

print(fruits)
----
['apple', 'banana']
------
- но удаляет только одно (первое слева) значение, первое вхождение 

--
fruits = ["apple", "cherry", "banana", "cherry"]

del fruits[0]

print(fruits)
----
['cherry', 'banana', 'cherry']
------

метод pop работает быстрее чем оператор del - 
--
fruits = ["apple", "banana", "cherry"]

fruits.pop(1)

print(fruits)
----
['apple', 'cherry']
------
- и если не указывать индекс - удалит последнее значение, и может вернуть удаленное значение если присвоить его переменной -
--
fruits = ["apple", "cherry", "banana", "cherry"]

v = fruits.pop(1)

print(fruits)
print(v)
----
['apple', 'banana', 'cherry']
cherry
------

--
fruits = ["apple", "cherry", "banana", "cherry"]

fruits.clear()

print(fruits)
----
[]
------

index - возвращает индекс первого вхождения элемента в список - 
--
fruits = ["apple", "cherry", "banana", "cherry"]

f = fruits.index("cherry")

print(f)
----
1
------

--
fruits = ["apple", "cherry", "banana", "cherry"]

f = fruits.count("cherry")

print(f)
----
2
------

--
num = [10, 40, 20, 30, 200, 100]

num.sort()

print(num)
----
[10, 20, 30, 40, 100, 200]
------

--
num = [10, 40, 20, 30, 200, 100]

num.sort(reverse=True)

print(num)
----
[200, 100, 40, 30, 20, 10]
------

развернуть зеркально элементы списка - 
--
num = [10, 40, 20, 30, 200, 100]

num.reverse()

print(num)
----
[100, 200, 30, 20, 40, 10]
------

также развернуть зекрально элементы списка можно так - 
--
num = [10, 40, 20, 30, 200, 100]

f = num[::-1]

print(f)
----
[100, 200, 30, 20, 40, 10]
------

x.copy()

len(x)

все методы запоминать не нужно - они есть в документации 

--
sp1 = [1, 2, 3]
sp2 = sp1.copy() 
sp2.append(4)

print(sp1)
print(sp2)
----
[1, 2, 3]
[1, 2, 3, 4]
------

Метод copy используется для создания поверхностной копии списка. Поверхностная копия означает, что создается новый список, но все его элементы — это ссылки на те же объекты, что и в исходном списке. Таким образом, изменения в элементах будут видны в обоих списках, но изменения в структуре списка (например, добавление или удаление элементов) затронут только копию или оригинал.

Как работает copy?
Создание нового списка: Метод copy создает новый список. Этот список содержит ссылки на те же объекты, что и оригинальный список.
Поверхностная копия: При использовании copy объекты в списке не копируются. Это означает, что если элементы списка являются изменяемыми объектами (например, вложенные списки), изменения в этих объектах будут отражаться в обоих списках.
Не создается глубокая копия: Для создания глубоких копий, где копируются все вложенные объекты, нужно использовать функцию deepcopy из модуля copy. -
--
import copy 

original_list = [1, 2, [3, 4]] 

shallow_copy = original_list.copy() 
print(shallow_copy) # Вывод: [1, 2, [3, 4]] 

# Изменяем вложенный список в копии 
shallow_copy[2][0] = 'changed' 
print(original_list) # Вывод: [1, 2, ['changed', 4]] 
print(shallow_copy) # Вывод: [1, 2, ['changed', 4]]
----

Различие между поверхностной и глубокой копией
Поверхностная копия: Создается с помощью copy() и копирует только ссылки на объекты. Вложенные объекты не копируются, а просто ссылаются на те же объекты, что и в оригинале.
Глубокая копия: Создается с помощью deepcopy() из модуля copy. Этот метод создает новый объект и рекурсивно копирует все вложенные объекты. Изменения в глубокой копии не затрагивают оригинал и наоборот.
Пример использования deepcopy - 
--
import copy

original_list = [1, 2, [3, 4]]
deep_copy = copy.deepcopy(original_list)

print(deep_copy)  # Вывод: [1, 2, [3, 4]]

# Изменяем вложенный список в глубокой копии
deep_copy[2][0] = 'changed'

print(original_list)  # Вывод: [1, 2, [3, 4]]
print(deep_copy)      # Вывод: [1, 2, ['changed', 4]]
----
- здесь изменение в глубокой копии не влияет на оригинальный список, так как все вложенные объекты были также скопированы.

************************************

6.3 - Поэлементное взаимодействие со списками

--
my_list = [10, 20, 30, 40, 50] 
total_sum = 0 

for element in my_list: 
    total_sum += element 
print(f"Сумма всех элементов: {total_sum}")
----

Поиск максимального элемента в списке -
--
s = [1, 2, 3, 6, 7, 100, 1000, 200, 100, 2, 1]

max_v = s[0]

for i in s:
    if i > max_v:
	    max_v = i 
		
print(max_v)
----
1000
------

************************************

6.4 - Генерация списков (list comprehension)

--
numbers = []

for i in range(1, 6):
    numbers.append(i)
	
print(numbers)
----
- но это не генерация списка, генерация списка - это когда мы используем такой синтаксис - 
--
numbers = [i for i in range(1, 6)]

print(numbers)
----

--
numbers = [i**2 for i in range(1, 6) if i%2==0]

print(numbers)
----
[4, 16]
------

--
fruits = ['apple', 'banana', 'cherry']
up = [x.upper() for x in fruits]
print(up)
----
['APPLE', 'BANANA', 'CHERRY']
------

--
fruits = ['apple', 'banana', 'cherry']
dl = [len(x) for x in fruits]
print(dl)
----
[5, 6, 6]
------

генератор списка работает быстрее чем цикл for 

Генерация всех комбинаций из двух списков -
--
list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
combinations = [(x, y) for x in list1 for y in list2]
print(combinations)
----
[(1, 'a'), (1, 'b'), (1, 'c'), (2, 'a'), (2, 'b'), (2, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
------

--
list = [i * 2 if i % 2 == 0 else i ** 3 for i in range(10)]
----

************************************

6.5 - Что такое кортежи?

картеж (tuple) - неизменяемый тип данных, но можно изменить структуры внутри картежа - 
--
t = (2, 3, [111, 111])
print(t)
t[2][0] = 222
print(t)
----
(2, 3, [111, 111])
(2, 3, [222, 111])
------

кортеж с одним значением - 
--
t = (1,)
----

t.count(3)

t.index(3)

print(t[0])

print(t[1:3])

--
t1 = (1, 2)
t2 = (3, 4)

print(t1 + t2)
----
(1, 2, 3, 4)
------

len(t)

--
my_list = [1, 2, 3]
my_tuple = tuple(my_list)
print(my_tuple)
print(type(my_tuple))
----
(1, 2, 3)
<class 'tuple'>
------

Кортеж без скобок (также допустимо) -
--
my_tuple2 = 1, 2, 3
----

************************************

7.1 - Что такое словарь и зачем он нужен, если есть списки?

Словарь (или dictionary) в Python — это изменяемая структура данных, которая хранит пары ключ-значение. В отличие от списков, которые используют числовые индексы для доступа к элементам, словари позволяют получать доступ к значениям по ключам, которые могут быть строками, числами или другими неизменяемыми типами данных.

Основные характеристики словарей:
- Неупорядоченные (до Python 3.7) и упорядоченные (начиная с Python 3.7): начиная с Python 3.7, словари сохраняют порядок добавления ключей, однако доступ к элементам осуществляется через ключи, а не индексы.
- Ключи уникальны: в словаре не может быть повторяющихся ключей, но значения могут дублироваться.
- Изменяемость: как и списки, словари можно изменять, добавляя, удаляя или изменяя пары ключ-значение.
- Быстрый доступ: доступ к элементам по ключу происходит быстрее, чем доступ к элементам списка по индексу (благодаря хеш-таблицам).

Словарь создается с использованием фигурных скобок {} или функции dict()

В словарях поиск по ключу выполняется быстрее, чем поиск по индексу в списке, благодаря использованию хеширования. Если у Вас большой набор данных, словарь позволяет более эффективно искать элементы.

когда что лучше использовать -  
- Списки лучше подходят для упорядоченных наборов данных, когда важен порядок элементов, и доступ осуществляется по индексу.
- Словари лучше подходят, когда данные имеют ассоциированные ключи, и вам нужно быстро находить значения по этим ключам.

************************************

7.2 - Методы работы со словарями

--
my_dict = {
    "apple": 3,
	"banana": 5,
	"cherry": 7
}

print(my_dict)

keys = my_dict.keys()
print(keys)
print(type(keys))

value = my_dict.values()
print(value)
print(type(value))

print(my_dict.items())

print(my_dict.get("apple", "не найдено"))

# обновить данные в словаре, добавить новые данные - 
my_dict.update({"apple": 333, "banana": 555, "kiwi": 888})
print(my_dict)

# удалить элемент словаря - 
x = my_dict.pop("kiwi")
print(x)   # 888
print(my_dict)

# удалить последнюю (правую) пару и вернуть пару ключ-значение - 
x = my_dict.popitem()
print(x)   # ('kiwi', 888)
print(my_dict)
----

d.clear()

len(d)

--
my_dict = {
    "apple": 3,
	"banana": 5,
	"cherry": 7
}

print(my_dict)
del my_dict["apple"]
print(my_dict)
----
{'apple': 3, 'banana': 5, 'cherry': 7}
{'banana': 5, 'cherry': 7}
------

словарь может содержать вложенные словари, списки и т.д. -
--
students = {
    "Alice": {"age": 25, "grade": 5},
    "Bob": {"age": 30, "grade": 10}
}

print(students)
print(students["Alice"]["age"])
----
{'Alice': {'age': 25, 'grade': 5}, 'Bob': {'age': 30, 'grade': 10}}
25
------

d.keys()

d.values()

d.items()

генератор словарей -
--
d = {x: x**2 for x in range(6)}

print(d)
----
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} 
------

Для удаления элементов из словаря можно использовать следующие методы - 
- pop(key) — удаляет элемент по ключу и возвращает его значение
- popitem() — удаляет и возвращает последнюю пару (ключ, значение)
- del dict[key] — удаляет элемент по ключу (без возврата значения)
- clear() — удаляет все элементы из словаря

Для получения значений по ключам используются следующие методы -
- dict[key] — получение значения по ключу (если ключ отсутствует, возникает ошибка)
- get(key, default) — получение значения по ключу, если ключ отсутствует, возвращается значение по умолчанию (None или указанное значение)

************************************

7.3 - Вложенные словари

Создание вложенного словаря -
--
company = {
    'department1': {
        'manager': 'Alice',
        'employees': 10,
        'location': 'Building A'
    },
    'department2': {
        'manager': 'Bob',
        'employees': 15,
        'location': 'Building B'
    }
}

# Добавление нового отдела в компанию
company['department3'] = {
    'manager': 'Charlie',
    'employees': 20,
    'location': 'Building C'
}
----

************************************

7.4 - Множества и методы множеств

множество - set() - неупорядоченная изменяемая коллекция уникальных элементов - соответственно индексы тут не работают, обращаться можно только по значениям 

--
my_set_1 = {1, 2, 3, 3}

my_set_2 = set([1, 2, 3, 3])

print(my_set_1)
print(my_set_2)
----
{1, 2, 3}
{1, 2, 3}
------

--
my_set = {1, 2, 3, 4, 5}

my_set.add(6)
print(my_set)
----
{1, 2, 3, 4, 5, 6}
------

--
my_set = {1, 2, 3, 4, 5}

my_set.remove(1)
print(my_set)
----
{2, 3, 4, 5}
------
- тут нужно использовать try-except так как если попробовать удалить элемент которого нет, то выйдет ошибка 

удаление элемента без вызова ошибки - 
--
my_set = {1, 2, 3, 4, 5}

my_set.discard(1)
print(my_set)
----
{2, 3, 4, 5}
------

s.pop() - удаляет и возвращает случайный элемент множества 

s.clear() - очищает множество 

объеденить 2 множества -
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.union(set2))
----
{1, 2, 3, 4, 5}
------

пересечение множеств (возьмет только те элементы которые есть и в одном и во втором множестве) -
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.intersection(set2))
----
{3}
------

разность множеств (выдасть элементы которые есть в первом множестве но нет во втором) - 
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.difference(set2))
----
{1, 2}
------

вывести элементы, которые есть в одном множестве но отсутствуют в другом (то есть все элементы которые не в пересечении множеств) - 
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}

print(set1.symmetric_difference(set2))
----
{1, 2, 4, 5}
------

входить ли первое множество полностью во второе - 
--
set1 = {1, 3, 2}
set2 = {5, 4, 3, 2, 1}

print(set1.issubset(set2))
----
True
------

входить ли второе множество полностью в первое - 
--
set1 = {1, 3, 2}
set2 = {2, 1}

print(set1.issuperset(set2))
----
True
------

frozenset - замороженное множество, оно не изменяется -
--
f = frozenset([1, 3, 5, 5, 5, 5])
print(f)
print(type(f))
----
frozenset({1, 3, 5})
<class 'frozenset'>
------

frozenset - часто используют как ключ для словаря, так как он неизменяемый 

Проверка на наличие элемента - 
in — проверяет, находится ли элемент в множестве -
--
my_set = {1, 2, 3}
print(2 in my_set)  # True
print(5 in my_set)  # False
----

************************************

7.5 - Круги Эйлера и операции над множествами

рассмотрим каждую из операций на простых примерах - 

- Пересечение (Intersection)
Операция пересечения возвращает множество элементов, которые одновременно принадлежат обоим множествам.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Тогда операция пересечения вернет {3,4}

- Объединение (Union)
Операция объединения возвращает множество всех уникальных элементов, которые принадлежат хотя бы одному из множеств.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция объединения вернет {1,2,3,4,5,6}
Здесь мы включаем все элементы из обоих множеств.

- Разность (Difference)
Операция разности возвращает множество элементов, которые принадлежат одному множеству, но не принадлежат другому.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция разности вернет {1,2}
Элементы 1 и 2 принадлежат множеству A, но не принадлежат множеству B.

- Дополнение (Complement)
Операция дополнения возвращает множество элементов, которые находятся в универсальном множестве U, но не принадлежат множеству A. Это, как правило, используется, когда определено универсальное множество всех возможных элементов.
Универсум (U) = {1, 2, 3, 4, 5, 6, 7, 8}
Множество A = {1, 2, 3, 4}
Тогда операция дополнения вернет {5,6,7,8}.
Элементы, которые не принадлежат множеству A, но принадлежат универсуму.

- Симметрическая разность (Symmetric Difference)
Симметрическая разность возвращает множество элементов, которые принадлежат только одному из множеств, но не обоим.
Множество A = {1, 2, 3, 4}
Множество B = {3, 4, 5, 6}
Операция симметрической разности вернет {1,2,5,6}
Элементы 1 и 2 принадлежат только множеству A, а элементы 5 и 6 принадлежат только множеству B.

Теперь тоже самое, только на Python и чуточку больше - 

- Объединение (Union)
Объединение множеств возвращает новое множество, содержащее все уникальные элементы обоих множеств.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2  # {1, 2, 3, 4, 5}
# Или
union_set = set1.union(set2)  # {1, 2, 3, 4, 5}
print(union_set)
----

- Пересечение (Intersection)
Пересечение множеств возвращает новое множество, содержащее только те элементы, которые есть в обоих множествах.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1 & set2  # {3}
# Или
intersection_set = set1.intersection(set2)  # {3}
print(intersection_set)
----

- Разность (Difference)
Разность множеств возвращает новое множество, содержащее элементы, которые есть в одном множестве, но отсутствуют в другом.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1 - set2  # {1, 2}
# Или
difference_set = set1.difference(set2)  # {1, 2}
print(difference_set)
----

- Симметрическая разность (Symmetric Difference)
Симметрическая разность возвращает новое множество, содержащее элементы, которые присутствуют только в одном из множеств, но не в обоих.
--
set1 = {1, 2, 3}
set2 = {3, 4, 5}
sym_diff_set = set1 ^ set2  # {1, 2, 4, 5}
# Или
sym_diff_set = set1.symmetric_difference(set2)  # {1, 2, 4, 5}
print(sym_diff_set)
----

- Проверка подмножества (Subset)
Подмножество — это множество, все элементы которого содержатся в другом множестве. Проверка на подмножество возвращает True, если одно множество является подмножеством другого.
--
set1 = {1, 2}
set2 = {1, 2, 3, 4}
print(set1 <= set2)  # True
# Или
print(set1.issubset(set2))  # True
----

- Проверка надмножества (Superset)
Надмножество — это множество, которое содержит все элементы другого множества. Проверка на надмножество возвращает True, если одно множество является надмножеством другого.
--
set1 = {1, 2, 3, 4}
set2 = {1, 2}
print(set1 >= set2)  # True
# Или
print(set1.issuperset(set2))  # True
----

Проверка на пересечение (Disjoint)
Возвращает True, если два множества не имеют общих элементов
--
set1 = {1, 2, 3}
set2 = {4, 5, 6}
print(set1.isdisjoint(set2))  # True
----

************************************

7.6 - Frozenset

frozenset в Python — это неизменяемый (иммутабельный) вариант множества (set). В отличие от обычного множества, элементы в котором можно добавлять, удалять или изменять, элементы во frozenset после создания не могут быть изменены. Это делает его удобным для ситуаций, когда Вам нужно использовать множество как ключ в словаре или элемент множества (так как изменяемые объекты не могут быть ключами).

По особенностям, здесь все очень просто -
- После создания элементы нельзя изменять — нельзя добавлять или удалять элементы.
- Как и в обычных множествах, все элементы frozenset уникальны.
- Элементы не упорядочены, как и в обычных множествах, поэтому доступ по индексу невозможен.

Создается очень просто -
--
# Создание frozenset из списка
fset = frozenset([1, 2, 3, 4, 5])
print(fset)  # frozenset({1, 2, 3, 4, 5})

# Создание пустого frozenset
empty_fset = frozenset()
print(empty_fset)  # frozenset()
----

Несмотря на то, что frozenset неизменяем, его можно использовать для выполнения операций над множествами, таких как объединение, пересечение, разность и симметрическая разность:
--
fset1 = frozenset([1, 2, 3])
fset2 = frozenset([3, 4, 5])

# Объединение
print(fset1 | fset2)  # frozenset({1, 2, 3, 4, 5})

# Пересечение
print(fset1 & fset2)  # frozenset({3})

# Разность
print(fset1 - fset2)  # frozenset({1, 2})

# Симметрическая разность
print(fset1 ^ fset2)  # frozenset({1, 2, 4, 5})
----

Frozenset можно использовать, как ключ в словаре.
--
# Множество для примера
my_set = {1, 2, 3}
# Создаем frozenset
my_frozenset = frozenset([1, 2, 3, 4])

# Пример использования frozenset в качестве ключа в словаре
my_dict = {my_frozenset: "значение"}
print(my_dict[my_frozenset])  # Вывод: значение
----

************************************

8.1 - Что такое функция и зачем они нужны?

В информатике функция — это блок кода, который выполняет определённую задачу, принимает входные данные (аргументы) и возвращает результат. Функции позволяют разбивать программы на более мелкие, управляемые части, что делает код более структурированным и читаемым.

--
def greet():
    print("Hello, world!")
	
greet()
----
Hello, world!
------

еще про плюсы функций -
- Функции позволяют скрыть детали реализации и сосредоточиться на том, что функция делает, а не как
- Изменение кода в функции изменяет поведение программы сразу во всех местах, где эта функция используется, что облегчает поддержку и исправление ошибок

************************************

8.2 - Функции без параметров и с параметрами

Один раз написал - много раз используешь 

--
def greet(name, x, y):
    return f"Hello, {name} {x+y}"

a = "Alex"
b = 100
c = 50

f = greet(name=a, x=b, y=c)
print(f)
----
Hello, Alex 150
------

вызывать функцию можно и внутри других конструкций - while, if, for и т.д. 

если функция ничего не возвращает, но что-то делает (например print("Hello!")) то будет возвращаться None (ничего, пустота) -
--
def greet():
    print("Hello, world!")
	
result = greet()
print(result)
----
Hello, world!
None
------

параметр по умолчанию - 
--
def greet(name="Guest"):
    print(f"Hello, {name}")

a = "Alex"

greet()
greet(a)
----
Hello, Guest
Hello, Alex
------

есть 2 понятия - локальная и глобальная область видимости, представим, что функция - это капсула

Глобальная область видимости (Global Scope):
- Переменные, объявленные вне всех функций, являются глобальными.
- Глобальные переменные доступны для всех функций, однако функции не могут изменять их напрямую без специального указания (используя global).
--
x = 10  # Глобальная переменная

def my_func():
    print(x)  # Доступна глобальная переменная

my_func()
----
- то есть переменная была инициализированная до функции, в ней вполне может использоваться

Локальная область видимости (Local Scope):
- Переменные, объявленные внутри функции, являются локальными для этой функции и доступны только в ней.
- Локальные переменные создаются при вызове функции и уничтожаются после её завершения -
--
def my_func():
    y = 5  # Локальная переменная
    print(y)

my_func()
# print(y)  # Ошибка, так как y не доступна вне функции
----

Есть еще такое понятие, как вложенность функций -
--
def outer():
    z = 50  # Переменная в enclosing scope

    def inner():
        print(z)  # Доступ к enclosing переменной
    inner()

outer()
----
- Если одна функция объявлена внутри другой, то внутренняя функция имеет доступ к переменным внешней функции (но не глобальной области видимости напрямую)

************************************

8.3 - Возвращение результата из функции

Возвращение результата из функции — это процесс передачи значения или значений из функции обратно в ту часть программы, которая вызвала эту функцию. Это делается с помощью ключевого слова return. Когда функция выполняет return, она завершает своё выполнение и возвращает результат. После оператора return выполнение функции прекращается, и никакой код ниже него не выполняется.

Основные аспекты -
- Функция может возвращать одно значение.
- Функция может возвращать сразу несколько значений в виде кортежа.
- Когда встречается return, выполнение функции немедленно прекращается, даже если есть код ниже.
--
def square(num):
    return num ** 2  # Возвращаем квадрат числа

result = square(4)  # Записываем результат в переменную
print(result)  # Выведет: 16
----

также рассмотрим возвращение нескольких значений в качестве списка или переменных -
--
def get_even_numbers():
    return [2, 4, 6, 8, 10]  

result = get_even_numbers() 
print(result)  
----
[2, 4, 6, 8, 10]
------
- Функция get_even_numbers() возвращает список из пяти четных чисел

Либо вот такой пример -
--
def get_squares(numbers):
    squares = [num ** 2 for num in numbers]  
    return squares  # Возвращаем список квадратов

result = get_squares([1, 2, 3, 4, 5])  
print(result)
----
[1, 4, 9, 16, 25]
------

************************************

8.4 - Рекурсия

Рекурсия — это способ организации выполнения функций, при котором функция вызывает саму себя для решения подзадачи, которая является частью исходной задачи. Рекурсия широко применяется для решения задач, которые можно разделить на подобные, но меньшие подзадачи. Например, задачи, которые требуют поиска, перебора или разложения на части (разбор деревьев, графов и т.д.)

--
def factorial(n):
    if n == 0:  # базовый случай
        return 1
    else:
        return n * factorial(n - 1)  # рекурсивный вызов функции

print(factorial(5)) # Результат: 120
----

************************************

8.5 - Аннотация типов

Аннотация типов в Python — это механизм, который позволяет указать ожидаемые типы аргументов функций и возвращаемых значений. Это не строгая проверка типов, а всего лишь подсказка для разработчиков и инструментов, таких как IDE или статические анализаторы кода (например, mypy)

Аннотации делают код более понятным для других разработчиков и инструментов. Видно, какие типы данных ожидаются, что уменьшает вероятность ошибок и улучшает читаемость.

Читая функцию, невозможно заранее понять, какие типы данных ожидаются в аргументах и что она должна вернуть. Это может привести к путанице и ошибкам при использовании функции.

аннотации - это рекомендации для разработчиков 

--
def add(x, y):
    return x + y 
	
a = int(input())
b = int(input())
	
print(add(a, b))
----

--
def add(x: int, y: int) -> int:
    return x + y 
	
print(add(5, 4))
----
- будет писать предупреждения (подчеркивать желтым цветом), но функционал ограничивать не будет, то есть к примеру если будет передано str вместо int, то всё сработает - 
--
def add(x: int, y: int) -> int:
    return x + y 
	
print(add("12", "34"))
----
1234
------

--
def greet(name: str) -> str:
    return f"Hello, {name}"

print(greet(45))
print(type(greet(45)))
----
Hello, 45
<class 'str'>
------

--
from typing import List 


def sum_list(numbers: List[int]) -> int:
    return sum(numbers) 

result = sum_list([1, 2, 3, 4, 5])

print(result)
----

--
from typing import Dict 

def get_population(country: Dict[str, int]) -> int:
    return sum(country.values())
	
population = get_population({"Russia": 140_000_000, "USA": 330_000_000})

print(population)
----

--
from typing import Tuple 


def get_coord() -> Tuple[int, int]:
    return 10, 20

print(get_coord())
----
(10, 20)
------

явное указание типов переменных -
--
age: int = 30 
name: str = "Alex"
power: bool = False 
----

посмотреть что есть в модуле - 
--
from typing import Tuple 
----
- зажать CTRL и нажать мышкой на > typing

метод Optional - нужен когда аргумент может быть необязателен - 
--
from typing import Optional 


def greet(name: Optional[str] = None) -> str:
    if name is None:
        return "Hello, Guest!"
    else:
        return f"Hello, {name}"
		
print(greet())
print(greet("Alex"))
----
Hello, Guest!
Hello, Alex
------

mypy — это инструмент для статической проверки типов в Python. Он проверяет соответствие типов, указанных в аннотациях функций и переменных, и фактических типов, используемых в программе, без её запуска.

mypy анализирует код на наличие несоответствий между аннотированными типами и реальными типами данных, используемыми в программе. Если типы не совпадают, mypy выдаёт предупреждения или ошибки.

Чтобы установить mypy необходимо открыть PyCharm и открыть там терминал и ввести команду -
--
pip install mypy
----

терминале достаточно ввести mypy и название Вашего скрипта -
--
mypy main.py
----
- программа не запускается, а просто сопоставляются типы данных. Некий хороший тон для разработки программ, почему нет. Ну и все ошибки будут показываться во время разработки, а не во время работы программы

************************************

8.6 - *Args и **Kwargs

*args и **kwargs — это специальные параметры, которые используются в функциях Python для передачи произвольного количества аргументов

Когда мы используем *args в функции, это позволяет передавать любое количество позиционных аргументов (аргументы, которые передаются по порядку) -
--
def greet(*args):
    for name in args:
        print(f"Привет, {name}!")

greet("Аня", "Борис", "Света")
----
- Как бы это выглядело без args? Все очень просто и одновременно неудобно. Чтобы реализовать функцию без использования *args, нам нужно будет заранее определить фиксированное количество параметров. В этом случае функция сможет принимать только заранее заданное количество аргументов. Например, если мы хотим принимать ровно три имени (как в примере с "Аня", "Борис" и "Света"), код выглядел бы следующим образом:
--
def greet(name1, name2, name3):
    print(f"Привет, {name1}!")
    print(f"Привет, {name2}!")
    print(f"Привет, {name3}!")

greet("Аня", "Борис", "Света")
----
- Этот вариант жестко ограничен количеством аргументов, которое функция может принять. Если вы захотите передать больше имен, вам придется модифицировать определение функции и добавить дополнительные параметры

**kwargs позволяет передавать любое количество именованных аргументов (аргументы, которые передаются в виде ключ-значение) -
--
def describe_person(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

describe_person(name="Аня", age=25, city="Москва")
----

если убрать использование **kwargs, то нам нужно будет заранее задать конкретные именованные параметры для функции, что в свою очередь, ограничит количество и тип передаваемых аргументов, и они будут передаваться как обычные параметры функции -
--
def describe_person(name, age, city):
    print(f"name: {name}")
    print(f"age: {age}")
    print(f"city: {city}")

describe_person(name="Аня", age=25, city="Москва")
----
- Без использования **kwargs нет возможности передавать динамическое количество именованных аргументов, что делает функцию менее гибкой

Звездочки (* и **) у *args и **kwargs — это специальные синтаксические символы в Python, которые указывают на то, как будут интерпретироваться передаваемые в функцию аргументы.

*args — одна звездочка перед переменной означает, что эта переменная будет принимать произвольное количество позиционных аргументов и хранить их в виде кортежа.
--
def example(*args):   # (1, 2, 3)
    print(args)

example(1, 2, 3)
----

**kwargs — две звездочки перед переменной означают, что эта переменная будет принимать произвольное количество именованных аргументов (ключ-значение) и сохранять их в виде словаря.
--
def example(**kwargs):   # {'a': 1, 'b': 2, 'c': 3}
    print(kwargs)

example(a=1, b=2, c=3)
----

То есть -
- *args — для позиционных аргументов, результатом будет кортеж.
- **kwargs — для именованных аргументов, результатом будет словарь.

посмотрим на использование обычных параметров, args и kwargs в одной функции.
--
def example(param1, param2, *args, param3=100, **kwargs):
    print(f"param1: {param1}")
    print(f"param2: {param2}")
    print(f"args: {args}")
    print(f"param3: {param3}")
    print(f"kwargs: {kwargs}")

# Вызов функции
example(10, 20, 30, 40, param3=300, key1='value1', key2='value2')
----
param1: 10
param2: 20
args: (30, 40)
param3: 300
kwargs: {'key1': 'value1', 'key2': 'value2'}
------
- Обычные параметры param1 и param2 получают первые два позиционных аргумента: 10 и 20.
*args собирает оставшиеся позиционные аргументы: (30, 40).
param3 принимает значение по умолчанию, но в этом случае оно переопределено с помощью именованного аргумента: param3=300.
**kwargs собирает все именованные аргументы, которые не привязаны к параметрам функции, и хранит их в словаре: {'key1': 'value1', 'key2': 'value2'}.

************************************

8.7 - Декораторы, передача функции как параметра

Декораторы в Python — это функции, которые принимают другую функцию в качестве аргумента и возвращают новую функцию (или объект), тем самым модифицируя или оборачивая поведение исходной функции без изменения ее исходного кода. Они часто используются для добавления дополнительной логики к функциям, таких как логирование, валидация или контроль доступа.

В Python функции являются объектами первого класса. Это значит, что они могут передаваться как аргументы другим функциям, возвращаться из функций, храниться в переменных, и так далее

--
def execute_function(func):
    print("Выполняем функцию...")
    func()  # Вызов переданной функции

def say_hello():
    print("Привет!")

# Передаем функцию say_hello как параметр
execute_function(say_hello)
----
Выполняем функцию...
Привет!
------
- Здесь execute_function принимает другую функцию say_hello как аргумент и вызывает её. Это базовая идея декоратора

Декоратор — это "обёртка" вокруг функции. Представьте, что у Вас есть функция, которая что-то делает, и Вы хотите добавить к ней дополнительное действие, не изменяя её код. Вот тут на помощь приходит декоратор.

Декоратор — это такой "помощник", который добавляет что-то новое к функции. Например, Вы можете перед вызовом функции добавить вывод текста или проверку, а сама функция останется такой же.

Представьте, что Вы хотите каждый раз перед тем, как поприветствовать человека, сказать: "Подготовка к приветствию". Вот как это можно сделать с декоратором
--
def decorator(func):
    def wrapper():
        print("Подготовка к приветствию...")
        func()  # Здесь вызывается наша исходная функция
        print("Приветствие завершено.")
    return wrapper

@decorator
def say_hello():
    print("Привет!")

say_hello()
----
Подготовка к приветствию...
Привет!
Приветствие завершено.
------
decorator — это функция-декоратор, которая добавляет действия перед и после функции say_hello.
@decorator — это волшебная строчка, которая говорит: "Применить декоратор к функции say_hello".
Когда вызывается say_hello(), декоратор делает так, что сначала выводится текст "Подготовка к приветствию...", потом сама функция говорит "Привет!", а затем выводится "Приветствие завершено.

@decorator это то же, что и say_hello = decorator(say_hello)

создадим декоратор, который будет замерять время выполнения функции и выводить результат -
--
import time


def time_it(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  
		# Запоминаем время начала
        result = func(*args, **kwargs)  
		# Вызываем оригинальную функцию
        end_time = time.time()  
		# Запоминаем время окончания
        print(f"Функция {func.__name__} заняла {end_time - start_time:.4f} секунд.")
        return result  
		# Возвращаем результат работы функции
    return wrapper

@time_it
def slow_function():
    print("Функция начала работу...")
    time.sleep(2)  
	# Задержка на 2 секунды для имитации долгой работы
    print("Функция завершила работу.")

slow_function()
----
Функция начала работу...
Функция завершила работу.
Функция slow_function заняла 2.0129 секунд.
------
time_it — это декоратор, который замеряет время выполнения функции.
time.time() — используется для захвата текущего времени до и после выполнения функции. Разница между ними даст время выполнения.
wrapper(*args, **kwargs) — обёртка, которая передаёт аргументы в оригинальную функцию и возвращает результат её работы.
Декоратор выводит время выполнения функции в секундах с точностью до четырёх знаков после запятой.

@time_it то же, что и slow_function = time_it(slow_function)

************************************

8.8 - map(), filter(), reduce()

В Python функции map(), filter() и reduce() относятся к функциям высшего порядка (higher-order functions), так как они принимают в качестве аргументов другие функции и применяют их к элементам последовательностей (списков, кортежей и т.д.). Эти функции полезны для работы с коллекциями данных и позволяют делать код более лаконичным и функциональным.

map()
Функция map() применяется для того, чтобы применить функцию к каждому элементу последовательности (например, список) и вернуть новый объект-итератор с результатами
--
def square(x):
    return x ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(square, numbers))

print(squared_numbers)  
----
[1, 4, 9, 16, 25]
------
- Здесь map() применяет функцию square к каждому элементу списка numbers

filter()
Функция filter() используется для фильтрации элементов последовательности на основе заданного условия (функции). Она возвращает только те элементы, для которых функция возвращает True -
--
def is_even(x):
    return x % 2 == 0

numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(is_even, numbers))

print(even_numbers)
----
[2, 4, 6]
------
- Здесь filter() возвращает только те числа, которые делятся на 2 без остатка

reduce() 
Функция reduce() применяется для того, чтобы свести (сжать) всю последовательность к одному значению, применяя функцию поэтапно к элементам. Она последовательно применяет функцию к парам элементов и возвращает одно итоговое значение -
--
from functools import reduce

def multiply(x, y):
    return x * y

numbers = [1, 2, 3, 4]
result = reduce(multiply, numbers)

print(result)
----
24
------

Функция reduce() работает следующим образом:
Она берёт первые два элемента списка и применяет к ним функцию multiply.
Затем результат применения функции к этим двум элементам используется вместе с третьим элементом списка в следующем вызове функции.
Процесс повторяется до тех пор, пока все элементы списка не будут обработаны и не останется одно итоговое значение.
Давай посмотрим, как это работает пошагово -
Шаг 1: multiply(1, 2) → возвращает 2.
Шаг 2: multiply(2, 3) → возвращает 6.
Шаг 3: multiply(6, 4) → возвращает 24.
В итоге перемножение всех чисел из списка [1, 2, 3, 4] даёт результат 24

************************************

8.9 - Lambda функции

Lambda-функции в Python — это компактные анонимные функции, которые создаются с помощью ключевого слова lambda. В отличие от обычных функций, которые определяются с помощью def, lambda-функции не имеют имени и могут содержать только одно выражение. Они полезны, когда нужно написать простую функцию, которую планируется использовать один раз или в коротком участке кода. Пришли они к нам, опять же, из функциональной парадигмы программирования, которую вежливо предоставляют нам Scala и Haskell.

Синтаксис следующий -
--
lambda аргументы: выражение
----

--
add = lambda x, y: x + y
print(add(2, 3))
----
5
------
- здесь lambda x, y: x + y — это функция, которая принимает два аргумента и возвращает их сумму. Она аналогична следующей функции, написанной с использованием def -
--
def add(x, y):
    return x + y
----

еще пример - 
--
numbers = [1, 2, 3, 4]
squared_numbers = list(map(lambda x: x ** 2, numbers))
print(squared_numbers)
----
[1, 4, 9, 16]
------

пример с filter -
--
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)
----
[2, 4, 6]
------
- Здесь lambda x: x % 2 == 0 фильтрует список, оставляя только чётные числа

пример с reduce -
--
from functools import reduce
numbers = [1, 2, 3, 4]
product = reduce(lambda x, y: x * y, numbers)
print(product)
----
24
------
- Lambda-функция lambda x, y: x * y перемножает все элементы списка.

Lambda-функции полезны для создания кратковременных функций, которые нужно использовать в одном месте, чтобы сделать код более компактным. Однако, если функция сложная и многократно используется, предпочтительнее использовать обычные функции, созданные с помощью def

************************************

8.10 - all(), any(), zip(), enumerate()

В Python функции all(), any(), zip(), и enumerate() — это встроенные функции, которые часто применяются для работы с итерациями, последовательностями и условиями. Они делают код более компактным и удобным для чтения

all() -
Функция all() проверяет, являются ли все элементы последовательности истинными (или не равными False). Она возвращает True, если все элементы истинны, и False, если хотя бы один элемент ложен.

--
numbers = [1, 2, 3, 4]
print(all(numbers))  
----
True
------
- все элементы ненулевые (истинные)

--
numbers_with_zero = [1, 0, 3]
print(all(numbers_with_zero))
----
False
------
- потому что 0 считается ложным значением

any() -
Функция any() проверяет, является ли хотя бы один элемент последовательности истинным. Она возвращает True, если хотя бы один элемент истинный, и False, если все элементы ложные.

--
numbers = [0, 0, 3]
print(any(numbers))
----
True
------
- потому что хотя бы один элемент (3) истинный

--
all_zeros = [0, 0, 0]
print(any(all_zeros))
----
False
------
- потому что все элементы ложные (0)

zip() - 
Функция zip() объединяет несколько последовательностей (списков, кортежей и т.д.) в кортежи, где каждый кортеж состоит из элементов, взятых по одному из каждой последовательности. 

--
names = ["Alice", "Bob", "Charlie"]
scores = [85, 90, 95]

zipped = zip(names, scores)
print(list(zipped))
----
[('Alice', 85), ('Bob', 90), ('Charlie', 95)]
------
Если длины последовательностей разные, zip() остановится, когда достигнет конца самой короткой последовательности.

enumerate() -
Функция enumerate() позволяет пронумеровать элементы последовательности и возвращает пары, состоящие из индекса и самого элемента. Это удобно, если нужно знать как индекс, так и значение элемента в цикле.
--
names = ["Alice", "Bob", "Charlie"]

for index, name in enumerate(names, start=1):
    print(index, name)
----
1 Alice
2 Bob
3 Charlie
------

************************************

8.11 - Итоговое задание 3 - 
--
def f_even(ls: list) -> list:
    res = []
    for i in ls:
        if i % 2 == 0:
            res.append(i)
    if res:
        return res
    else:
        return "Четные числа отсутствуют"


def f_sum_avg(ls: list) -> list:
    if ls:
        res = []
        summ = sum(ls)
        avgg = summ / len(ls)
        res.append(summ)
        res.append(avgg)
        return res
    else:
        pass


list_1 = input("Введите числа через пробел: ").split()
list_2 = [int(x) for x in list_1]

res1 = f_even(list_2)
print(f"Четные числа: {res1}")

if type(res1) != str:
    res2_summ = f_sum_avg(res1)[0]
    print(f"Сумма четных чисел: {res2_summ}")
    res3_avg = f_sum_avg(res1)[1]
    print(f"Среднее значение четных чисел: {res3_avg}")
----
- тип возвращаемого значения функции может быть и строка:
--
from typing import Union
def f_even(ls: list) -> Union[list, str]: 
    res = []
    for i in ls:
        if i % 2 == 0:
            res.append(i)
    if res:
        return res
    else:
        return "Четные числа отсутствуют"
----

************************************

9.1 - Что такое пакеты и модули?

Модуль — это файл с расширением .py, который содержит код на Python (функции, классы, переменные, и т.д.). Модули позволяют разделять код на небольшие, логически связанные части, что упрощает его повторное использование.

Как использовать модуль:
Модуль можно импортировать в другой файл с помощью оператора import.
После импорта можно использовать функции, классы или переменные, определенные в модуле.
Пример создания и использования модуля:

Создаем файл my_module.py с таким содержимым -
--
my_module.py
--
def greet(name):
    return f"Hello, {name}!"
----

Импортируем и используем модуль в другом файле -
--
main.py
--
import my_module

print(my_module.greet("Alice"))
----

Пакет в Python — это способ организации и структурирования кода, который состоит из нескольких модулей. Пакет — это каталог (папка), содержащий один или несколько модулей (файлы с расширением .py) и специальный файл __init__.py, который делает эту папку пакетом.

Пакеты позволяют лучше организовывать код, особенно в больших проектах, обеспечивая логическое разделение функциональности на различные модули. Это также позволяет избежать конфликтов имен и упрощает импорт модулей.

Рассмотрим следующую структуру -
--
mypackage/          # Папка пакета
    __init__.py     # Указывает, что это пакет
    module1.py      # Модуль 1
    module2.py      # Модуль 2
----
- mypackage — это основной пакет.
- module1.py и module2.py — это модули, содержащие функции или классы, связанные с функциональностью пакета.
- __init__.py — файл, который инициализирует пакет и позволяет импортировать его как пакет. Он может быть пустым или содержать код для настройки или объявления доступных компонентов пакета.

Содержание module1 -
--
# module1.py
def func1():
    print("This is function 1 from module 1")
----

Содержание module2 -
--
# module2.py
def func2():
    print("This is function 2 from module 2")
----

В файле __init__.py пакета можно импортировать функции, чтобы их можно было импортировать напрямую -
--
# __init__.py
from .module1 import func1
from .module2 import func2
----

А теперь создадим вообще другой py файл. Но в поддиректории проекта, но не в папке mypackage. Я его назвал main.py -
--
main.py
--
from mypackage import func1, func2 

func1
func2 
----

Думаю разницу улавливаете?

- Модуль — это отдельный файл с кодом Python, который может быть импортирован и использован в других файлах.
- Пакет — это коллекция модулей, сгруппированных в одной папке, что позволяет структурировать сложные проекты.

Пакет - это целая библиотека с набором папок, подпапок и модулей в них.

************************************

9.2 - Псевдонимы

Псевдонимы (или алиасы) в Python — это альтернативные имена, которые можно присвоить модулям, функциям, или переменным при их импорте или использовании. Это помогает сократить или упростить код, особенно при работе с длинными или часто используемыми именами модулей или функций.

Иногда имена модулей могут быть длинными, и для удобства их можно переименовать в более короткие псевдонимы. Это делается с помощью ключевого слова as.
--
import numpy as np  
# 'numpy' теперь можно использовать как 'np'

import pandas as pd  
# 'pandas' теперь можно использовать как 'pd'
----

Теперь вместо использования полного имени модуля numpy или pandas, вы можете использовать псевдонимы np и pd -
--
array = np.array([1, 2, 3])
dataframe = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
----

Опять же, речь про модули, поэтому то, что делает код понимать пока что не нужно.

Псевдонимы можно применять не только к модулям, но и к отдельным функциям или классам. Например, вы можете импортировать только одну функцию из модуля и дать ей новое имя.
--
from math import sqrt as square_root

result = square_root(16)  
# Используем псевдоним 'square_root' вместо 'sqrt'

print(result)  
# Output: 4.0
----

А также можем избегать конфликтов, если имена функций совпадают.
--
def my_func():
    print("This is a local function.")

# Импортируем модуль с псевдонимом, чтобы избежать конфликта с локальной функцией -
import my_module as mm

my_func()  
# Локальная функция

mm.my_func()  
# Функция из модуля 'my_module'
----

************************************

10.1 - Псевдослучайные числа

Псевдослучайные числа — это числа, которые выглядят случайными, но на самом деле генерируются определённым алгоритмом, следовательно, они не являются полностью случайными. Эти числа получаются на основе детерминированных алгоритмов, что означает, что при одинаковом начальном условии последовательность псевдослучайных чисел будет всегда одинаковой.

Что говорит нам о том, что случайности не случайны.
- Псевдослучайные числа генерируются на основе определённых математических алгоритмов, что означает, что они повторяются при одинаковых условиях.
- Алгоритм генерации псевдослучайных чисел обычно принимает начальное значение, которое определяет последовательность чисел. При одинаковом значении seed алгоритм всегда будет выдавать одну и ту же последовательность.
- Псевдослучайные числа используются в ситуациях, где не требуется абсолютная случайность (например, в компьютерных симуляциях, играх, шифровании, статистике и моделировании).

Библиотеку random устанавливать не нужно. random — это встроенный модуль Python, который используется для работы с псевдослучайными числами. Этот модуль предоставляет функции для генерации случайных чисел, перемешивания последовательностей, выбора случайных элементов и других операций, связанных со случайностью
--
import random

# Установка начального значения (seed)
random.seed(42)

# Генерация псевдослучайного числа
print(random.randint(1, 100))  
# Всегда будет одинаковое значение при одинаковом seed
----
- Сколько раз бы мы не запускали эту программу - всегда будет число 82

- Истинно случайные числа — это числа, которые действительно случайны, и они не могут быть воспроизведены с использованием алгоритмов. Такие числа можно получить из физически случайных процессов (например, шум в электронных системах).
- Псевдослучайные числа — это результат вычислений и повторяемы при известных начальных условиях.

Истинная случайность основывается на природных процессах, которые по своей сути не поддаются детерминированному предсказанию. Например, в квантовой механике есть процессы, результаты которых случайны и не могут быть определены заранее. Истинно случайные числа важны в таких областях, как:
- Криптография, где требуется высокая степень случайности для генерации ключей.
- Лотереи и азартные игры, где нужно избежать предсказуемости.
- Научные эксперименты, где важна непредсказуемость данных.

Так что все числа, которые мы с вами "генерим" не являются истинными случайностями, а являются алгоритмом, который просто очень хорошо отрабатывает.

Функция random.seed() в Python используется для инициализации генератора псевдослучайных чисел, что позволяет воспроизводить одинаковые последовательности случайных чисел при каждом запуске программы с одинаковым значением seed. Это полезно для тестирования и отладки, когда нужно гарантировать, что результаты будут одинаковыми на каждом запуске.

Когда Вы задаете значение для random.seed(), это инициализирует внутренний генератор случайных чисел с конкретным начальным значением, что позволяет генерировать одну и ту же последовательность случайных чисел.

Рассмотрим использование random.seed() для генерации повторяющихся чисел -
--
import random

# Устанавливаем значение seed
random.seed(42)

# Генерация трех случайных чисел
print(random.random())  
print(random.random())  
print(random.random())  
----
0.6394267984578837
0.025010755222666936
0.27502931836911926
------
- И значения всегда останутся такими же.

Или вот такой вот код -
--
import random

# Устанавливаем значение seed
random.seed(123)

# Генерация случайных целых чисел
print(random.randint(1, 100))  
print(random.randint(1, 100))  
print(random.randint(1, 100))  
----
7
35
12
------

Значение seed не имеет особого смысла само по себе — важно только, что оно детерминирует последовательность псевдослучайных чисел.

Если вам нужна повторяемость результатов, выберите любое фиксированное значение. Это может быть целое число, число с плавающей точкой или строка.

Для уникальной случайности при каждом запуске просто не задавайте значение seed или используйте текущее время.

************************************

10.2 - Рассматриваем методы random

рассмотрим основные методы работы с random

random() -
Возвращает случайное число с плавающей точкой в диапазоне от 0.0 до 1.0 -
--
import random

print(random.random())
----
0.37444887175646646
------

randint(a, b) -
Возвращает случайное целое число в диапазоне от a до b включительно -
--
import random

print(random.randint(1, 10))
----
3
------
- включает и 1, и 10

uniform(a, b) -
Возвращает случайное число с плавающей точкой в диапазоне от a до b -
--
import random

print(random.uniform(1.5, 10.5))
----
6.236
------

randrange(start, stop, step) -
Возвращает случайное целое число из последовательности, определённой началом start, концом stop и шагом step -
--
import random

print(random.randrange(0, 10, 2))
----
4
----
- тут выбор из 0, 2, 4, 6, 8

choice(seq) -
Возвращает случайный элемент из непустой последовательности seq (например, список, строка или кортеж) -
--
import random

items = ['apple', 'banana', 'cherry']
print(random.choice(items))  
----
'banana'
------

choices(population, weights=None, k=1) -
Функция random.choices() в Python позволяет выбрать случайные элементы из последовательности, при этом элементы могут повторяться. Она принимает несколько параметров, включая обязательный параметр population (список или другую последовательность, из которой нужно выбирать) и параметр k, который указывает количество случайных элементов, которые нужно вернуть. 

Возвращает список из k случайных элементов из последовательности population. Можно использовать параметр weights для указания вероятности каждого элемента -
--
import random

items = ['apple', 'banana', 'cherry']
print(random.choices(items, k=2))
----
['cherry', 'apple']
------

В этом примере у 'cherry' наибольший вес, поэтому она будет выбираться чаще -
--
import random

items = ['apple', 'banana', 'cherry']
weights = [1, 2, 3]  # 'apple' выбирается реже, 'cherry' — чаще
result = random.choices(items, weights=weights, k=3)
print(result)
----
['cherry', 'banana', 'cherry']
------

shuffle(seq) -
Перемешивает элементы последовательности seq на месте -
--
import random

numbers = [1, 2, 3, 4, 5]
random.shuffle(numbers)
print(numbers) 
----
[4, 1, 5, 2, 3]
------

sample(population, k) -
Возвращает список из k уникальных случайных элементов из последовательности population -
--
import random

items = ['apple', 'banana', 'cherry', 'date']
print(random.sample(items, 2))  
----
['banana', 'cherry']
------

Тут сразу посмотрим на 6 пункт и сравним -
- random.choices() — выбирает элементы с возвращением, то есть один элемент может быть выбран несколько раз.
- random.sample() — выбирает элементы без возвращения, то есть каждый элемент может быть выбран только один раз.

************************************

10.3 - Как замерять время работы программы?

Замер времени выполнения программ или отдельных участков кода полезен для анализа производительности и оптимизации.

Очень часто мы используем это для замера скорости циклов, алгоритмов, сортировок и так далее. Начнем с модуля time.

Модуль time предоставляет функции для работы с временем. Самый простой способ замерить время выполнения — это использовать функции time.time() или time.perf_counter() -
--
import time

start_time = time.time()

for i in range(1000000):
    pass

end_time = time.time()

execution_time = end_time - start_time
print(f"Время выполнения: {execution_time} секунд")
----
- start_time ставится в начало замера кода, а end_time ставится в конце замера программы. Далее просто считается разница. time.time() возвращает время в секундах с начала эпохи (обычно с 1 января 1970 года). Разница между началом и концом выполнения даст время в секундах.

time.perf_counter() — это более точная функция, которая учитывает время в высокоточной системе (например, на уровне процессора). Она полезна для более точных замеров -
--
import time

start_time = time.perf_counter()


for i in range(1000000):
    pass

end_time = time.perf_counter()
execution_time = end_time - start_time

print(f"Время выполнения: {execution_time} секунд")
----

Можно создать собственный декоратор, чтобы автоматически замерять время выполнения любой функции. Очень советую сохранить, чтобы замерять скорость других функций -
--
import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        execution_time = end_time - start_time
        print(f"Время выполнения {func.__name__}: {execution_time} секунд")
        return result
    return wrapper

@timer_decorator
def test_function():
    for i in range(1000000):
        pass

test_function()
----
- добавив декоратор перед функциями, мы будем иметь еще и время их выполнения

Также можно использовать cProfile. cProfile — это встроенный модуль для профилирования программ, который не только замеряет время выполнения, но и анализирует производительность каждой части программы -
--
import cProfile

def test_function():
    for i in range(1000000):
        pass

cProfile.run('test_function()')
----
- при выводе каждый столбец имеет следующую информацию -

- ncalls: Количество вызовов функции.
- tottime: Общее время, которое было потрачено на выполнение этой функции (без учета времени, затраченного на вызов других функций внутри неё).
- percall: Среднее время на вызов функции, вычисляется как tottime / ncalls.
- cumtime: Кумулятивное время — общее время, затраченное на выполнение функции, включая вызовы всех вложенных функций.
- percall (cumtime): Среднее кумулятивное время на вызов функции, вычисляется как cumtime / ncalls.
- filename(function): Имя файла, строка, где находится функция, и имя самой функции.

<string>:1(<module>):
- Это строка, соответствующая глобальной области видимости вашего кода, где происходит выполнение основного тела программы.
- tottime = 0.000: Выполнение этой части кода не заняло значительного времени.
- cumtime = 0.019: Это кумулятивное время, потому что основной модуль вызвал функцию test_function(), которая занимала 0.019 секунд.

main.py:3(test_function):
- Это основная функция, которую вы профилировали — test_function().
- ncalls = 1: Функция была вызвана один раз.
- tottime = 0.019: Время, затраченное исключительно на выполнение этой функции, составило 0.019 секунд.
- cumtime = 0.019: Кумулятивное время равно 0.019 секунд, так как внутри функции не было вызвано других функций.

{built-in method builtins.exec}:
- Это встроенная функция Python, которая выполняет ваш код.
- tottime = 0.000: Время, затраченное на этот вызов, незначительно.
- cumtime = 0.019: Это общее время выполнения программы, включая test_function()

{method 'disable' of '_lsprof.Profiler' objects}:
- Это метод профилировщика, который отключает сбор данных после выполнения кода.
- Время, потраченное на него, незначительно (tottime = 0.000, cumtime = 0.000)

Почему 4 вызова функции?  4 вызова включают не только вызов функции test_function, но и вызовы системных функций Python, которые связаны с выполнением программы.

************************************

11.1 - Decimal

Decimal — это класс из модуля decimal в Python, который используется для работы с числами с плавающей запятой с высокой точностью. В отличие от обычных чисел с плавающей точкой (float), которые могут приводить к ошибкам округления из-за ограниченной точности, числа типа Decimal позволяют выполнять арифметические операции с точной арифметикой, что полезно, например, для финансовых вычислений

Decimal позволяет задавать точность вычислений и избегать проблем с округлением, которые возникают при использовании обычных чисел с плавающей точкой.

Модуль decimal позволяет изменять контекст, задавая количество знаков после запятой, при вычислениях.

Для использования Decimal нужно импортировать модуль decimal -
--
from decimal import Decimal

# Создание Decimal из строки
number = Decimal('0.1')
print(number)
----
0.1
------

взглянем на разницу между float и decimal. Числа с плавающей точкой (float) могут давать неожиданные результаты из-за ограниченной точности -
--
print(0.1 + 0.2)  # 0.30000000000000004 (из-за округления)
print(type(0.1 + 0.2))
# Используем Decimal для точных вычислений
from decimal import Decimal
print(Decimal('0.1') + Decimal('0.2'))  # 0.3
----

Можем легко и просто ограничить количество знаков после запятой -
--
from decimal import Decimal, getcontext

# Установка точности в 3 знака -
getcontext().prec = 3

print(Decimal('1.2345') + Decimal('2.3456'))  # 3.58
----

Теперь взглянем на более красивый пример.
Допустим, у нас есть три товара с ценами -
Товар 1: $0.1
Товар 2: $0.2
Товар 3: $0.3

Мы попробуем вычислить общую стоимость этих товаров, используя как float, так и Decimal -
--
from decimal import Decimal, getcontext

# Цены товаров как float
price1_float = 0.1
price2_float = 0.2
price3_float = 0.3

# Цены товаров как Decimal
price1_decimal = Decimal('0.1')
price2_decimal = Decimal('0.2')
price3_decimal = Decimal('0.3')

# Расчет общей стоимости с использованием float
total_float = price1_float + price2_float + price3_float
print(f"Общая стоимость с float: {total_float}")

# Настройка точности Decimal (точность до 2 знаков после запятой)
getcontext().prec = 6  # Устанавливаем контекст для Decimal
total_decimal = price1_decimal + price2_decimal + price3_decimal
print(f"Общая стоимость с Decimal: {total_decimal}")
----
Общая стоимость с float: 0.6000000000000001
Общая стоимость с Decimal: 0.6
------

Или, например, когда мы с деньгами работаем более серьезно, а именно с процентами -
--
from decimal import Decimal

# Расчет итоговой суммы с НДС
price = Decimal('100.25')  # Цена товара
tax_rate = Decimal('0.18')  # Ставка НДС 18%

# Вычисляем НДС
tax = price * tax_rate
total_price = price + tax

# Красивый вывод результата
print(f"Цена товара: {price}")
print(f"НДС (18%): {tax}")
print(f"Итоговая стоимость: {total_price}")
----
Цена товара: 100.25
НДС (18%): 18.0450
Итоговая стоимость: 118.2950
------

Использование Decimal в таких задачах гарантирует, что даже при обработке большого количества транзакций или сложных вычислений суммы будут рассчитываться корректно

************************************

11.2 - Fractions

Fractions — это часть стандартного модуля fractions в Python, который предоставляет класс Fraction для работы с рациональными числами. Рациональные числа представляют собой дроби, записанные в виде числителя и знаменателя. Модуль fractions позволяет точно представлять дроби и выполнять с ними арифметические операции, что особенно полезно, когда требуется точное представление, без ошибок округления, которые могут возникать при использовании чисел с плавающей точкой (float).

- Точность: Работа с дробями в точности как с математическими объектами. Например, при делении 1/3 можно получить точное значение 1/3, а не приближённое значение с плавающей точкой.
- Поддержка арифметических операций: Класс Fraction поддерживает сложение, вычитание, умножение, деление и другие операции с дробями.
- Создание дробей: Дроби могут быть созданы из целых чисел, строк или чисел с плавающей точкой.

Подключать ничего не нужно, все уже есть в Python. Попробуем запустить следующий код -
--
from fractions import Fraction

# Создание дроби из числителя и знаменателя
frac1 = Fraction(1, 3)
frac2 = Fraction(2, 5)

print(frac1)
print(frac2)
----
1/3
2/5
------
- увидим, что выведет реальную дробь, а не длинное вещественное значение

Объекты Fraction можно создать максимально просто. Мы рассмотрели создание из целых чисел дроби. 
Можно также это сделать и из строки -
--
f = Fraction("7/8")
print(f)  
----
7/8
------

А также из числа с плавающей запятой -
--
f = Fraction(0.5)

print(f)
----
1/2
------

А также из decimal -
--
from fractions import Fraction
from decimal import Decimal

f = Fraction(Decimal('0.25'))
print(f)
----
1/4
------

Класс Fraction поддерживает стандартные арифметические операции, такие как сложение, вычитание, умножение и деление.
--
from fractions import Fraction

f1 = Fraction(1, 3)
f2 = Fraction(2, 5)

# Сложение
result_add = f1 + f2
print(result_add)  # Output: 11/15

# Вычитание
result_sub = f1 - f2
print(result_sub)  # Output: -1/15

# Умножение
result_mul = f1 * f2
print(result_mul)  # Output: 2/15

# Деление
result_div = f1 / f2
print(result_div)  # Output: 5/6
----

Класс Fraction автоматически сокращает дроби. Например, если вы создаёте дробь 2/4, Python автоматически преобразует её в 1/2 -
--
f = Fraction(2, 4)
print(f)  
----
1/2
------

А также методы для работы с числителем и знаменателем -
- numerator — возвращает числитель дроби.
- denominator — возвращает знаменатель дроби.
--
from fractions import Fraction

f = Fraction(5, 8)
print(f.numerator)   
print(f.denominator) 
----
5
8
------

************************************

12.1 - Введение в комбинаторику

Комбинаторика — это раздел математики, который изучает количество способов выбрать, упорядочить или распределить элементы в конечных множествах. Вот несколько основных формул и понятий, используемых в комбинаторике.

Перестановки — это различные способы упорядочить все элементы множества. Порядок элементов имеет значение.

ТАМ КАРТИНКИ С ФОРМУЛАМИ - нужно смотреть на сайте 

************************************

12.2 - Что такое IterTools?

Модуль itertools в Python предоставляет функции для эффективного решения задач, связанных с комбинаторикой. Он помогает генерировать перестановки, комбинации, декартовы произведения и другие наборы элементов без необходимости вручную реализовывать эти алгоритмы

Основные функции itertools для комбинаторных задач:
1. permutations() — Генерация перестановок.
2. combinations() — Генерация комбинаций без повторений.
3. combinations_with_replacement() — Генерация комбинаций с повторениями.
4. product() — Декартово произведение множеств (все возможные комбинации элементов).

Рассмотрим первую задачу - перестановки букв.
Условие: Сколько различных способов можно переставить буквы в слове "ABC"?
Теперь давайте рассмотрим решение при помощи itertools. Использовать будем метод permutations.
Эта функция генерирует все возможные перестановки элементов итерируемого объекта. Порядок важен, и каждый элемент может быть использован только один раз.
--
import itertools

data = ['A', 'B', 'C']
permutations = itertools.permutations(data)
for p in permutations:
    print(p)
----
('A', 'B', 'C')
('A', 'C', 'B')
('B', 'A', 'C')
('B', 'C', 'A')
('C', 'A', 'B')
('C', 'B', 'A')
------

Рассмотрим вторую задачу - различные комбинации из набора символов. Сколько комбинаций может быть из набора символов 1, 2, 3, 4 длиною 2 символа? Реализуем это с помощью функции combinators.
Функция генерирует все возможные комбинации элементов заданной длины из итерируемого объекта. Порядок не важен, элементы не могут повторяться
--
import itertools

combs = itertools.combinations([1, 2, 3, 4], 2)
for comb in combs:
    print(comb)
----
(1, 2)
(1, 3)
(1, 4)
(2, 3)
(2, 4)
(3, 4)
------
- заметим, что здесь не было повторения элементов, по типу 
1, 1
2, 2
Рассмотрим также и их. Используется метод combinations_with_replacement() -
--
import itertools

combs_rep = itertools.combinations_with_replacement([1, 2, 3], 2)
for comb in combs_rep:
    print(comb)
----
(1, 1)
(1, 2)
(1, 3)
(2, 2)
(2, 3)
(3, 3)
------

Также рассмотрим метод product, который будет делать декартово произведение. То есть он составляет все возможные комбинации элементов из нескольких итерируемых объектов -
--
import itertools

prod = itertools.product([1, 2], ['A', 'B'])
for p in prod:
    print(p)
----
(1, 'A')
(1, 'B')
(2, 'A')
(2, 'B')
------

у IterTools также есть и множество других методов. Так, например метод chain. Функция объединяет несколько списков или итерируемых объектов в один, не создавая новый список -
--
import itertools

list1 = [1, 2, 3]
list2 = ['A', 'B', 'C']
chained = itertools.chain(list1, list2)
for item in chained:
    print(item)
----
1
2
3
A
B
C
------

метод islice - извлечение среза из итератора. Эта функция позволяет извлекать часть элементов из бесконечного или очень большого итерируемого объекта -
--
from itertools import islice

# Генератор бесконечного потока чисел
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

# Извлечём только первые 5 чисел
limited_numbers = islice(infinite_numbers(), 5)
for num in limited_numbers:
    print(num)
----
0
1
2
3
4
------

метод groupby. Он группирует последовательные элементы на основе их ключа -
--
import itertools

data = [(1, 'A'), (1, 'B'), (2, 'C'), (2, 'D')]
grouped = itertools.groupby(data, key=lambda x: x[0])

for key, group in grouped:
    print(key, list(group))
----
1 [(1, 'A'), (1, 'B')]
2 [(2, 'C'), (2, 'D')]
------

метод accumulate, который будет аккумулировать значения. (по умолчанию сложение) -
--
import itertools

data = [1, 2, 3, 4]
accumulated = itertools.accumulate(data)
print(list(accumulated))
----
[1, 3, 6, 10]
------

************************************

13.1 - Как реализуются графические приложения на Python?

Графические приложения на Python можно реализовать с помощью различных библиотек, которые предоставляют средства для создания оконных интерфейсов, обработки событий и взаимодействия с пользователем. Вот основные библиотеки для создания графических интерфейсов на Python:

Tkinter — это встроенная в стандартную библиотеку Python библиотека для создания простых графических интерфейсов. Она часто используется для разработки настольных приложений.

Особенности Tkinter:
- Простота и наличие в стандартной библиотеке Python.
- Подходит для небольших и простых приложений.
- Поддерживает создание виджетов, таких как кнопки, метки, поля ввода и т.д.

Небольшой пример. Он рабочий, потому что tkinter уже есть в любой последней версии Python -
--
import tkinter as tk

# Создание основного окна
root = tk.Tk()
root.title("Простое приложение")
root.geometry("300x200")

# Создание метки
label = tk.Label(root, text="Привет, мир!")
label.pack()

# Создание кнопки
button = tk.Button(root, text="Нажми меня", command=lambda: label.config(text="Кнопка нажата!"))
button.pack()

# Запуск основного цикла событий
root.mainloop()
----

PyQt — это мощная библиотека для создания графических интерфейсов, основанная на библиотеке Qt. Она позволяет создавать более сложные и профессиональные приложения с множеством виджетов и функциональностью.

Особенности PyQt:
- Мощная библиотека для создания профессиональных приложений.
- Большое количество виджетов и поддержка современных GUI.
- Поддерживает мультимедиа, графику и 3D.
- Требует установки (не является частью стандартной библиотеки Python)

Kivy — это библиотека для создания мультитач-приложений с поддержкой кросс-платформенности (Windows, macOS, Linux, Android, iOS). Она используется для создания интерактивных приложений и игр -
--
from kivy.app import App
from kivy.uix.button import Button

class MyApp(App):
    def build(self):
        return Button(text="Нажми меня", on_press=self.on_button_press)

    def on_button_press(self, instance):
        instance.text = "Кнопка нажата!"

# Запуск приложения
if __name__ == "__main__":
    MyApp().run()
----
- для этого библиотеку нужно установить. Правой кнопкой мыши нажимаете на kivy в коде и нажимаете кнопку install package kivy

Особенности Kivy:
- Поддержка сенсорного ввода и мультитач.
- Легкость создания кросс-платформенных приложений.
- Подходит для создания мобильных приложений и игр.
- Не входит в стандартную библиотеку Python.

wxPython — это обертка для библиотеки wxWidgets, которая позволяет создавать кросс-платформенные приложения с нативным интерфейсом для Windows, macOS и Linux

Особенности wxPython:
- Поддержка кросс-платформенных нативных приложений.
- Позволяет создавать сложные пользовательские интерфейсы.
- Требует установки (не входит в стандартную библиотеку Python)

PyGame используется для создания игр, но также может применяться для создания простых графических интерфейсов. Она поддерживает мультимедиа, графику, анимацию и работу с пользовательским вводом.

Опять же, правой кнопкой мыши по библиотеке - и скачиваем библиотеку -
--
import pygame

# Инициализация PyGame
pygame.init()

# Установка размеров окна
screen = pygame.display.set_mode((400, 300))
pygame.display.set_caption("Простое приложение на PyGame")

# Основной цикл приложения
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    screen.fill((0, 0, 0))  # Заполняем экран черным цветом
    pygame.display.flip()    # Обновляем экран

# Завершение работы
pygame.quit()
----

код игры "змейка" - 
--
import pygame
import random
import time


pygame.init()

# Определяем цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (213, 50, 80)
GREEN = (0, 255, 0)
BLUE = (50, 153, 213)

# Размеры экрана
WIDTH = 600
HEIGHT = 400

# Размер одного блока змейки
BLOCK_SIZE = 20

# Установка экрана
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption('Змейка')

# Установка времени обновления игры
clock = pygame.time.Clock()
SNAKE_SPEED = 15

# Шрифт для отображения текста
font_style = pygame.font.SysFont("bahnschrift", 25)
score_font = pygame.font.SysFont("comicsansms", 35)

# Функция отображения счета
def display_score(score):
    value = score_font.render("Счет: " + str(score), True, WHITE)
    screen.blit(value, [0, 0])

# Функция отображения сообщения
def display_message(msg, color):
    mesg = font_style.render(msg, True, color)
    screen.blit(mesg, [WIDTH / 6, HEIGHT / 3])

# Основная игра
def game_loop():
    game_over = False
    game_close = False

    # Начальные координаты змейки
    x = WIDTH / 2
    y = HEIGHT / 2

    # Направление змейки
    x_change = 0
    y_change = 0

    # Тело змейки
    snake = []
    snake_length = 1

    # Координаты еды
    food_x = round(random.randrange(0, WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
    food_y = round(random.randrange(0, HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE

    # Основной цикл игры
    while not game_over:

        while game_close:
            screen.fill(BLUE)
            display_message("Проигрыш! Нажмите Q - выйти или C - играть снова", RED)
            display_score(snake_length - 1)
            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_q:
                        game_over = True
                        game_close = False
                    if event.key == pygame.K_c:
                        game_loop()

        # Обработка нажатий клавиш
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                game_over = True
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    x_change = -BLOCK_SIZE
                    y_change = 0
                elif event.key == pygame.K_RIGHT:
                    x_change = BLOCK_SIZE
                    y_change = 0
                elif event.key == pygame.K_UP:
                    y_change = -BLOCK_SIZE
                    x_change = 0
                elif event.key == pygame.K_DOWN:
                    y_change = BLOCK_SIZE
                    x_change = 0

        # Обновление положения змейки
        if x >= WIDTH or x < 0 or y >= HEIGHT or y < 0:
            game_close = True
        x += x_change
        y += y_change

        screen.fill(BLACK)
        pygame.draw.rect(screen, GREEN, [food_x, food_y, BLOCK_SIZE, BLOCK_SIZE])

        # Обновление тела змейки
        snake_head = []
        snake_head.append(x)
        snake_head.append(y)
        snake.append(snake_head)
        if len(snake) > snake_length:
            del snake[0]

        # Проверка на столкновение с самим собой
        for segment in snake[:-1]:
            if segment == snake_head:
                game_close = True

        # Рисуем змейку
        for segment in snake:
            pygame.draw.rect(screen, WHITE, [segment[0], segment[1], BLOCK_SIZE, BLOCK_SIZE])

        display_score(snake_length - 1)

        pygame.display.update()

        # Если змейка съела еду
        if x == food_x and y == food_y:
            food_x = round(random.randrange(0, WIDTH - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
            food_y = round(random.randrange(0, HEIGHT - BLOCK_SIZE) / BLOCK_SIZE) * BLOCK_SIZE
            snake_length += 1

        # Устанавливаем скорость игры
        clock.tick(SNAKE_SPEED)

    # Завершаем работу pygame
    pygame.quit()
    quit()

# Запуск игры
game_loop()
----

Особенности PyGame:
- Изначально предназначена для создания игр.
- Поддержка работы с графикой, звуком, анимацией и пользовательским вводом.
- Подходит для создания игр и мультимедийных приложений

************************************

13.2 - Введение в PyQT5

PyQt5 — это набор привязок для языка Python, которые позволяют взаимодействовать с библиотекой Qt для создания графических пользовательских интерфейсов (GUI). PyQt5 является одной из наиболее популярных библиотек для создания кросс-платформенных приложений на Python с графическим интерфейсом. Qt — это мощная библиотека, используемая для разработки настольных и мобильных приложений с поддержкой интерфейсов, мультимедиа, 3D-графики и многого другого.

Почему PyQT5? Честно - потому что очень много документации, большое комьюнити + кроссплатформенность.
У многих из-за особенностей операционной системы может не работать версия PyQt5, по крайней мере так показывает практика. Но при этом с PyQt6 у Вас вероятно проблем не будет. Разницы Вы не заметите, но PyQt5 мне нравится больше. Код будет приложен для обоих версий.

Перейдем в PyCharm и установим PyQt, если у Вас -

5 версия - 
--
​​​​​​​pip install PyQt5
----

6 версия - 
--
​​​​​​​pip install PyQt6
----

разницы Вы не заметите, можете хоть 2 версии себе установить

--
import sys
from PyQt5.QtWidgets import QApplication, QPushButton, QLabel, QVBoxLayout, QWidget

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("Простое приложение")

layout = QVBoxLayout()

label = QLabel("Привет, мир!")
button = QPushButton("Нажми меня")
button.clicked.connect(lambda: label.setText("Кнопка нажата!"))

layout.addWidget(label)
layout.addWidget(button)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----

************************************

13.3 - Что такое window и label?

Окна в графических приложениях — это базовые элементы, которые предоставляют пользователю интерфейс для взаимодействия с программой. Они могут содержать различную информацию и элементы управления, но само окно выступает как основа для отображения этой информации.

Окна служат контейнерами для графического интерфейса программы, в которых пользователь может видеть и взаимодействовать с программой. Окна могут выполнять следующие задачи:
- Отображение информации: текст, изображения, графика и другие данные.
- Взаимодействие с пользователем: предоставление доступа к элементам управления, таким как кнопки, меню, поля ввода.
- Обработка событий: окна реагируют на действия пользователя, такие как нажатие мыши, ввод с клавиатуры, изменение размеров и т.д.

То есть любой открытый браузер - это окно.

В графических приложениях существуют различные типы окон, которые можно использовать в зависимости от задачи.

1. Главное окно (Main Window)
Это основное окно программы, которое содержит основную информацию или элементы управления. Обычно в нем могут быть меню, панели инструментов, область содержимого и статусная строка.

Пример: текстовый редактор, где главное окно содержит меню (Файл, Правка и т.д.), текстовое поле для редактирования текста и статусную строку.

2. Диалоговые окна (Dialog Windows)
Диалоговые окна — это вспомогательные окна, которые запрашивают у пользователя дополнительную информацию или подтверждение. Они обычно появляются поверх главного окна и требуют от пользователя выполнить какое-то действие (например, нажать кнопку "ОК" или "Отмена").

Примеры диалоговых окон:
- Окно подтверждения ("Вы уверены, что хотите закрыть программу?")
- Окно настроек
- Окно открытия или сохранения файла

3. Всплывающие окна (Popup Windows)
Всплывающие окна — это небольшие окна, которые появляются поверх других окон. Обычно они используются для предоставления контекстной информации или предупреждений.

Пример: окно с подсказкой или уведомление об ошибке.

4. Модальные окна (Modal Windows)
Модальные окна блокируют взаимодействие с другими окнами программы до тех пор, пока пользователь не завершит взаимодействие с модальным окном. Например, если открылось окно подтверждения "Сохранить изменения", пользователю нужно сначала ответить, чтобы продолжить работу с основным окном.

5. Вспомогательные окна (Tool Windows)
Это небольшие окна, которые служат для предоставления дополнительных инструментов для работы с программой. Пример: панель инструментов в графическом редакторе.

Рассмотрим самое простое основное окно -
--
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow

# Создание приложения
app = QApplication(sys.argv)

# Создание главного окна
window = QMainWindow()
window.setWindowTitle("Простое окно")
window.setGeometry(100, 100, 600, 400)  # Устанавливаем размер и позицию окна

# Показ окна
window.show()

# Запуск основного цикла обработки событий
sys.exit(app.exec())
----

--
app = QApplication(sys.argv)
----
- Это точка входа в программу. Мы вмешиваемся в работу ОС, чтобы можно было открыть окно

--
window = QMainWindow()
----
- Далее мы создаем окно, его тип Main Window

--
window.setWindowTitle("Простое окно")
window.setGeometry(100, 100, 600, 400)
----
- Далее мы даем название нашему окну, а также выстраиваем геометрию окна. 
x (100) — горизонтальная позиция окна на экране относительно левого верхнего угла экрана (в пикселях).
y (100) — вертикальная позиция окна на экране относительно левого верхнего угла экрана (в пикселях).
width (600) — ширина окна (в пикселях).
height (400) — высота окна (в пикселях)

--
window.show()
----
- это просто показ окна, чтобы при запуске мы его увидели

--
sys.exit(app.exec())
----
- Закрытие приложение и правильное высвобождение ресурсов

Label в PyQt (и в других GUI-библиотеках) — это виджет, предназначенный для отображения текстовой или графической информации. Он используется для того, чтобы показывать статический текст, изображения или другие элементы на экране, которые не предполагают взаимодействия с пользователем. Метки не предназначены для получения ввода от пользователя (например, нажатия клавиш или кликов), они просто отображают информацию.

В PyQt метки создаются с помощью класса QLabel -
--
import sys
from PyQt5.QtWidgets import QApplication, QLabel, QWidget

app = QApplication(sys.argv)

# Создание окна
window = QWidget()
window.setWindowTitle("Пример QLabel")
window.setGeometry(100, 100, 400, 200)  # Установка размеров окна

# Создание метки и установка ее как дочерний элемент для окна
label = QLabel("Привет, мир!", parent=window)
label.move(150, 80)  # Позиционирование метки вручную

# Показ окна
window.show()

sys.exit(app.exec())
----

Здесь добавляется блок кода с созданием переменной label.

В кавычках указывается то, что будет в QLabel ( в тексте ), указывается родитель для того, чтобы понять куда этот текст "лепить". У нас это наше окно. Так как мы налепили его, нам необходимо его вручную передвинуть. 

x (150) — горизонтальная координата, определяющая, насколько метка будет смещена вправо от левого края окна (в пикселях).
y (80) — вертикальная координата, определяющая, насколько метка будет смещена вниз от верхнего края окна (в пикселях)

--
import sys
from PyQt5.QtWidgets import QApplication, QLabel, QWidget
from PyQt5.QtGui import QFont

app = QApplication(sys.argv)

# Создание окна
window = QWidget()
window.setWindowTitle("Изменение стиля QLabel")
window.setGeometry(100, 100, 400, 200)

# Создание метки
label = QLabel("Привет, мир!", parent=window)

# Изменение шрифта, размера и толщины текста с помощью setFont
font = QFont("Arial", 24)  # Шрифт Arial, размер 24
font.setBold(True)  # Сделать текст жирным
label.setFont(font)

# Изменение цвета текста с помощью стиля
label.setStyleSheet("color: blue;")  # Устанавливаем синий цвет текста

# Позиционирование метки
label.move(50, 50)

# Показ окна
window.show()

sys.exit(app.exec())
----

также мы можем использовать QSS стили -
--
import sys
from PyQt5.QtWidgets import QApplication, QLabel, QWidget
from PyQt5.QtGui import QFont

app = QApplication(sys.argv)

# Создание окна
window = QWidget()
window.setWindowTitle("Изменение стиля QLabel")
window.setGeometry(100, 100, 400, 200)

# Создание метки
label = QLabel("Привет, мир!", parent=window)

# Изменение шрифта, размера и толщины текста с помощью setFont
font = QFont("Arial", 24)  # Шрифт Arial, размер 24
font.setBold(True)  # Сделать текст жирным
label.setFont(font)

# Устанавливаем цвет фона и толщину текста через QSS (стили)
label.setStyleSheet("""
    color: red;              /* Цвет текста */
    background-color: yellow; /* Цвет фона */
    border: 2px solid black;  /* Черная рамка вокруг текста */
""")

# Позиционирование метки
label.move(50, 50)

# Показ окна
window.show()

sys.exit(app.exec())
----

************************************

13.4 - Что такое layout? QVBox layout vs QHBox layout

В PyQt5, layout (расположение) — это способ управления размещением виджетов (элементов интерфейса, таких как кнопки, текстовые поля и т.д.) внутри окна или другого контейнера. Layout автоматически управляет позицией и размером виджетов, чтобы они аккуратно располагались в пределах окна, а также адаптировались к изменениям размеров окна

Существует несколько типов layout в PyQt5:

- QHBoxLayout — горизонтальное расположение. Все виджеты располагаются в один ряд слева направо.

- QVBoxLayout — вертикальное расположение. Виджеты располагаются сверху вниз.

- QGridLayout — сеточное расположение. Позволяет расположить виджеты в виде сетки с ячейками.

- QFormLayout — табличное расположение, используется для создания форм, где элементы располагаются парами (название поля и само поле)

Пример с QHBoxLayout и QLabel (горизонтальное расположение) -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QHBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QHBoxLayout with QLabel Example")

layout = QHBoxLayout()

label1 = QLabel("Label 1")
label2 = QLabel("Label 2")
label3 = QLabel("Label 3")

layout.addWidget(label1)
layout.addWidget(label2)
layout.addWidget(label3)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----
- Здесь мы создаем layout, и делаем его horizontal. О чем говорит нам тип layout - QHBoxLayout.
Далее мы создаем три текстовых поля и добавляем их на layout через команду add widget

Поскольку слоев может быть несколько, мы говорим о том, что на данный момент этот layout - основной для нашего окна. Слои могут стоять рядом, могут накладываться друг на друга и так далее

Пример с QVBoxLayout и QLabel (вертикальное расположение) -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QVBoxLayout with QLabel Example")

layout = QVBoxLayout()

label1 = QLabel("Label 1")
label2 = QLabel("Label 2")
label3 = QLabel("Label 3")

layout.addWidget(label1)
layout.addWidget(label2)
layout.addWidget(label3)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----
- Здесь процесс аналогичный, только группировка уже будет вертикальной

То есть вне зависимости от количества и размеров label, группировка всегда будет выполняться. И с кнопками это также работает

Пример с QGridLayout и QLabel (сеточное расположение). Здесь мы располагаем метки в виде таблицы -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QGridLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QGridLayout with QLabel Example")

layout = QGridLayout()

label1 = QLabel("Label 1")
label2 = QLabel("Label 2")
label3 = QLabel("Label 3")
label4 = QLabel("Label 4")

layout.addWidget(label1, 0, 0)  # (row, column)
layout.addWidget(label2, 0, 1)
layout.addWidget(label3, 1, 0)
layout.addWidget(label4, 1, 1)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----
- Здесь логика такая же, но мы используем QGridLayout, который вручную делает группировку, как в таблице. О чем говорят нам строки -
--
layout.addWidget(label1, 0, 0)  # (row, column)
layout.addWidget(label2, 0, 1)
layout.addWidget(label3, 1, 0)
layout.addWidget(label4, 1, 1)
----

Пример с QFormLayout и QLabel (форматированное расположение)
Этот layout часто используется для создания форм с метками и элементами ввода, но здесь мы используем только метки -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QFormLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QFormLayout with QLabel Example")

layout = QFormLayout()

label1 = QLabel("Name:")
value1 = QLabel("John Doe")

label2 = QLabel("Email:")
value2 = QLabel("johndoe@example.com")

layout.addRow(label1, value1)
layout.addRow(label2, value2)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----

Ну и комбинированный layout -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QVBoxLayout, QHBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("Combined Layout with QLabel Example")


main_layout = QVBoxLayout()

# Горизонтальный layout 1
layout1 = QHBoxLayout()
label1 = QLabel("Label 1")
label2 = QLabel("Label 2")
layout1.addWidget(label1)
layout1.addWidget(label2)

# Горизонтальный layout 2
layout2 = QHBoxLayout()
label3 = QLabel("Label 3")
label4 = QLabel("Label 4")
layout2.addWidget(label3)
layout2.addWidget(label4)

# Добавляем горизонтальные layout'ы в основной вертикальный layout
main_layout.addLayout(layout1)
main_layout.addLayout(layout2)

window.setLayout(main_layout)
window.show()

sys.exit(app.exec())
----
- создаем вертикальный layout и делаем его основным. На него уже натягиваем еще 2 слоя, но уже горизонтальных. То есть в рамках этих горизонтальных слоев объекты будут группироваться по горизонтали, а горизонтальные слои будут выравниваться по вертикали, все слои и группировки работают вне зависимости от масштаба

************************************

13.5 - Как работать с кнопками? Виды кнопок

В PyQt5 кнопка — это элемент управления, представленный классом QPushButton. Она используется для выполнения определенных действий в графическом интерфейсе, когда пользователь на неё нажимает. Кнопки — это основные интерактивные элементы, которые могут запускать различные функции или операции по клику.

Текст и иконки: Кнопка может отображать текст, иконку или и то и другое. Это позволяет легко создавать кнопки с визуальными подсказками.

Сигналы и слоты: Кнопки в PyQt5 используют механизм сигналов и слотов для обработки событий. Когда пользователь нажимает на кнопку, генерируется сигнал clicked(), который можно связать с определенной функцией.

Настраиваемый внешний вид: Кнопки могут быть стилизованы с помощью CSS, чтобы изменить их цвет, размер, шрифт и т.д.

Функциональные возможности: Кнопку можно сделать неактивной, скрыть или заблокировать на время выполнения каких-либо операций.

Давайте рассмотрим пример самой простой кнопки, потом посмотрим, что с ней можно сделать и поглядим на другие виды кнопок. Первое - это QPushButton -
--
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton

app = QApplication([])

# Создание окна
window = QWidget()
window.setWindowTitle("Button Example")

# Создание кнопки
button = QPushButton("Click Me", window)
button.setGeometry(100, 100, 200, 40)  # Установка позиции и размера кнопки

# Отображение окна
window.show()
app.exec()
----

Если кликать на кнопку, то ничего не происходит. Давайте это исправим. Будем выводить сообщение в терминал в PyCharm, когда на кнопку будут тыкать.

Создадим функцию on_button_click, которая просто выводит текст в терминал -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton

def on_button_click():
    print("Button was clicked!")

app = QApplication(sys.argv)

# Создание окна
window = QWidget()
window.setWindowTitle("Button Click Example")

# Создание кнопки
button = QPushButton("Click Me", window)
button.setGeometry(100, 100, 200, 40)

# Связь сигнала с функцией
button.clicked.connect(on_button_click)

# Отображение окна
window.show()

sys.exit(app.exec())
----
- тут связываем функцию и кнопку, посредством кода - 
--
button.clicked.connect(on_button_click)
----

Соответсвенно по кусочкам -
- button - не служебное слово, а название нашей кнопки. 
- clicked - означает, что на кнопку нажали
- connect - функция, которая соединяет нажатие с тем, что должно произойти

текст будет выводиться в терминале, сколько кликов - столько раз и будет выведен в терминал текст

и рассмотрим и другие виды кнопок, которые предлагает нам PyQt5 - 

--- QCheckBox (Флажок)

Это кнопка с переключателем, которая может быть установлена (выбрана) или сброшена (не выбрана). Используется для выбора "Да" или "Нет" в форме, или для выбора нескольких опций одновременно -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QCheckBox, QVBoxLayout

def on_checkbox_state_change():
    if checkbox.isChecked():
        print("Checked")
    else:
        print("Unchecked")

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QCheckBox Example")

layout = QVBoxLayout()

checkbox = QCheckBox("Option 1")
checkbox.stateChanged.connect(on_checkbox_state_change)

layout.addWidget(checkbox)
window.setLayout(layout)

window.show()
sys.exit(app.exec())
---
- checkbox isChecked - это проверка того, нажали ли на кнопку, а если нажали, то произойдет вывод в терминал.

--
checkbox = QCheckBox("Option 1")
----
- это создание кнопки.

--- QRadioButton (Радиокнопка)

Радиокнопки используются, когда из набора опций можно выбрать только одну. Радиокнопки обычно группируются, и только одна из них может быть выбрана в группе -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QRadioButton, QVBoxLayout

def on_radio_button_selected():
    if radio_button1.isChecked():
        print("Option 1 selected")
    elif radio_button2.isChecked():
        print("Option 2 selected")

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QRadioButton Example")

layout = QVBoxLayout()

radio_button1 = QRadioButton("Option 1")
radio_button2 = QRadioButton("Option 2")

radio_button1.toggled.connect(on_radio_button_selected)
radio_button2.toggled.connect(on_radio_button_selected)

layout.addWidget(radio_button1)
layout.addWidget(radio_button2)

window.setLayout(layout)
window.show()
sys.exit(app.exec())
----

************************************

13.6 - Что такое виджеты?

Виджеты в PyQt5 — это графические элементы интерфейса пользователя (GUI), которые можно использовать для создания окон, кнопок, текстовых полей, ползунков и других интерактивных компонентов. Виджеты представляют собой основную строительную часть любого графического интерфейса в PyQt5, и все элементы управления, такие как кнопки или поля ввода, являются виджетами.

Основные виджеты PyQt5:
- QWidget: Базовый класс для всех виджетов. Его мы уже рассмотрели.
- QPushButton: Кнопка. Его мы уже рассмотрели.
- QLabel: Метка для отображения текста или изображений. Его мы уже рассмотрели.
- QLineEdit: Поле для ввода текста.
- QTextEdit: Многострочное текстовое поле.
- QCheckBox: Флажок. Его мы уже рассмотрели.
- QRadioButton: Радиокнопка. Его мы уже рассмотрели.
- QSlider: Ползунок для выбора значений.
- QComboBox: Выпадающий список.

Остается рассмотреть QLineEdit, QTextEdit, QSlider и QComboBox -

--- QLineEdit предоставляет поле для ввода текста, которое часто используется в формах -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QLineEdit, QVBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QLineEdit Example")

layout = QVBoxLayout()

line_edit = QLineEdit()  # Создаем поле для ввода текста
line_edit.setPlaceholderText("Enter your text here")  # Текст-подсказка

layout.addWidget(line_edit)
window.setLayout(layout)

window.show()
sys.exit(app.exec())
----

--- QTextEdit в PyQt5 — это виджет для многострочного текстового редактирования, который позволяет пользователю вводить, редактировать и форматировать текст. В отличие от QLineEdit, который ограничен одной строкой текста, QTextEdit поддерживает несколько строк и различные форматы текста (например, жирный шрифт, курсив, подчеркивание) -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QTextEdit, QVBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QTextEdit Example")

layout = QVBoxLayout()

# Создаем виджет QTextEdit
text_edit = QTextEdit()
text_edit.setPlaceholderText("Enter your text here...")

# Добавляем текстовое поле в макет
layout.addWidget(text_edit)

window.setLayout(layout)
window.show()
sys.exit(app.exec())
----

также пример с HTML, все для того же QTextEdit -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QTextEdit, QVBoxLayout

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QTextEdit HTML Example")

layout = QVBoxLayout()

# Создаем виджет QTextEdit
text_edit = QTextEdit()

# Устанавливаем HTML-контент в текстовое поле
html_content = """
<h1>Title</h1>
<p>This is a paragraph with <b>bold</b> and <i>italic</i> text.</p>
"""
text_edit.setHtml(html_content)

layout.addWidget(text_edit)
window.setLayout(layout)

window.show()
sys.exit(app.exec())
----

также посмотрим, как забирать текст из поля -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QTextEdit, QPushButton, QVBoxLayout

def get_text():
    # Получаем обычный текст
    print("Plain Text:")
    print(text_edit.toPlainText())

    # Получаем HTML текст
    print("HTML Text:")
    print(text_edit.toHtml())

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QTextEdit Get Text Example")

layout = QVBoxLayout()

text_edit = QTextEdit()
button = QPushButton("Get Text")
button.clicked.connect(get_text)

layout.addWidget(text_edit)
layout.addWidget(button)

window.setLayout(layout)
window.show()

sys.exit(app.exec())
----

--- QSlider — это виджет, который позволяет пользователю выбирать значения, перемещая ползунок вдоль заданной оси (горизонтальной или вертикальной). Он обычно используется для выбора числового значения в пределах определенного диапазона -
--
- тут в коде - 
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QSlider, QLabel, QVBoxLayout
from PyQt5.QtCore import Qt
----
-
sys: Используется для запуска и завершения приложения.

QApplication: Основной класс для любого PyQt5-приложения, который управляет событием GUI.

QWidget: Базовый виджет, который используется в качестве контейнера для интерфейса.

QSlider: Виджет ползунка для выбора значения.

QLabel: Метка, отображающая текст или значение.

QVBoxLayout: Вертикальный компоновщик, который упорядочивает виджеты сверху вниз.

Qt: Модуль для работы с параметрами GUI (например, ориентация ползунка).

--
def on_slider_value_changed(value):
    label.setText(f"Slider Value: {value}")
----
- Эта функция вызывается каждый раз, когда пользователь изменяет значение ползунка.
Она принимает новое значение ползунка и обновляет текст метки label, чтобы показать текущее значение.

--
slider = QSlider(Qt.Horizontal)  # Горизонтальный ползунок
slider.setMinimum(0)  # Минимальное значение
slider.setMaximum(100)  # Максимальное значение
slider.setValue(50)  # Начальное значение
----
- 
QSlider(Qt.Horizontal) создает ползунок, ориентированный горизонтально.

setMinimum(0) устанавливает минимальное значение ползунка.

setMaximum(100) устанавливает максимальное значение ползунка.

setValue(50) устанавливает начальное значение ползунка на 50.


--
label = QLabel(f"Slider Value: {slider.value()}")
----
-
QLabel создается для отображения текста. Текст отображает текущее значение ползунка (изначально 50).
slider.value() возвращает текущее значение ползунка и вставляется в текст метки.

--
slider.valueChanged.connect(on_slider_value_changed)
----
-
valueChanged — это сигнал, который генерируется при изменении значения ползунка.
connect(on_slider_value_changed) связывает этот сигнал с функцией on_slider_value_changed, которая будет выполнена при изменении значения ползунка.

--- QComboBox — это виджет, который предоставляет пользователю возможность выбрать одно значение из выпадающего списка. Можно добавить несколько элементов в список, и пользователь сможет выбрать один из них -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QComboBox, QLabel, QVBoxLayout

def on_combobox_changed(value):
    label.setText(f"Selected: {value}")

app = QApplication(sys.argv)

window = QWidget()
window.setWindowTitle("QComboBox Example")

layout = QVBoxLayout()

# Создаем выпадающий список
combobox = QComboBox()
combobox.addItem("Option 1")  # Добавляем элементы в выпадающий список
combobox.addItem("Option 2")
combobox.addItem("Option 3")

# Метка для отображения выбранного элемента
label = QLabel("Selected: Option 1")

# Обрабатываем изменение выбора
combobox.currentTextChanged.connect(on_combobox_changed)

layout.addWidget(combobox)
layout.addWidget(label)

window.setLayout(layout)
window.show()
sys.exit(app.exec())
----
-
QComboBox — это виджет выпадающего списка, который позволяет пользователю выбирать один из нескольких элементов.

addItem() добавляет элементы в список. В данном случае добавляются "Option 1", "Option 2" и "Option 3".

QLabel — это виджет для отображения текста. Изначально текст метки устанавливается как "Selected: Option 1", потому что первый элемент в списке выбран по умолчанию.

currentTextChanged — это сигнал, который генерируется, когда пользователь выбирает новый элемент в выпадающем списке.

connect(on_combobox_changed) связывает этот сигнал с функцией on_combobox_changed, которая обновляет текст метки.

************************************

13.7 - Реальные проекты, написанные на PyQT5

В данном разделе мы будем рассматривать различные проекты, которые пишутся на PyQT5. Начнем пожалуй, с самого важного и интересного. С калькулятора -
--
import sys
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QGridLayout, QLineEdit, QPushButton
from PyQt5.QtCore import Qt  # Добавляем этот импорт для использования Qt.AlignRight

class Calculator(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Calculator")
        self.setGeometry(100, 100, 300, 400)

        # Основной макет
        main_layout = QVBoxLayout()

        # Поле для ввода и отображения результата
        self.display = QLineEdit()
        self.display.setReadOnly(True)
        self.display.setAlignment(Qt.AlignRight)  # Используем выравнивание текста справа
        self.display.setFixedHeight(50)
        main_layout.addWidget(self.display)

        # Сетка для кнопок
        grid_layout = QGridLayout()

        # Определяем кнопки
        buttons = {
            '7': (0, 0), '8': (0, 1), '9': (0, 2), '/': (0, 3),
            '4': (1, 0), '5': (1, 1), '6': (1, 2), '*': (1, 3),
            '1': (2, 0), '2': (2, 1), '3': (2, 2), '-': (2, 3),
            '0': (3, 0), 'C': (3, 1), '=': (3, 2), '+': (3, 3)
        }

        # Создаем кнопки и добавляем их в сетку
        for btn_text, pos in buttons.items():
            button = QPushButton(btn_text)
            button.setFixedSize(60, 60)
            grid_layout.addWidget(button, pos[0], pos[1])
            button.clicked.connect(self.on_button_click)

        main_layout.addLayout(grid_layout)
        self.setLayout(main_layout)

    def on_button_click(self):
        button = self.sender()
        text = button.text()

        # Если нажата кнопка "C", очищаем дисплей
        if text == 'C':
            self.display.setText('')
        # Если нажата кнопка "=", выполняем вычисление
        elif text == '=':
            try:
                result = str(eval(self.display.text()))  # eval выполняет строку как выражение
                self.display.setText(result)
            except Exception:
                self.display.setText('Error')
        # В любом другом случае добавляем текст на дисплей
        else:
            self.display.setText(self.display.text() + text)

# Запуск приложения
app = QApplication(sys.argv)
window = Calculator()
window.show()
sys.exit(app.exec_())
----



































******************

DA itProgger - 
https://www.youtube.com/playlist?list=PLDyJYA6aTY1kcb2fIGFZ9064fi-u1sLyf

https://itproger.com/course/data-analytics

1 - 

NumPy 
Pandas
Matplotlib 
Seaborn 
Plotly

- аналитика данных - это изучение прошлого и настоящего 
- дата саенс - создание моделей машинного обучения для предсказания будущего 

2 -

создать новый проект в PyCharm 

в терминале - 
--
pip install numpy 
----

--
import numpy as np 

arr = np.array([1, 2, 3, 4, 5])

matrix = np.array([
    [1, 2, 3],
	[4, 5, 6],
	[7, 8, 9]
])

print(arr * 2)
print(matrix * 2)
----
[ 2  4  6  8 10]
[[ 2  4  6]
 [ 8 10 12]
 [14 16 18]]
------
- каждый элемент массива будет умножен на 2 

анализ з/п сотрудников компании - 
--
import numpy as np 


















docker -
https://www.youtube.com/watch?v=KWn3f3xJkCE

перейти в папку проекта -
cd papka_proecta 

npm init 

npm i express 

в папке проекта создать файл - 
--
Dockerfile 
--
FROM node:20.11.1

2-50



















БРАУЗЕРНЫЕ НОДЫ - Доход в крипте без вложений -
https://www.youtube.com/watch?v=ONteW4Z3v0w

cryptorank.io/price/nodepay 

тут нода - это расширение для браузера (версии для - ПК, android, ios)

поддерживают инфраструктуру сети 

11-11











































<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

xakep.ru - Иван Сараев - 4 статьи по python - 
https://xakep.ru/author/solprogram/

1 статья - 

переменные - 
int 
float 
str 
bool 
None 
list 
dict 
tuple 
set 
...

условный оператор - if - elif - elif - .... - else 

print()
input()

a.lower()
a.upper()

list - 
a = [1, 2, 3, 'a, 'b', 'Hello', True]

a.append() 

a.sort() 

срезы - [::]

циклы - 
for  
while 

range() -
--
for i in range(5):
    print(i)
----

Практическая задача: мониторим буфер обмена
А теперь от учебных примеров перейдем к чему-нибудь интересному! В кон­це концов, мы ведь изучаем программирование не просто из любопытства. Давай напишем программу, которая будет следить за тем, что происходит в буфере обмена.

Од­на из силь­ных сто­рон Python — это огромная база готовых модулей, которые мож­но брать и под­клю­чать к сво­им прог­раммам. Что­бы их уста­новить и исполь­зовать внут­ри сво­их прог­рамм, мож­но заюзать менед­жер пакетов под наз­вани­ем pip. Будем счи­тать, что pip у тебя уже уста­нов­лен.

Пер­вым делом ста­вим при помощи pip модуль, который отве­чает за работу с буфером обме­на. 

В Windows это будет вот такая коман­да:
pip install pyperclip

В Linux — слег­ка дру­гая:
pip3 install pyperclip

Пе­рехо­дим к кодиро­ванию. Наша прог­рамма будет монито­рить буфер обме­на и печатать на экра­не любой текст, который копиру­ет поль­зователь. Пояс­нения я дал в виде ком­мента­риев, они в Python отби­вают­ся зна­ком # в начале стро­ки.
--
# Подключим модуль для работы с буфером обмена
import pyperclip
# Подключим модуль для работы с системным временем
import time
# Задаем переменную old и присваиваем ей пустую строку
old = ''
# Начнем бесконечный цикл слежения за буфером обмена
while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()
    # Если полученное содержимое не равно предыдущему, то:
    if(s != old):
        # печатаем его
        print(s)
        # в переменную old записываем текущее пойманное значение
        # чтобы в следующий виток цикла не повторяться и не печатать то, что уже поймано
        old = s
    # В конце витка цикла делаем паузу в одну секунду, чтобы содержимое буфера обмена успело прогрузиться
    time.sleep(1)
----

Домашнее задание
Да­вай я дам тебе пароч­ку посиль­ных заданий на дом, что­бы ты мог поуп­ражнять­ся сам.
1
Сде­лай прог­рамму, которая вычис­ляет твой иде­аль­ный вес в зависи­мос­ти от рос­та и воз­раста. Най­ди соот­ветс­тву­ющую фор­мулу в поис­ковых сис­темах и реали­зуй усло­вие для рас­чета. Пиво пивом, а за здо­ровь­ем нуж­но сле­дить!
2
На­пиши прог­рамму, которая в цик­ле монито­рит буфер обме­на, пери­оди­чес­ки получая из него текст с помощью pyperclip.paste(), и, если видит, что кем‑то был ско­пиро­ван email, заменя­ет этот email дру­гим, заранее про­писан­ным в коде, помещая его в буфер обме­на коман­дой pyperclip.copy('coolhacker@xakep.ru').

1 -
--
rost = int(input('Введите ваш рост в см.:   '))
vozrast = int(input('Введите ваш возраст:   '))

res = 0
if vozrast >= 40:
    res = rost - 100
else:
    res = rost - 110

print(res)
----

2 -
--
import pyperclip
import time

while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()

    if '@' in s:
        pyperclip.copy('xxx@xxx.com')
        time.sleep(1)
----



2 статья - 

переб­рал сло­варь, что­бы заменить каж­дое из слов (key) на соот­ветс­тву­ющее зна­чение из сло­варя (slova[key]):
--
s = 'Все лето мы пили пиво. Вот как-то открываю дверь, а на пороге Чебурашка, весь такой пьяный-пьяный, и бутылка из кармана торчит.'

slova = {'пили':'читали', 'пиво':'книги', 'пьяный':'начитанный', 'бутылка':'энциклопедия'}


for key in slova:
    s = s.replace(key, slova[key])
print(s)
----

replace() удоб­но исполь­зовать, что­бы начис­то уда­лить какие‑то сло­ва из стро­ки. Для это­го будем заменять их пус­той стро­кой (если открыть и зак­рыть кавыч­ку, то получит­ся пус­тая стро­ка):
--
s = '''Я не люблю пить пиво.
Оно невкусное и неполезное!'''

s = s.replace('не','')
print(s)
----

Что­бы получить количес­тво сим­волов в стро­ке, исполь­зует­ся фун­кция len() -
--
s = 'Если очень вам неймется, код пишите как придется!'
n = len(s)
print(n)
----

от строк мож­но брать сре­зы как от мас­сивов, если ука­зать начало и конец подс­тро­ки в квад­ратных скоб­ках пос­ле перемен­ной. Позиция начина­ется с нуля.
--
s = 'Меня зовут Бонд, Джеймс Бонд'
a = s[11:15]
print('Фамилия: ' + a)
----

Пред­положим, тебе нуж­но най­ти в спис­ке стро­ки, которые начина­ются на https. Переби­раем их с помощью for, для каж­дой про­веря­ем, сов­пада­ют ли пер­вые пять зна­ков со стро­кой https, и если да, то выводим стро­ку -
--
values = ['httpsaaaaa', 'aaa', 'httpbbbb', 'httpsccccc', 'bbb']
zn = 'https' 

for i in values:
	if i[:5] == zn:
		print(i)

print('end')
----
httpsaaaaa
httpsccccc
end
------

подсчитать количество - 
--
n = lst.count('hello')
----

Иног­да в начале или в кон­це стро­ки могут быть лиш­ние про­белы или перено­сы строк. Давай уда­лим их спе­циаль­ной коман­дой .strip() -
--
s = ' Пива много не бывает!  \n'
s = s.strip()
print('***')
print(s)
print('***')
----
***
Пива много не бывает!
***
------

Пе­рено­сы строк мож­но добавить с помощью сим­волов \n (исполь­зует­ся во всех ОС) либо \r\n (в Windows). Есть и дру­гие спец­симво­лы. Нап­ример, \t — знак табуля­ции

Что­бы опре­делить наличие подс­тро­ки в стро­ке s, мож­но исполь­зовать метод .find() - 
--
n = s.find('строка, которую ищем')
----
- Ес­ли иско­мая подс­тро­ка най­дена, то в перемен­ную n попадет ее позиция в стро­ке, а если не най­дена, n ста­нет рав­ной -1.

поп­робу­ем опре­делить, есть ли в стро­ке адрес элек­трон­ной поч­ты с Xakep.ru, то есть будем искать подс­тро­ку @xakep.ru.

Но сна­чала нам понадо­бит­ся еще один стро­ковый метод — .split(). Он поз­воля­ет раз­делить стро­ку на час­ти, ука­зав в качес­тве аргу­мен­та стро­ку‑раз­делитель. Нап­ример, s.split('\n') раз­делит текст на абза­цы по сим­волу перено­са стро­ки. Если же оста­вить скоб­ки пус­тыми, то будет исполь­зован раз­делитель по умол­чанию — про­бел.
--
s = 'Это обычная строка, а в ней адрес почты vasya@xakep.ru'
words = s.split()
for w in words:
    n = w.find('@xakep.ru')
    if n != -1:
        print('Найден e-mail: ' + str(w) + ' в позиции ' + str(n))
----

Ме­тод .join() поз­воля­ет, наобо­рот, скле­ивать стро­ки. Он при­нима­ет спи­сок и воз­вра­щает стро­ку, где каж­дый эле­мент спис­ка соеди­нен с дру­гим через стро­ку, у которой ты выз­вал этот метод -
--
s = 'вирус внедряется '
list1 = ['раз, ', 'два, ', 'три...']
print(s + s.join(list1))
----
вирус внедряется раз, вирус внедряется два, вирус внедряется три...
------

lst.split()

'*'.join(lst)

метод .format() для форматирования строк - 
Мы можем вста­вить в стро­ку пар­ные фигур­ные скоб­ки, а затем выз­вать стро­ковый метод .format() и передать ему нуж­ные зна­чения в поряд­ке их под­ста­нов­ки в стро­ку.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(name, age, address)
print(info)
----

Мож­но передать информа­цию спис­ком через звез­дочку:
--
data = ['Вася Пупкин', 20, 'улица Пушкина, дом Колотушкина']
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(*data)
print(info)
----

Способ 2 — через f-строки -
Дру­гой вари­ант — написать бук­ву f перед стро­кой и затем в фигур­ных скоб­ках ука­зывать непос­редс­твен­но перемен­ные.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = f'Имя: {name.upper()}. Возраст: {age}. Адрес: {address}'
print(info)
----

Глав­ное пре­иму­щес­тво это­го спо­соба в том, что ты можешь вста­вить зна­чение в стро­ку нес­коль­ко раз. К тому же мож­но менять зна­чения пря­мо в фигур­ных скоб­ках: спер­ва Python выпол­нит все дей­ствия в них, а затем под­ста­вит получен­ный резуль­тат в стро­ку. Так, метод .upper() в при­мере выше дела­ет все бук­вы заг­лавны­ми

Что­бы работать с фай­лом, его нуж­но открыть. Для это­го слу­жит фун­кция open(), а работа­ет она вот так:
--
f = open('имя файла с путем и расширением', 'режим работы с файлом', encoding='Кодировка текста')
----

Ре­жимов работы с фай­лами нес­коль­ко, но тебя инте­ресу­ет в основном:

r — открыть файл для чте­ния из него информа­ции;
w — открыть файл для записи в него информа­ции (соз­дает новый файл);
a — открыть файл для дозапи­си информа­ции в конец фай­ла (дописы­вает информа­цию в конец сущес­тву­юще­го фай­ла);
a+ — дозапись и чте­ние.

Что­бы избе­жать проб­лем с путями в Windows, исполь­зуй в них двой­ной слеш \\, а так­же перед откры­вающей кавыч­кой пути фай­ла ставь бук­ву u, ука­зыва­ющую на то, что стро­ка в кодиров­ке Unicode:
--
f = open(u'D:\\test.txt', 'r', encoding='UTF-8')
----

Чи­тать стро­ки из фай­ла мож­но методом .read():
--
f = open('test.txt', 'r', encoding='UTF-8')
s = f.read()
print(s)
----

Как вари­ант — мож­но пос­ледова­тель­но читать из фай­ла отдель­ные стро­ки с помощью цик­ла for:
--
f = open('test.txt', 'r', encoding='UTF-8')
for x in f:
    print(x)
----

Пос­ле того как работа с фай­лом закон­чена, нуж­но зак­рыть его.
--
f.close()
----

















