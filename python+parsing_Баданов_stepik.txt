ЭТИ КУРСЫ ТУТ - 

python - 
https://stepik.org/course/209150/promo

parsing - 
https://stepik.org/course/209546/promo

взял 07.12.2024 - 450 руб. + 285 руб. 

это Баданов - у него ранее покупал курс по DE



************************************
************************************
************************************

КУРС - Python Engineer с нуля до junior

************************************
************************************
************************************

Для возможности задавать вопросы преподавателям, а также состоять в группе единомышленников и одногруппников, можно вступить в чат по ссылке -
https://t.me/+lIvySxhZXGZhM2My

По ссылке можно и нужно отслеживать изменения курса -
https://t.me/stepik_hello_py

************************************

2.1 - Что такое программирование?

нужно только желаниие обучаться 

чат-боты, ИИ - изучение python не углубленно, а широко, и потом выбрать ту область которую захочешь 

нужен только один монитор 

в программировании сложно, но не очень - 
python + библиотеки к нему 

************************************

2.2 - Актуальность Python

+

************************************

2.3 - Что можно сделать на Python

+

************************************

2.4 - Что такое PEP 8 и почему это важно

PEP 8 (Python Enhancement Proposal 8) — это официальный стиль кодирования для языка программирования Python. Этот документ был предложен Гвидо ван Россумом, создателем Python, и Тимом Петерсом, одним из ключевых разработчиков языка, и описывает правила форматирования кода, которые помогают сделать код Python более читаемым и единообразным.

Основные положения PEP 8:

- Отступы: Использование четырёх пробелов для отступов. Это помогает поддерживать единообразие кода и делает его легко читаемым. Важно избегать смешивания пробелов и табуляций.

- Максимальная длина строки: Рекомендуется, чтобы строки кода не превышали 79 символов. Это облегчает чтение кода на экранах с небольшой шириной и помогает в многооконной работе.

- Пробелы в выражениях и операторах: PEP 8 описывает, где следует и не следует использовать пробелы в коде. Например, пробелы не используются внутри скобок, но должны быть вокруг операндов в выражениях.

- Именование переменных и функций: PEP 8 рекомендует использовать нижний регистр с подчеркиваниями (snake_case) для переменных и функций, а для классов — стиль CamelCase.

- Импорт модулей: Все импорты должны быть в начале файла, отдельно от остального кода. Импорты должны быть структурированы в определённом порядке: стандартные библиотеки, сторонние библиотеки, и затем модули самого проекта.

- Документирование: PEP 8 рекомендует использовать строки документации (docstrings) для описания назначения функций, классов и методов.



Почему PEP 8 важен:

1. Читаемость кода: Одной из главных целей PEP 8 является улучшение читаемости кода. Когда код написан в соответствии с единым стилем, его легче читать и понимать. Это особенно важно в командной разработке, где код пишет и поддерживает множество людей.

2. Поддержка и сопровождение кода: Когда код следует единым правилам форматирования, его проще поддерживать. Новым разработчикам легче подключиться к проекту и начать работу с существующим кодом, если он структурирован по понятным и общепринятым правилам.

3. Снижение ошибок: Следование PEP 8 может помочь снизить вероятность появления ошибок. Например, использование четырёх пробелов для отступов вместо табуляций помогает избежать проблем, связанных с различной интерпретацией отступов в разных текстовых редакторах.

4. Инструменты автоматической проверки: Существуют инструменты, такие как flake8, pylint и black, которые автоматически проверяют и форматируют код в соответствии с PEP 8. Использование этих инструментов помогает поддерживать качество кода на высоком уровне и следить за его соответствием общепринятым стандартам.

5. Профессионализм: Код, написанный в соответствии с PEP 8, демонстрирует профессиональный подход к программированию. Это показывает, что разработчик заботится о качестве своего кода и уважает работу других, следуя общим стандартам.


В Pycharm есть удобное сочетание клавиш Ctrl + alt + L для быстрого исправления

************************************

2.5 - Установка всего необходимого

Для начала перейдем по ссылке - https://www.jetbrains.com/pycharm/download/?section=mac
Далее на странице найдем версию Community Edition, она бесплатна.

У Вас проектов может не быть, если Вы раньше не работали с этой программой. Поэтому нажимаем на кнопку "New Project".

Далее конфигурируем проект. Введем название, выберем путь, где его сохранить. В Python Version можно указать любую версию Python и она скачается. Скачивайте больше 3.10.

Все, что слева находится  является корнем проекта. Папки внутри директории .venv и External Libraries являются служебными. Создадим первый скрипт, чтобы проверить, что все установилось корректно.

Для этого нажмем на название проекта, щелкнем правой кнопкой мыши, New, Python File.

Введем название нашего скрипта. У меня это будет main. Обязательно на английском.

Preferences - это настройки. 

************************************

3.1 - Переменные

все файлы python называются скриптами 

переменная - это определенная область памяти, на которую мы можем сослаться 

--
main.py 
--
print("Hello, world!")

count_apple = 5 
# область в памяти на которую ссылается переменная - count_apple 

number = 42
# переменные называть по смыслу 

res = (count_apple + number)
print(res)

# слишком длинные переменные создавать не нужно 
----
Hello, world!
47
------

переменная - это именованная область памяти, которая может хранить некоторое значение

--
name = "Alice"  # Переменная 'name' хранит текст "Alice"
age = 25        # Переменная 'age' хранит число 25
----

определим некоторый список правил, как необходимо переменные именовать.

1. Именуйте переменные так, за что они отвечают. Если это имя, то название переменной будет name, а не n, anton и т.д. -
--
name = "Ivan"
----

2. Не используйте какие-то цифры, специальные символы и так далее, особенно в начале переменной

Если у Вас длинное название переменной, используйте 2 стиля на выбор, а именно - 

- snake_case — слова разделяются нижними подчеркиваниями, каждое слово пишется с маленькой буквы. Часто используется в Python: user_name, total_price 

- camelCase — первое слово пишется с маленькой буквы, а каждое последующее слово начинается с заглавной. Например, userName, totalPrice

Также не используйте в качестве названия переменных ключевые слова, они же служебные. Мы с ними далее познакомимся, но это слова по типу - class, if, for, return

По длине у названия переменных ограничений нет, но лучше использовать не длинные конструкции

Константа — это фиксированное значение, которое не изменяется в течение выполнения программы. В отличие от переменных, значение константы задается один раз и остается неизменным на протяжении всей работы программы.
Но их в Python нет - Поэтому используем следующую конструкцию.
Константы принято называть заглавными буквами, используя символ подчеркивания для разделения слов.
--
PI = 3.14159
MAX_USERS = 100
URL = "https://example.com"
----

Python не запрещает изменение значений констант, это просто конвенция. Вы можете изменить значение константы, но делать это не рекомендуется, так как это нарушает логику использования констант

************************************

3.2 - Типы данных и комментарии

--
count_apple = 5 
name = "Gleb"
pi = 3.14 
enabled = True 

# это комментарий 

'''
это 
тоже 
комментарий
'''

# проверить тип переменной - 
print(type(enabled))
----
<class 'bool'>
------

Рассмотрим примитивные типы данных -

- int (целые числа, он же integer): представляют собой числа без дробной части. Пример - 5, -10

- float (числа с плавающей запятой): представляют собой вещественные числа, то есть числа с дробной частью. Пример - 3.14, -0.001

- double (расширенная точность): в некоторых языках это тип для чисел с плавающей запятой повышенной точности. Пример: 3.1415926535

- bool (булевый тип, он же boolean): принимает два значения — True (истина) и False (ложь). Пример - is_valid = True

- string (строка): представляют собой последовательность символов. Пример: "Hello", "12345"

Но, что если мы хотим узнать тип данных, но выводить его в терминал не хотим? Для этого зажмите кнопку ctrl и наведите курсор на название любой переменной

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах

иногда полезно знать, сколько памяти занимает переменная в Python. Это можно сделать с помощью встроенной функции sys.getsizeof() из модуля sys. Эта функция возвращает размер объекта (переменной) в байтах -
--
import sys

x = 10
y = 3.14
z = "Hello, world!"

print("Размер переменной x (int):", sys.getsizeof(x), "байт")
print("Размер переменной y (float):", sys.getsizeof(y), "байт")
print("Размер переменной z (str):", sys.getsizeof(z), "байт")
----
Размер переменной x (int): 28 байт
Размер переменной y (float): 24 байт
Размер переменной z (str): 62 байт
------

Размер переменной типа int в Python зависит от значения числа. В CPython малые целые числа имеют базовый размер 28 байт, но этот размер увеличивается по мере роста числа, так как Python динамически увеличивает количество байт, чтобы вместить большие значения -
--
import sys

x = 1
y = 1000
z = 10**100  # Очень большое число

print("Размер переменной x (1):", sys.getsizeof(x), "байт")
print("Размер переменной y (1000):", sys.getsizeof(y), "байт")
print("Размер переменной z (10**100):", sys.getsizeof(z), "байт")
----
Размер переменной x (1): 28 байт
Размер переменной y (1000): 28 байт
Размер переменной z (10**100): 72 байт
------

Размер переменной типа float фиксирован и обычно составляет 24 байта (в CPython), так как они реализованы с использованием 64-битных чисел с плавающей запятой (double precision) -
--
import sys

f = 3.14
print("Размер переменной f (float):", sys.getsizeof(f), "байт")
----
Размер переменной f (float): 24 байт
------

Размер строки в Python зависит от её длины, так как каждая строка хранится как последовательность символов Unicode. Базовый размер строки — около 49 байт для пустой строки, затем добавляется по 1 байту за каждый символ в строке -
--
import sys

s1 = ""
s2 = "a"
s3 = "Hello, World!"

print("Размер пустой строки:", sys.getsizeof(s1), "байт")
print("Размер строки 'a':", sys.getsizeof(s2), "байт")
print("Размер строки 'Hello, World!':", sys.getsizeof(s3), "байт")
----
Размер пустой строки: 49 байт
Размер строки 'a': 50 байт
Размер строки 'Hello, World!': 62 байт
------

************************************

3.3 - Ввод и вывод информации 

--
age = 5 
name = 'Jon'
print(age, name)
----
5 Jon 
------

\n - перевод на новую строку 

input() - по умолчанию всегда str 

--
name = input('Enter your name:   ')
age = int(input('Enter age:   '))

print(name, str(age))
----

sep=' ,'

end='!'

************************************

3.4 - Операции с переменными 

--
a = 4 
b = 45 
print(a * b)

a = 56 
print(a)
----

+
-
*
**
/
//
%

f-строки - 
--
age = 45
name = 'Alex'

print(f'Hello {name} - {age} age')
----
Hello Alex - 45 age
------

приоритет арифметических операций - как и в математике 

нельзя складывать str с int или float 

int() — преобразует данные в целое число
float() — преобразует данные в число с плавающей запятой
str() — преобразует данные в строку
bool() — преобразует данные в булево значение (True или False)

************************************

4.1 - Условный оператор if/else

pep8 - 4 пробела или TAB 

--
number = 15

if (number > 0):
	print('number > 0')
elif (number < 0):
	print('number < 0')
else:
	print('number = 0')
----

операторы сравнения -
>
<
>=
<=
==
!= 

--
number = int(input("Enter number:   "))

if (number % 2 == 0):
	print(f'{number} - четное число')
else:
	print(f'{number} - нечетное число')
----

and - И
or  - ИЛИ
not - НЕ 

************************************

4.2 - Цикл for

цикл в C++ выглядит примерно так - 
--
for (i=0, i<5, i++):
	print(i)
----
- там синтаксис немного другой, но условия так прописываются 

--
for i in range(2, 11, 2):
	print(i)
----
- первое включительно, второе не включительно, третье это шаг 

левая граница диапазона всегда включается, а правая всегда не включается -
--
for i in range(10, 1, -1):
    print(i)
----
10
9
8
7
6
5
4
3
2
------

--
st = 'abcde' 

for i in st:
    print(i)
----
a
b
c
d
e
------

выведем все нечетные числа от 0 до 50 - 
--
for i in range(0, 51):
	if i % 2 != 0:
	    print(i)
----

************************************

4.3 - Цикл while 

for - заранее задает диапазон 
while - не задает диапазона, а прячет его под условием 

--
i = 1

while i <= 5:
    print(i)
	i += 1
----

--
check = True 

while check:
    age = int(input('Enter age:   '))
    if age == 18:
        print('Ok')
        check = False
----

continue - оператор продолжения (пропуска итерации)

break - оператор прерывания цикла 

pass - заглушка 

************************************

4.4 - Конструкция try/except (и осталось ещё 85 пунктов)

чаще всего try/except пользуются когда ошибка возникает и нам нужно её "простить" чтобы python её пропустил 

--
a = 5
b = 0
print(a/b)
print("Hello")
----
- будет ошибка и "Hello" напечатано не будет, и чтобы этого избежать можно предусмотреть ошибки -  

--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
----

--
try:
    age = int(input("Введите ваш возраст:   "))
    print(age)
except ValueError:
    print("Ошибка")
----

блоков except может быть несколько 

блок finally - выполняется всегда, в независимости от того, были ли ошибки или нет -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except ZeroDivisionError:
    print('No / ZERO')
except ValueError:
    print("Ошибка")
else:
    print(f'Результат {result}')
finally:
    print('Программа завершена')
----
- тут блок else выполняется в случае успеха try (то есть когда не обнаружено ошибок)

если у нас выскакивает ошибка которую мы в первый раз видим - мы можем её расшифровать -
--
try:
    num1 = int(input('Enter first number:   '))
    num2 = int(input('Enter second number:   '))
    result = num1 / num2
	print(f'Result - {result}')
except Exception as e:
    print(e)
----

try/except часто используется для открытия файлов (если файл открылся - то ОК, если не открылся - то не ОК)

пример использования try/except в цикле while для ввода числа - 
--
while True:
    try:
        num = int(input("Введите число (или 0 для выхода)"))
        if num == 0:
            break
        print(f'Вы ввели число {num}')
    except ValueError:
        print("Ошибка, введите корректное число")
----

Основные исключения, которые будут встречаться Вам чаще всего -
ValueError: Введено некорректное значение.
ZeroDivisionError: Попытка деления на ноль.
FileNotFoundError: Файл не найден.
TypeError: Неправильный тип данных для операции.

Блок try не может существовать без except или finally.

************************************

5.1 - Что такое изменяемые и неизменяемые типы данных?

Строки в Python — это последовательности символов, используемые для хранения и представления текстовой информации. В Python строки являются неизменяемыми (immutable), что означает, что после создания строки её содержимое нельзя изменить.

Неизменяемые типы данных (Immutable) -
Неизменяемые типы данных — это такие объекты, которые нельзя изменить после их создания. Любые операции, которые, кажется, изменяют значение, на самом деле создают новый объект.

Примеры неизменяемых типов данных:
Числа: int, float, complex
Логические значения: bool
Строки: str
Кортежи: tuple
Множества: frozenset
Изменяемые типы данных (Mutable) 

Изменяемые типы данных — это объекты, которые могут быть изменены после их создания. Операции с изменяемыми объектами могут менять их содержимое напрямую, не создавая новый объект.

Примеры изменяемых типов данных:
Списки: list
Словари: dict
Множества: set
Массивы (из библиотеки array)
Объекты пользовательских классов

что происходит со старыми объектами неизменяемых типов данных и можно ли получить к ним доступ?

Когда вы пытаетесь "изменить" значение неизменяемого объекта, Python создаёт новый объект с новым значением. Старый объект остаётся в памяти, но к нему можно получить доступ только через переменные, которые продолжают на него ссылаться. Например - 
--
s = "Hello"
s = s + " World"
----

Вначале переменная s ссылается на строку "Hello".
Когда вы делаете s + " World", создается новая строка, а переменная s теперь ссылается на новую строку "Hello World".
Старый объект "Hello" остаётся в памяти до тех пор, пока на него есть ссылки.
Если на старый объект больше нет ссылок (никакие переменные не указывают на него), Python в конечном итоге удалит его с помощью сборщика мусора. Этот механизм автоматически освобождает память, когда объекты больше не нужны.

************************************

5.2 А теперь про строки!

конкатенация (сложение, склеивание) строк - 
--
text1 = 'Hello'
text2 = "John"

print(text1 + ' ' + text2)
----
Hello John
------

индексы строк - [::]

умножение строк - 
--
text1 = 'Abcdefgh'

print(text1 * 3)
----
AbcdefghAbcdefghAbcdefgh
------

len() - считает количество символов - 
--
text1 = 'Abcdefgh'

print(len(text1))
----
8
------

************************************

5.3 - Методы строк 

text.upper()

text.lower()

text.capitalize() 

text.title() 

text.swapcase() 

text.strip() 

text.lstrip() 

text.rstrip() 

text.find('abc')
# возращает индекс первого входжения или -1 если нет вхождения 

--
text = "Hello, World"
print(text.index("World"))
----
7
------
- а тут если нет вхождения - вернет ошибку 

text.rfind('abc')
# возвращает индекс последнего(правого) вхождения или -1 

--
text = "banana"
print(text.count('a'))
----
3
------

--
text = "Hello, Python"
print(text.startswith("Hello"))
----
True 
------

--
text = "Hello, Python"
print(text.endswith("Python"))
----
True 
------

--
text = "yes my name John yes yes"
print(text.replace("yes", "no"))
print(text.replace("yes", ""))
----
no my name John no no
 my name John
------

--
text = "apple, banana, cherry"
fruits = text.split(",")
print(fruits)
----
['apple', ' banana', ' cherry']
------

--
text = "12345"
print(text.isdigit())
----
True 
------

--
text = "abc"
print(text.isalpha())
----
True 
------

--
text = "abc123"
print(text.isalnum())
----
True 
------

--
text = "     "
print(text.isspace())
----
True 
------

--
text = "hello"
print(text.islower())
----
True 
------

--
text = "HELLO"
print(text.isupper())
----
True 
------

--
text = "hello!123"
print(text.islower())

text = "HELLO!123"
print(text.isupper())
----
True 
True 
------
- но эти два метода проверяют только регистры букв 

--
text = "42"
print(text.zfill(5))
----
00042
------

--
text = "Python, Python"
print("Python" in text)
----
True 
------













































<<<<<<<<<<<<<<<<<<<<<>>>>>>>>>>>>>>>>>>>>>

xakep.ru - Иван Сараев - 4 статьи по python - 
https://xakep.ru/author/solprogram/

1 статья - 

переменные - 
int 
float 
str 
bool 
None 
list 
dict 
tuple 
set 
...

условный оператор - if - elif - elif - .... - else 

print()
input()

a.lower()
a.upper()

list - 
a = [1, 2, 3, 'a, 'b', 'Hello', True]

a.append() 

a.sort() 

срезы - [::]

циклы - 
for  
while 

range() -
--
for i in range(5):
    print(i)
----

Практическая задача: мониторим буфер обмена
А теперь от учебных примеров перейдем к чему-нибудь интересному! В кон­це концов, мы ведь изучаем программирование не просто из любопытства. Давай напишем программу, которая будет следить за тем, что происходит в буфере обмена.

Од­на из силь­ных сто­рон Python — это огромная база готовых модулей, которые мож­но брать и под­клю­чать к сво­им прог­раммам. Что­бы их уста­новить и исполь­зовать внут­ри сво­их прог­рамм, мож­но заюзать менед­жер пакетов под наз­вани­ем pip. Будем счи­тать, что pip у тебя уже уста­нов­лен.

Пер­вым делом ста­вим при помощи pip модуль, который отве­чает за работу с буфером обме­на. 

В Windows это будет вот такая коман­да:
pip install pyperclip

В Linux — слег­ка дру­гая:
pip3 install pyperclip

Пе­рехо­дим к кодиро­ванию. Наша прог­рамма будет монито­рить буфер обме­на и печатать на экра­не любой текст, который копиру­ет поль­зователь. Пояс­нения я дал в виде ком­мента­риев, они в Python отби­вают­ся зна­ком # в начале стро­ки.
--
# Подключим модуль для работы с буфером обмена
import pyperclip
# Подключим модуль для работы с системным временем
import time
# Задаем переменную old и присваиваем ей пустую строку
old = ''
# Начнем бесконечный цикл слежения за буфером обмена
while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()
    # Если полученное содержимое не равно предыдущему, то:
    if(s != old):
        # печатаем его
        print(s)
        # в переменную old записываем текущее пойманное значение
        # чтобы в следующий виток цикла не повторяться и не печатать то, что уже поймано
        old = s
    # В конце витка цикла делаем паузу в одну секунду, чтобы содержимое буфера обмена успело прогрузиться
    time.sleep(1)
----

Домашнее задание
Да­вай я дам тебе пароч­ку посиль­ных заданий на дом, что­бы ты мог поуп­ражнять­ся сам.
1
Сде­лай прог­рамму, которая вычис­ляет твой иде­аль­ный вес в зависи­мос­ти от рос­та и воз­раста. Най­ди соот­ветс­тву­ющую фор­мулу в поис­ковых сис­темах и реали­зуй усло­вие для рас­чета. Пиво пивом, а за здо­ровь­ем нуж­но сле­дить!
2
На­пиши прог­рамму, которая в цик­ле монито­рит буфер обме­на, пери­оди­чес­ки получая из него текст с помощью pyperclip.paste(), и, если видит, что кем‑то был ско­пиро­ван email, заменя­ет этот email дру­гим, заранее про­писан­ным в коде, помещая его в буфер обме­на коман­дой pyperclip.copy('coolhacker@xakep.ru').

1 -
--
rost = int(input('Введите ваш рост в см.:   '))
vozrast = int(input('Введите ваш возраст:   '))

res = 0
if vozrast >= 40:
    res = rost - 100
else:
    res = rost - 110

print(res)
----

2 -
--
import pyperclip
import time

while True:
    # Кладем в переменную s содержимое буфера обмена
    s = pyperclip.paste()

    if '@' in s:
        pyperclip.copy('xxx@xxx.com')
        time.sleep(1)
----



2 статья - 

переб­рал сло­варь, что­бы заменить каж­дое из слов (key) на соот­ветс­тву­ющее зна­чение из сло­варя (slova[key]):
--
s = 'Все лето мы пили пиво. Вот как-то открываю дверь, а на пороге Чебурашка, весь такой пьяный-пьяный, и бутылка из кармана торчит.'

slova = {'пили':'читали', 'пиво':'книги', 'пьяный':'начитанный', 'бутылка':'энциклопедия'}


for key in slova:
    s = s.replace(key, slova[key])
print(s)
----

replace() удоб­но исполь­зовать, что­бы начис­то уда­лить какие‑то сло­ва из стро­ки. Для это­го будем заменять их пус­той стро­кой (если открыть и зак­рыть кавыч­ку, то получит­ся пус­тая стро­ка):
--
s = '''Я не люблю пить пиво.
Оно невкусное и неполезное!'''

s = s.replace('не','')
print(s)
----

Что­бы получить количес­тво сим­волов в стро­ке, исполь­зует­ся фун­кция len() -
--
s = 'Если очень вам неймется, код пишите как придется!'
n = len(s)
print(n)
----

от строк мож­но брать сре­зы как от мас­сивов, если ука­зать начало и конец подс­тро­ки в квад­ратных скоб­ках пос­ле перемен­ной. Позиция начина­ется с нуля.
--
s = 'Меня зовут Бонд, Джеймс Бонд'
a = s[11:15]
print('Фамилия: ' + a)
----

Пред­положим, тебе нуж­но най­ти в спис­ке стро­ки, которые начина­ются на https. Переби­раем их с помощью for, для каж­дой про­веря­ем, сов­пада­ют ли пер­вые пять зна­ков со стро­кой https, и если да, то выводим стро­ку -
--
values = ['httpsaaaaa', 'aaa', 'httpbbbb', 'httpsccccc', 'bbb']
zn = 'https' 

for i in values:
	if i[:5] == zn:
		print(i)

print('end')
----
httpsaaaaa
httpsccccc
end
------

подсчитать количество - 
--
n = lst.count('hello')
----

Иног­да в начале или в кон­це стро­ки могут быть лиш­ние про­белы или перено­сы строк. Давай уда­лим их спе­циаль­ной коман­дой .strip() -
--
s = ' Пива много не бывает!  \n'
s = s.strip()
print('***')
print(s)
print('***')
----
***
Пива много не бывает!
***
------

Пе­рено­сы строк мож­но добавить с помощью сим­волов \n (исполь­зует­ся во всех ОС) либо \r\n (в Windows). Есть и дру­гие спец­симво­лы. Нап­ример, \t — знак табуля­ции

Что­бы опре­делить наличие подс­тро­ки в стро­ке s, мож­но исполь­зовать метод .find() - 
--
n = s.find('строка, которую ищем')
----
- Ес­ли иско­мая подс­тро­ка най­дена, то в перемен­ную n попадет ее позиция в стро­ке, а если не най­дена, n ста­нет рав­ной -1.

поп­робу­ем опре­делить, есть ли в стро­ке адрес элек­трон­ной поч­ты с Xakep.ru, то есть будем искать подс­тро­ку @xakep.ru.

Но сна­чала нам понадо­бит­ся еще один стро­ковый метод — .split(). Он поз­воля­ет раз­делить стро­ку на час­ти, ука­зав в качес­тве аргу­мен­та стро­ку‑раз­делитель. Нап­ример, s.split('\n') раз­делит текст на абза­цы по сим­волу перено­са стро­ки. Если же оста­вить скоб­ки пус­тыми, то будет исполь­зован раз­делитель по умол­чанию — про­бел.
--
s = 'Это обычная строка, а в ней адрес почты vasya@xakep.ru'
words = s.split()
for w in words:
    n = w.find('@xakep.ru')
    if n != -1:
        print('Найден e-mail: ' + str(w) + ' в позиции ' + str(n))
----

Ме­тод .join() поз­воля­ет, наобо­рот, скле­ивать стро­ки. Он при­нима­ет спи­сок и воз­вра­щает стро­ку, где каж­дый эле­мент спис­ка соеди­нен с дру­гим через стро­ку, у которой ты выз­вал этот метод -
--
s = 'вирус внедряется '
list1 = ['раз, ', 'два, ', 'три...']
print(s + s.join(list1))
----
вирус внедряется раз, вирус внедряется два, вирус внедряется три...
------

lst.split()

'*'.join(lst)

метод .format() для форматирования строк - 
Мы можем вста­вить в стро­ку пар­ные фигур­ные скоб­ки, а затем выз­вать стро­ковый метод .format() и передать ему нуж­ные зна­чения в поряд­ке их под­ста­нов­ки в стро­ку.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(name, age, address)
print(info)
----

Мож­но передать информа­цию спис­ком через звез­дочку:
--
data = ['Вася Пупкин', 20, 'улица Пушкина, дом Колотушкина']
info = 'Имя: {}. Возраст: {}. Адрес: {}'.format(*data)
print(info)
----

Способ 2 — через f-строки -
Дру­гой вари­ант — написать бук­ву f перед стро­кой и затем в фигур­ных скоб­ках ука­зывать непос­редс­твен­но перемен­ные.
--
name = 'Вася Пупкин'
age = 20
address = 'улица Пушкина, дом Колотушкина'
info = f'Имя: {name.upper()}. Возраст: {age}. Адрес: {address}'
print(info)
----

Глав­ное пре­иму­щес­тво это­го спо­соба в том, что ты можешь вста­вить зна­чение в стро­ку нес­коль­ко раз. К тому же мож­но менять зна­чения пря­мо в фигур­ных скоб­ках: спер­ва Python выпол­нит все дей­ствия в них, а затем под­ста­вит получен­ный резуль­тат в стро­ку. Так, метод .upper() в при­мере выше дела­ет все бук­вы заг­лавны­ми

Что­бы работать с фай­лом, его нуж­но открыть. Для это­го слу­жит фун­кция open(), а работа­ет она вот так:
--
f = open('имя файла с путем и расширением', 'режим работы с файлом', encoding='Кодировка текста')
----

Ре­жимов работы с фай­лами нес­коль­ко, но тебя инте­ресу­ет в основном:

r — открыть файл для чте­ния из него информа­ции;
w — открыть файл для записи в него информа­ции (соз­дает новый файл);
a — открыть файл для дозапи­си информа­ции в конец фай­ла (дописы­вает информа­цию в конец сущес­тву­юще­го фай­ла);
a+ — дозапись и чте­ние.

Что­бы избе­жать проб­лем с путями в Windows, исполь­зуй в них двой­ной слеш \\, а так­же перед откры­вающей кавыч­кой пути фай­ла ставь бук­ву u, ука­зыва­ющую на то, что стро­ка в кодиров­ке Unicode:
--
f = open(u'D:\\test.txt', 'r', encoding='UTF-8')
----

Чи­тать стро­ки из фай­ла мож­но методом .read():
--
f = open('test.txt', 'r', encoding='UTF-8')
s = f.read()
print(s)
----

Как вари­ант — мож­но пос­ледова­тель­но читать из фай­ла отдель­ные стро­ки с помощью цик­ла for:
--
f = open('test.txt', 'r', encoding='UTF-8')
for x in f:
    print(x)
----

Пос­ле того как работа с фай­лом закон­чена, нуж­но зак­рыть его.
--
f.close()
----

















